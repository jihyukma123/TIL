[Composing Software: An Introduction](https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea)

# The QUESTION most developers struggle to answer

소프트웨어 개발의 본질은 복잡한 문제를 작은 문제로 쪼개고, 작은 해결책들을 합쳐서 복잡한 문제에 대한 완전한 해답을 구축하는 것.

하지만 대부분의 개발자들은 이 `essence of software development`를 깊게 이해하지 못하고 있음.

아래의 질문을 나는 답할 수 있을까? 아직은 못한다.

- what is function composition?
- what is object composition?

# 근데 꼭 알아야함?

모른다고 해서 피할수가 없다는게 문제임. Composition은 필연적으로 발생하는데, 잘 모르니까 이상하게 하는게 문제다.

버그가 있는 코드, 동료가 이해하기 힘든 코드를 작성함.

어차피 매일매일 해야되는 일이라면, 무슨 짓을 하는지 제대로 알고 하는게 좋겠지.

다시 한 번 말하지만, 소프트웨어 개발을 큰 문제들을 작은 문제로 쪼개고, 작은 문제들에 대한 해결책을 만들고 조합해서 하나의 소프트웨어를 만드는 것. 즉 해결책들을 어떻게 조합할 것인가는 굉장히 큰 부분이다. 누구나 하게 되는 일임 조합은.

# Composing functions

algebra에서 함수 합성은, `(f ∘ g)(x) = f(g(x))`

g(x)를 평가한 값이 f의 인자로 전달되어서 처리된다.

개발자들은 이 짓을 사실 매일 하고 있다.

함수 체이닝이나, 한 함수의 반환값을 다른 함수에 넣어서 호출하고 있다면 함수를 합성하고 있는 거임.

나도 많이 작성했던 게 아래와 같은 코드임

```javascript
const funcA = (input) => input + 1;
const funcB = (input) => input * 1;

const doSomething = (x) => {
  const resultOfA = funcA(x);
  const resultOfB = funcB(resultOfA);

  return resultOfB;
};

doSomething(20);
```

이걸 `개선`한 버전의 코드가 다음 코드라고 함.

```javascript
const funcA = (input) => input + 1;
const funcB = (input) => input * 1;

const doSomethingBetter = (x) => funcB(funcA(x));

doSomethingBetter(20);
```

이런 함수 작성 방식을 반대하는 대표적인 이유 중 하나가 디버깅이 힘들다는 것.

나도 근데 디버깅까지는 아닌데, 이렇게 작성된 코드가 오히려 사람이 이해하기에는 더 힘들지 않나 하는 생각이 들긴한다.

그래서 이런 디버깅에 대한 것을 고려하는 함수들도 존재하고, 함수들을 이전에 실행된 함수의 결과를 다음 함수에 인자로 전달해서 연쇄적으로 실행하는 파이프라인을 추상화한 함수도 존재한다.

lodash의 pipe와 같은 함수..
-> 이거 예전에도 봤었던 것 같은데, f(g(x))와 같이 작성된 코드의 단점 중 하나가 실행 순서와 코드 작성 순서가 맞지 않다는 점.

근데 pipe를 이용하면 실행 순서와 작성 순서를 맞출 수 있음.

```javascript
// pipe함수를 이용하면
const doSomethingWithPipe = pipe(funcA, funcB);

doSomethigWithPipe(20);

// 글에서 제시한 pipe는 lodash의 pipe인데, 신기하게도 인자를 따로 pipe함수에 넣지 않아도 되나보다.
```

내가 생각했을 때, 기존의 코드 작성 방식(변수를 만들어서 함수 결과를 받고 그 다음 함수에 전달해서 또 변수에 저장하는 방식 or 함수를 중첩호출하는 방식)에 비해서 pipe가 가지는 장점은 다음과 같다.

- `이전 함수의 결과를 다음 함수의 인자로 전달해서 연쇄적으로 호출한다`라는 로직을 추상화해서 처리가 가능함. 반복 작업이 많이 줄어들고, 코드 자체도 더 적게 작성할 수 있음.
- 개발자로 이거 인지하고 코드를 작성할 수 있음. 내가 무슨 짓을 하는지 알고 코드를 작성한다고 해야하나? 그리고 함수를 만들 때 의식적으로 이 구조로 실행될 수 있는 형태로 작성하게 되지 않을까?
- 코드의 흐름을 더 쉽게 한 눈에 볼 수 있음. pipe를 보는 순간 아 함수들이 연쇄적으로 호출되겠구나라고 생각하고, 그 안에서 어떤 순서로 함수가 실행되는지도 실제로 실행되는 순서로 볼 수 있음.

# point-free style

앞서서 내가 pipe함수는 호출할 때 인자를 명시하지 않아도 pipe함수의 결과로 만들어진 함수를 인자를 전달해서 호출하면 인자가 pipe라인을 타도록 구현되어 있구나 하는 점을 신기하게 생각했는데, 이렇게 구현하는 걸 `point-free style`이라고 한다고 함.

이런 식으로 코드를 작성하려면 함수를 반환하는 함수 형식으로 함수를 작성하는게 필요함.

point-free 스타일을 잘 사용하면 중간변수들이 필요가 없어지기 때문에 불필요한 복잡도를 제거할 수 있다고 한다.

- 불필요한 복잡도라는게 뭘까? 내 생각에는 위에서 작성한 내 코드를 기준으로, `resultOfA`나 `resultOfB` 같은 변수들을 말하는 것 같다. 이 변수들은 result를 만들기 위한 중간과정을 담는 역할 밖에 하지 않으므로, 굳이 명시적으로 변수로 만들어질 필요가 없다고 보는 것 같음.
- 맞나? 나는 저런 식으로 코드를 작성할 때, 명시적으로 중간과정 결과물을 semantic한 변수명으로 드러내는게 더 낫다고 생각을 하기도 했었던 것 같은데, 어차피 중간 과정의 결과물의 의미가 다음 함수를 호출하는 것 뿐이라면, 필요없다는 말에 동의가 된다.

# 이 방식의 장점

- working memory를 효율적으로 사용할 수 있음.(cognitive load를 감소시킨다는 거지)
  - 사람은 동시에 하나의 context안에서 유지할 수 있는 정보의 양에 명확한 한계가 있는데, 불필요한 중간정보를 제거해서 정보저장고에서 불필요한 데이터 제거
- 불필요한 코드 제거
  - 정말 중요한 코드만 남겨두고, 불필요한 정보를 제거해서 코드가 더 읽기 쉽고 이해하기 쉽게 되는 것이 목적.
- extra code === extra surface space for bugs 라는 말에 동의한다면(나는 동의한다. 사실 코드가 없으면 버그가 생길일도 없겠지.) 이런 식으로 애초에 겉으로 들어나있는 코드의 양이 적을수록 버그를 만들어낼 가능성이 적다고 볼 수 있음.
