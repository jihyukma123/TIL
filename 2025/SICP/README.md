# 왜 책을 읽기로 했는지?

뭘 얻을지 솔직히 잘 모르겠음. BUT, 장기적으로 봤을 때 잘 변하지 않는 자양분 같은 지식과 인사이트를 얻을 수 있을 것이라고 생각이 되어서 올해 찬찬히 꾸준히 읽어보기로 함.

왜? 올해는 내가 이 분야에서 업을 이어나가는데 있어 도움이 되는 기초를 탄탄히 잡고 가는 한 해로 정했으니까. 적어도 6개월, 길게는 1~1.5년.

# Foreword

서문에 이런 질문이 나온다.

"Is it really true that it is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures?"

이 질문에 대해서 답은 커녕, 어떤 기준으로 두 가지 선택을 비교해야되는지, 무엇이 고려되어야 하는지조차 하나도 모르겠음...근데 분명히 개발을 하면서 필요한 선택일 수 있는 질문이란 말이지.

근데 생각해보면, 1개의 효율적인 자료구조를 기반으로 100가지 함수 만드는게 더 `낫다`고 볼 여지가 많기는 함.

- 10개의 자료구조가 존재한다는 것이 가지는 의미는? -> 각 자료구조별로 데이터를 처리하기 위한 방법들이 각각 존재함.
- 10개의 서로 다른 로직으로 조작되는 자료구조마다 10개의 함수를 만든다는 것은? -> 사실상 100가지 조합이 나올 수 있음(공통되는 것도 있겠지만 극단적으로 생각해보면)
- 일관성이나, 확장성, 프로그램의 이해가능성 등이 떨어질 가능성이 높음
- 반대로 1개의 자료구조를 기반으로 100가지 함수를 만든다는것은?? -> 자료구조를 조작하는 방법의 묶음이 한가지만 존재한다는 것(JavaScript 배열이라고 생각하면, push, pop 등 정해져있다는거지)
- 100가지 서로 다른 함수를 구현해도, 기반이 되는 기반 정보라고 해야하나(뿌리?)는 배열과 배열을 조작하는 로직 묶음에서 변하지 않음. 즉 하나의 사상에서 파생된 여러 변형이기 때문에 공통된 로직이 있고, 개발자의 이해가능성이 커질 것 같음.
- 프로그램을 작은 단위로 fail safe한 구조로 만들고, 이를 fail safe한 방법으로 조합해서 큰 프로그램을 만드는데 기반으로 삼기에는 후자가 더 낫다.

프로그램은 사람이 쓰는 것 -> 100가지 함수의 기능을 포괄할 1가지 함수를 구현하는것은 얼마든지 가능하지만, 사람이 그걸 이해하는건 참 어려운 일이 됨.

사람이 프로그램을 쓴다는 것. 좋은 글을 쓰는 것과 일맥상통하는 부분이 있다.

# 1984년 출판될 당시 Foreword

문제를 해결하기 위해서는 일련의 프로그램이 사용됨

여기서 중요한건,

- 프로그램이 얼마나 잘 동작하는가
- 더 큰 프로그램의 일부로서 얼마나 다른 프로그램들과 잘 어우러지는가.

그렇기 때문에 부분 프로그램들을 잘 동작하도록 작성해야하고, 조합되었을 때 충분히 문제를 해결하도록 구성해야 한다.

## What is a computer program?

컴퓨터 프로그램이란 무엇인가?

단순히 생각하면 컴퓨터에서 돌아가는 프로그램이다..히히.

하지만 자연발생한게 아니니까, 왜 발생했는지의 관점을 섞어서 보자면, 컴퓨터 프로그램이란 real/mental process를 머릿속으로 구조화(모델링)한 결과물임. (Every computer program is a model 이라고 하는데, model이라고 하면 여전히 좀 추상적인 머릿속에 있는 그 무언가처럼 느껴짐 나는. 그 모델을 실제로 컴퓨터에서 돌아갈 수 있도록 구현한게 프로그램이지 않나?)

근데 이 `process`라는게 심플하지가 않음.(하나의 큰 개념을 작은 프로세스로 쪼갤 수 있지만, 결국 해결하고자 하는 큰 `process`는 심플하지 않음. 복잡하고 뭐가 많고, 다양한 디테일이 존재)

그래서 무슨 문제가 생기냐? 프로세스를 프로그램으로 구현하는 사람이(또는 조직이겠지?) 전체적인 그림에 대한 이해를 다 가진 상태에서 개발하는게 거의 불가능함.

그래서 어느 한 시점에 이해한만큼 프로그램을 만들고 -> 만들면서 또 이해하는 만큼 보완하고 하는 과정을 거칠 수 밖에 없다. 그래서 어느정도 완성도를 갖추면 더 큰 시스템의 일부로 또 더 큰 시스템을 개선하고 하는 일련의 과정.

프로그래밍은 (내가 하는 웹개발 관점에서 본다면) 단순히 정해진 시나리오에 필요한 UI와 API를 개발하는게 아니라, 프로세스를 실제로 구현하는 과정임. 그리고이 과정에서 해당 프로세스에 대한 인식이 확장되면서 확장된 인식과 이해를 프로그램에 지속 반영해서 머릿속에 있던 개념적인 것을 컴퓨터 프로그램으로 구현해내는 것.

## 프로그래밍의 본질적인 어려움이 무엇일까?

컴퓨터 -> 강력한 도구이지만, 동시에 융통성이 없는 도구임. 정해진 방식에서 벗어나도 제대로 동작하지 않고, 또한 내가 만든대로만 동작함.

여기서 든 생각이 그래서 2가지 관점에서 어려운 점이 있음.

- 기술적으로(문법적으로) 프로그램 오류가 없어야 함.(개발지식)
- 잘 만들어야함(설계가 중요함. 설계를 잘못하면 설계대로 잘 만들어도 내가 만든대로 동작하니까 목적을 달성하지 못함 -> 프로덕트/비즈니스에 대한 이해가 필요함)

무튼..

그래서 컴퓨터는 똑똑한데 멍청함. 그래서 우리가 일을 엄청 제대로 시켜야한다.

그러면? 우리가 어떻게 일을 잘 시킬까에 대한 이해와 방법론을 공부하는게 곧 잘 작동하는 프로그램을 만드는 것으로 이어짐.

로직 자체는 논리학적으로 옮음을 증명할 수 있음.(논증을 통해서 추론이 된다.) 근데 문제는 거대한 프로그램(대부분의 현대 프로그램들이 `거대`함) 규모가 크다는거지. 얘네는 논리저적으로 잘 동작함을 (truth)를 증명하기가 어려움. 왜? 프로그램을 만들기 위한 명세 자체의 충분성, 정확도, 일관성 등 측면들이 확실하지 않은 경우가 많기 때문에 -> 당연히 결과물도 이게 진짜 우리가 의도한 문제를 풀어내는가에 대한 증명이 어렵지.

그러면 어떻게 조금이라도 그 `유효함` 혹은 `truth`의 가능성을 높일 수 있느냐??

알고리즘에서 얘기하는 분할정복하고 비슷한 방식의 사고로 접근해보자.

큰 프로그램 -> 더 작은 프로그램들의 집합 -> 각 작은 프로그램들은 또 더 작은 프로그램들의 집합 이런 식으로 재귀적으로 구성되어 있다고 있음.

그러면 큰 프로그램의 `truth`는 증명하기 힘들지만, 일정 규모 이하의 프로그램들의 `truth`를 증명하는 것은 가능하겠지.

그러면 작은 프로그램들이 `true`하다면, `true`한 프로그램들을 `잘` 조합해서 만든 거대한 프로그램도 `true`하지 않을까?

그렇기 때문에 여기서 2가지가 중요함

- `idiom`이라고 하는, `true`함이 이미 증명된 표준 프로그램 구조의 집합을 만드는 것이 중요하고, (clean code pattern 같은 그런 비슷한 느낌의 프로그래밍 구조나 방법론으로 이해함)
- 이런 구조들을 증명된 방법으로 조합해서 더 큰 프로그램을 구성하는 것

이 책은 바로 이런 기술들을 다루고 있다고 함.(그래서 이 책을 읽어보는게 도움이 되겠구나!!! 왜 읽으면 좋을지 여기서 좀 느낌이 옴)

이런 `조직화 기법 - organizational techniques`를 이해하는 것이 대규모 프로그램을 만드는 것의 핵심.

참고로 큰 프로그램 만드는거 너무 빡센 일이라, 프로그램에 포함되는 함수와 디테일을 줄일 수 있는 방법을 찾게 되기 마련임.(이런 시도는 계속 이루어지고 있다.)
