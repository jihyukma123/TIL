# What is an Agent? 어떤 개념적인 요소인가?

테디노트 영상을 보면서 Agent라는게 뭔지 아직도 잘 모르겠어서 GPT랑 좀 대화를 했는데 다음과 같이 요약해줌.

Agent(에이전트) 는 쉽게 말해서 "스스로 판단하고, 도구를 써서 목표를 해결해나가는 똑똑한 비서" 라고 생각하면 돼!

LLM이 기본적으로 동작하는 방식 -> 질의를 하면, 일련의 추론 과정을 통해서 답변을 제공.

질의 -> 답변, 질의 -> 답변 형식으로 진행됨.

근데 실제로 우리가 해결하려는 문제는 단순한 질의들로 해결되지 않는 경우가 다반사.

예를 들어,

"서울에서 다음으로 이루어진 데이트 코스를 짜줘. 어떤 요일 몇시부터 몇시까지 대략 이런 동네에서 다음과 같은 조건에 해당되는 식당에서 밥을 먹고, 그리고 산책을 좀 하고 영화를 볼거야. 그리고 너무 많이 걷지 않는 선에서 예쁜 카페에서 커피를 한 잔 하고 싶어. 차를 가져갈거라서 차가 막히는지, 주차는 어디에 하는게 좋을지도 고려해줘."

이런 문제를 해결하고자 한다면 단순히 질의하는 것 가지고는 충분치 않음. 웹에서 검색한 결과도 필요하고, 결과를 기준으로 판단을 내리고 내린 판단을 기준으로 또 다음 판단을 이어나가고 하는 일련의 과정이 필요함.(질의 -> 응답이라는 하나의 단계가 아니라 복수의 단계가 필요하다.)

이런 문제를 해결하고자 하는 것이 Agent라는 개념.

Thought -> Action -> Observation 루프로 Agent가 스스로 생각하고, 행동하고, 피드백을 받는 일련의 행동을 반복하는 구조.

`ReAct`는 reasoning + acting을 반복해서 문제를 해결하는 방식

# 그래도 조금 더 깊은 이해를 좀 해보고 싶다. 그래서 Google에서 Agent 관련 가이드를 제공한게 있다고 해서 한 번 읽어봄.

생성형 AI 모델과 연결된 추론과 외부 정보를 기반으로 한 의사결정, 작업 처리 등을 하는 조합이 invokes the concept of an agent.

Agent는 가장 기본적으로는 application that attempts to achieve a goal by observing the world and acting upon it using the tools that it has at its disposal.

인간 개입없이 자동으로 동작하는 것이 중요한 포인트 중 하나.

agent는 사람의 지시 없이도 최종 목적을 달성하기 위해서 다음에 뭘 해야되는지 추론할 수 있음.

진짜 그냥 AI비서 같은 존재라고 생각할 수 있네. declarative goal이 주어졌을 때 이를 달성하기 위해 필요한 일련의 작업을 알아서 정의하고, 수행할 수 있는 프로그램.

# Agent의 액션과 의사결정을 이끄는 기본 구성 요소들을 알아보자.

이 조합을 `cognitive architecture`라고 할 수 있음.

이 `cognitive architecture`를 구성하는 3가지 요소가 있다.

일단 이 문서에서 기본적으로 설명하는 구조는 user_query -> Agent Runtime -> agent_response이고, 이 runtime 안에 model, tools, orchestration이 포함되어 있음.

model -> 의사결정 하는 놈
tool -> 외부세계와의 상호작용 수단
orchestration layer -> 이 둘을 연결하고 작동 순서를 결정하는 놈

**The Model**

the centralized decision maker for agent processes

하나 혹은 복수의 지시 기반 추론 및 논리를 처리할 수 있는 LM이면 됨.

만들고자 하는 앱의 니즈를 잘 충족하는 모델을 고르는게 더 좋은 결과물을 낳을 가능성을 높이고, 이상적으로는 `cognitive architecture`에서 사용하고자 하는 도구들의 data signature(데이터의 특징적 형태, 구조, 형식 패턴 등등)을 미리 학습했다면 더 좋다.

**The tools**

foundation model들은 텍스트나 이미지 생성에는 매우 뛰어나지만, outside world와 상호작용이 불가하다는 근본적인 한계를 가지고 있음.

Tools bridge this gap. 즉 에이전트들이 외부 데이터와 서비스에 연결해서 기반이 되는 모델만 가지고는 할 수 없는 일들을 할 수 있게 함.

통상적으로 web API 메서드로 데이터 교환함.

tool이 agent를 도와서 DB데이터를 업데이트하거나, 데이터를 가져와서 추론 결과 도출에 같이 데이터를 전달할 수 있음.

Tools를 통해서 agent가 실시간 정보에 접근가능하고, 이는 RAG같은 foundation model 혼자서는 할 수 없는 구조의 작업처리 방식이 가능케 함.

그냥 제일 중요한 포인트는 Agent가 model 기반으로 가지는 internal 능력과 실시간 데이터 간의 gap을 연결하는데 사용되는 것들을 tool이라고 한다는 점.(agent가 tool과 model을 연결한다고 생각했는데 약간 느낌이 좀 다르네..무슨 차이인거지?)

`Agent가 Tool과 Model을 연결하는 주체라고 보기보다는, Agent라는 시스템 안에서 Model이 의사 결정을 내리고, 그 결정에 따라 Orchestration Layer가 적절한 Tool을 선택하여 외부 세계와 상호 작용하는 구조로 이해하는 것이 더 정확합니다. Tool은 Model의 부족한 외부 세계 상호 작용 능력을 보완하고 확장하는 역할을 수행하는 것이 핵심입니다.` -> NotebookLM이 만들어준 답변...ㄷㄷ

Agent가 tool을 이용해서 external system과 model의 추론 능력을 연결. 즉 model이 가지는 한계를 확장할 수 있음.

외부 세계와 소통하는데 사용되는 것이 Tool

**The orchestration layer**

순환적인 과정을 설명하는 계층.

Agent가 정보를 입력받아서, 추론과정을 통해 나온 결과를 다시 다음 액션이나 의사결정에 어떻게 사용하는지 컨트롤

agent가 목적을 달성하거나, 특정 stop point에 도달할 때까지 loop가 돌아감.

# `cognitive architecture` -> Agent는 어떻게 동작하는가??

쉐프들은 고객들에게 맛있는 음식을 제공하는 것이 목적이고, 이를 위해서 계획, 실행 그리고 조정과정 끊임없이 반복함.

시간이 지나고 변화하는 변수들(재료의 양, 고객의 피드백 등등)에 맞춰서 재조정을 계속 하면서 목표 달성을 시도함.

이전의 결과물들을 활용해서 다음 액션을 결정하는 이 순환적인 `정보습득 -> 계획 -> 실행 -> 재조정`의 과정은 쉐프가 목표를 달성하기 위해서 사용하는 유니크한 `인지적 구조`라고 볼 수 있음.

Agent의 인지적 구조의 핵심은 `orchestration layer`임.

필요한 메모리, 상태, 추론과 계획 등을 관리하는 역할을 하며, 프롬프트 엔지니어링과 연관된 프레임워크를 사용해서 추론과 계획을 처리

프롬프트 엔지니어링 프레임워크 몇 가지 (프레임워크라고 하는 용어의 의미가 Spring Boot가 프레임워크라고 하는 것과 느낌이 조금 다른 것 같음. 그래서 헷갈렸는데, 이 문서에서 framework라는 단어는 방법론으로 이해하는게 맞을 것 같음.)

- ReAct: 사용자 질의에 대해서 추론+action을 통해서 답을 만들어나가는 방식
- CoT(Chain-of-Thought): 중간단계들을 통해서 추론 능력을 향상시키는 방법
- ToT(Tree-of-thoughts): 여러 추론 경로를 동시에 펼쳐서 비교하고, 더 나은 경로를 선택하는 방식!

Agent는 여러 방법론 들을 활용해서 주어진 사용자 입력에 대해서 취해야되는 최선의 다음 행동을 결정.

ReAct를 이용하면?

이 부분 flow가 문서상으로만 해서 이해가 잘 되지 않아서 lm에 물어봄.

**구체적인 사용 사례: 여행 계획 에이전트**

사용자가 다음과 같은 쿼리를 여행 계획 에이전트에게 보냈다고 가정해 보겠습니다.

`"다음 주말에 서울에서 부산으로 가는 KTX 티켓을 예매하고 싶은데, 가장 빠른 출발 시간과 도착 시간을 알려줘."`

이 쿼리를 받은 에이전트는 ReAct 프레임워크에 따라 다음과 같은 단계를 거칠 수 있습니다.

1.  사용자 쿼리: "다음 주말에 서울에서 부산으로 가는 KTX 티켓을 예매하고 싶은데, 가장 빠른 출발 시간과 도착 시간을 알려줘."
2.  ReAct 시퀀스 시작: 에이전트는 사용자의 쿼리를 처리하기 위해 ReAct 시퀀스를 시작합니다.
3.  모델에게 프롬프트 제공 및 다음 ReAct 단계 생성 요청: 에이전트는 모델에게 다음과 유사한 프롬프트를 보냅니다.
4.  모델 응답: 모델은 프롬프트에 따라 다음 ReAct 단계를 생성합니다.
    ◦
    Thought: 사용자가 KTX 시간표 정보를 알고 싶어하므로, KTX 시간표를 조회할 수 있는 도구를 사용해야 한다고 생각합니다.
    ◦
    Action: KTX 시간표 조회 도구를 사용합니다. (여기서 Flights, Search, Code, None과 같이 미리 정의된 사용 가능한 도구 목록 중에서 선택합니다. 이 예시에서는 KTX 시간표 조회라는 도구가 있다고 가정한 것입니다.)
    ◦
    Action Input: {"출발지": "서울", "도착지": "부산", "날짜": "다음 주말"} (선택한 도구에 필요한 파라미터를 JSON 형식 등으로 제공합니다.)
5.  도구 실행 및 결과 관찰: 에이전트는 모델이 선택한 KTX 시간표 조회 도구를, 모델이 제공한 입력 ({"출발지": "서울", "도착지": "부산", "날짜": "다음 주말"})과 함께 실행합니다. 도구가 실행되면 그 결과를 에이전트에게 반환합니다. 예를 들어, 도구가 다음과 같은 결과를 반환했다고 가정해 보겠습니다.
6.  다음 ReAct 단계 또는 최종 답변 생성 요청: 에이전트는 도구 실행 결과를 다시 모델에게 프롬프트로 제공하고, 다음 단계를 추론하거나 최종 답변을 생성하도록 요청합니다.
7.  최종 답변 제공: 모델은 최종 답변을 생성하여 사용자에게 제공합니다.
8.  "다음 주말 서울에서 08:00에 출발하는 KTX를 타시면 가장 빠른 10:30에 부산에 도착합니다. 티켓 예매를 원하시면 알려주세요."
    이 예시에서 볼 수 있듯이, "Action" 단계에서 에이전트는 사용자의 쿼리를 이해하고, 현재 상황과 목표를 고려하여 어떤 외부 도구를 사용할지 결정합니다. Flights, Search, Code 등은 미리 에이전트가 사용할 수 있도록 정의된 도구들의 예시이며, 실제 사용 사례에서는 더 구체적인 이름과 기능을 가진 도구들이 활용될 수 있습니다 (예: KTX 시간표 조회, 이메일 보내기, 날씨 정보 검색, 데이터베이스 쿼리 실행 등).
    핵심은 모델이 "Thought" 과정을 통해 어떤 도구가 필요한지 추론하고, 그에 맞는 "Action"을 선택한다는 점입니다. "Action Input"은 선택된 도구를 실행하기 위해 필요한 구체적인 정보를 모델이 생성하는 단계입니다.
    이 설명이 ReAct 프레임워크의 해당 부분을 이해하시는 데 도움이 되었기를 바랍니다.

Agent의 응답 퀄리티는 결국 여러 task에 대해서 추론하고 처리하는 model의 능력과, 적절한 도구를 선택하는 능력 그리고 얼마나 도구들이 잘 정의되었는지에 달려있다

sound reasoning(model이 적절한 추론과, 도구를 적절하게 선택해야 함), 그리고 reliable information(도구들이 적절한 정보를 제공할 수 있어야 함.)을 통해서 최적의 답을 제공할 수 있음.

# Tool

LM은 정보처리는 잘 하는데, 외부 세상과 소통하는 능력이 없음.

외부 시스템이나 데이터와 상호작용이 필요한 상황에서 LM의 효용이 떨어지는 가장 큰 이유(라고 내 생각...인데 맞는 듯? 입력된 값 말고 내가 가지고 있는 여러 데이터를 기반으로 만들어주면 좋지.)

이는 다르게 말하면, LM은 그것이 학습한 데이터의 범위 안에서만 쓸모가 있음.

그리고 데이터랑 다르게 또 외부 시스템과 상호작용은 애초에 못함.

그러면 어떻게 외부 시스템과 상호작용할 수 있도록 해주나??

Functions, Extensions, Data Stores and Plugins를 통해서 모델이 이 능력을 만들어준다!!!

Tool이 여러 이름으로 불리긴 해도 결국 본질적으로는 foundation model과 외부 시스템 간 링크를 만들어주는 것.

Agent가 Tool을 통해서 스마트홈 세팅 조정, 캘린더 업데이트, DB에서 사용자 정보 조회, 이메일 전송 등의 작업을 처리할 수 있게 함.

## Extension

외부 API와 Agent가 표준화된 방식으로 소통할 수 있도록 해준다. 실제 Implementation과 관계없이 잘 돌아가게 함.

API를 쓰려면 원래는 코드를 작성해야하는데, 문제는 입력되는 쿼리가 유동적인 상황에서 항상 쿼리가 필요한 값들이 잘 입력되어서 호출된다는 보장이 없음. (input_A, input_B가 있어야 하는데 input_A만 입력된다던지 하는..)

이럴 때 Extension을 써서 API사용이 원활하게 되도록 할 수 있다.

어떻게?

1. Agent를 학습시킴. 뭐에 대해서? 특정 API endpoint를 쓰는 방법에 대해서 예시를 사용해서 학습을 시킨다.
2. 그리고 API endpoint를 호출하기 위해서 필요한 값들을 학습시킴.

Extension은 Agent의 configuration의 일부로 제공되어야 한다고 함.

그래서 Agent는 런타임에 model과 주어진 example들을 활용해서 어떤 Extension을 사용할지 결정함.

Extension의 핵심 장점은 내장된 example-types라고 함. 이를 통해서 실시간으로 어떤 익스텐션을 선택할지 결정이 가능하다.

(익스텐션의 예시들을 기반으로 최적의 익스텐션을 고름.) -> 미리 이런 경우에 이렇게 해라 이런게 없어도 사용자 쿼리에 맞춰서 적절한 예시가 있는 익스텐션으로 처리할 가능성이 높아짐. 그리고 개발자가 일일이 모든 쿼리에 대해서 API호출에 대한 코드를 작성하지 않아도 됨. 그리고 익스텐션 추가가 용이하다. 그냥 익스텐션 하나 새로 만들고 사용 예시 만들면 Agent가 이를 학습해서 처리할 수 있음.

결국 이걸 통해서 하고 싶은 것은, 미리 정의된대로 동작하는게 아니라 런타임에서 동적으로 자체적으로 적절한 도구를 선택하고, 도구를 알아서 잘 사용해서 유효한 결과를 만들어내도록 하고 싶은 것.
