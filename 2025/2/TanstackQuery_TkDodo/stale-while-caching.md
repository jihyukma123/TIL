# Server State Management에 대하여

React Query관련 공부를 하다가 stale-while-revalidate라는 표현이 무슨 뜻인지 이해를 못해서 찾아보니, [jbee님의 블로그 글 - 전역 상태 관리에 대한 단상 (stale-while-revalidate)](<https://jbee.io/articles/react/%EC%A0%84%EC%97%AD%20%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC%EC%97%90%20%EB%8C%80%ED%95%9C%20%EB%8B%A8%EC%83%81%20(stale-while-revalidate)>)이 있어서 읽어봤음.

React문서에 상태를 이렇게 표시한다라는 내용이 있어서 지금 기준 React 문서를 보니, ` In React, this kind of component-specific memory is called state.` 라고 되어있었다. 사용자가 입력하는 input과 같이 컴포넌트가 기억해야되는 값을 state라고 규정하고 있음. -> 렌더링에 영향을 주는 값이라고 이해할 수 있겠다.

## 전역이라는 것의 의미

`전역`이라는 것은, 문서의 어떤 곳에서라도 접근할 수 있는 영역.(오 이런 관점으로 생각해보지 않았는데 `문서` 관점에서 생각할 수 있구나.)

`전역 상태`는? -> 단순히 전역에서 접근가능한 것 뿐만 아니라, 변화에 따라서 렌더링에 영향을 줘야하는 값. (나는 변화에 따라 렌더링에 영향을 준다는 점을 하나의 조건으로 고려하지 않았는데, 상태라는 것 자체가 변화를 전제하는 값이라는 점. 전역에서 접근가능해도 변화할 때 렌더링에 직접적으로 영향을 주지 않거나, 관리의 대상이 아닌 값은 전역 상태라고 볼 수 없음.)

## 클라이언트 앱의 상태

- 외부에서 주입되는 `동적인` 데이터 (Server Response)
- 애플리케이션 UI 상태 (ex. isOpen)

후자는 관리가 상대적으로 쉬움. 어려운건 외부에서 주입되는 동적인 데이터이다.

## 클라이언트에서 외부에서 주입받는 데이터를 관리하는데 어떤 어려움이 있는가?

어떤 어려움이 있는지에 대해서 생각을 깊게 해보지 않았는데 이 글을 읽으면서 생각해보게 되었음.

외부에서 데이터를 주입받는 대표적인 예시가 server에 값을 요청해서 받는 것.

외부에서 데이터를 불러올 때, 뭐가 어려운 부분일까?

- 언제 데이터를 호출하는가?
- 어디서 호출해서 어떤 컴포넌트에서 state로 등록해서 관리하는가?

이런걸 결정하는게 어려운 부분.

언제 어디서 호출할 것인가? -> 이게 왜 중요하지? 불필요한 리소스 낭비를 줄이기 위해서 필요한 시점에 데이터를 불러와야 함.

이상적으로는 사용하는 컴포넌트에서 호출하는 것이 응집도를 높이는 방향이다. (하지만 컴포넌트 구조와 API의 응답 구조가 일치하리라는 보장이 없는 것이 또 하나의 문제)

여러 컴포넌트 간에 공유되어야 하는 상태를 불러와야 하는 경우, 자연스럽게 전역상태에 등록해서 사용해야될 것 같은 느낌이 들고 실제로 react-redux 같은 라이브러리 활용해서 그렇게 해왔음.

## Redux로 데이터를 언제, 어디서 호출하는지에 대한 문제를 해결하는 경우 어떤 문제가 생기는지?

**필요로 하는 값은 redux에 존재한다는 가정.**

redux에 등록되어 있는 서버에서 불러온 서버상태값을 특정 컴포넌트에서 가져다쓰려면?

```javascript
// 아래 코드처럼 useSelector를 써서 state에서 값을 가져올 때 개발자가 가정하는 사항은 뭘까?
// 값이 있으리라는 가정이다. 의도한 값이 redux에 있으리라는 가정
// 값이 있으려면? 이 컴포넌트에서 redux에서 상태를 불러오기 전에 값을 서버로부터 불러오는 로직이 먼저 호출되어야만 함.
function TransactionListA() {
  const transactions = useSelector((state) => state.transaction);

  return <ul>{/* render transaction */}</ul>;
}

// 즉 데이터를 redux에서 가져다 쓰는 TransactionListA 같은 컴포넌트가 마운트되기 전에 서버로부터 값을 가져와서 등록하는 action이 반드시 dispatch 되어야 함.
useEffect(() => {
  dispatch("fetchTransactions"); // fetch server api !!!
}, []);
```

값이 없을 때 state에 접근하지 않도록 하는, 반대로 말하면 데이터 fetching & redux 등록 작업이 데이터 read 작업 이전에 수행되도록 하는 메커니즘이 필요한데, 그걸 강제하는 로직이 없을 뿐더러 문제가 런타임에서 발견되는 안좋은 사례이다.(런타임에 문제가 생기는 것의 나쁜 부분에 대해서는 멘토님과도 얘기했었다. fail fast, 개발자가 아는 범위 내에서 fail 하도록 하는 것이 런타임에서 터지는 것보다 더 좋은 접근법이라고 생각된다.)

근데 이렇게 처리하면 처음에 우리가 얘기했던 가정에 위배됨

> 불필요한 네트워크 비용을 최소화하기 위해서 필요한 시점에 데이터를 불러온다.

-> 근데 데이터를 필요하기 이전에 불러오게 되면 그게 사용되지 않으면? 리소스 낭비임.

Redux로 서버 데이터를 관리하면 결국 데이터에 접근하는 시점에 데이터가 존재함을 보장하기가 어려워져서 데이터 흐름 추적이 힘들어짐.

**특정 시점에 capture된 서버 데이터(상태)**

서버에서 불러와서 저장되어 있는 데이터가 최신 값이라는 보장이 없으며, 이 값은 다시 서버에서 값을 불러오는 action이 dispatch되기 전에는 반영되지 않는다.

사실 클라이언트에 서버 상태를 저장해서 사용하는 구조 자체가 SSOT를 위배하는 것이라 그 자체로 위험성이 존재함.

## 이런 문제가 생기는 근본적인 원인이 뭘까?

생각해보면 결국 비용 문제다. 매번 서버에서 해당 시점에 최신 데이터로 불러와서 보여주는게 사실 베스트이지만 그러면 데이터가 변경되지 않아도 호출이 계속 되면서 비용이 증가함.

데이터를 불러오는 시점과 데이터에 접근하는 시점의 불일치와 데이터가 필요할 때 데이터가 실제로 잘 호출되어서 저장되어 있음을 보장하지 못하는 문제는 간단한 캐싱 + hooks를 활용해서 해결할 수 있다는 것.(내가 이해한게 맞으면 데이터가 존재하는지 확인하고, 존재하지 않으면 호출하고 존재하면 있는걸 가져다쓰는 로직을 hook으로 추상화해서 컴포넌트에서 해당 hook을 사용하는 형태로 하면 된다고 이해됨, 여러 컴포넌트 간 공유도 동일한 hook를 동일한 id 값으로 호출해서 사용하면 된다는 느낌?)

하지만 여전히 SSOT에 위배되며 캐싱된 데이터가 out-of-date 되는 시점을 파악하는 문제는 해결되지 않았음.

## Stale-while-revalidate 철학을 메모리 캐시에도 적용해보자... = React Query, swr, rtk-query 등등이 그 구현체

서버 응답을 메모리에 캐싱하면서 재검증 로직과 함께 비용을 줄인다.

- 서버로부터 데이터를 가져오는 코드와 데이터에 접근하는 인터페이스가 동일하다. -> 개발할 때 고려해야되는 것들이 적어짐
  - 기존의 방법(useEffect안에서 데이터 fetching을 처리하고, 이를 useState/redux등에 저장해서 사용하는 구조에서는 데이터를 가져오는 코드와 데이터에 접근하는 코드가 분리되어 있었음. React Query는 `useQuery`훅을 활용해서 이 두 가지를 한 번에 합쳐서 제공한다. 그래서 개발자가 신경쓸게 많이 줄어드는 장점이 존재한다.)
- 주기적으로 revalidateg하여 out-of-date에 대한 가능성이 낮아짐.
- `+@` 비동기적으로 동작하는 코드에 따라오는 필연적인 부산물들(status처리, 실패에 따른 retry등등)에 대한 부가기능 제공.

## 하지만 여전히 SSOT에 위배되며 캐싱된 데이터가 out-of-date 되는 시점을 파악하는 문제는 해결되지 않았음. -> 그러면 source of truth인 server에서 데이터의 변경이 있을 때 client로 어떤 신호를 보내는 구조는 어떤 문제가 있을지? 문득 궁금해졌음.

궁금하네. 어떤 식으로 구현할 수 있을까?

근데 잠깐만 이거 Client가 데이터 교환을 initiate 한다는 HTTP의 원칙?(뭐지 원칙일까 아니면 가정일까 뭘까)규칙? 무튼 그 무언가에 위배되나 애초에? 이건 HTTP가 아닌가? 모르겠네 흠

아니면 f에 저장된 데이터를 어떤 식으로 업데이트 여부를 판단하지? 조금더 overload가 적은 데이터를 주고 받는 형태가 되면 되는지?(왔다갔다 하는 비용 자체가 문제인지 아니면 담겨있는 데이터의 양이 문제인지도 궁금함. 1회 왔다갔다 하는 것 자체가 문제?일 것 같긴하네 왜냐하면 호출당으로 비용을 부과하니까)

## state-while-revalidate

애초에 영어 표현이 직역이 잘 안돼서 더 개념이 와닿지 않는 듯 해서 클로드한테 한글로 번역해달라고 했더니...

- 재검증하는 동안 오래된 데이터 사용
- 갱신 중에도 기존 데이터 활용

이라고 알려줌. stale(오래된) 데이터를 보여주면서 동시에 새로운 데이터를 가져오는(revalidate) 과정

웹개발에서는 Better UX를 위해서 캐시된 데이터를 즉시 보여주고, 백그라운드에서 최신 데이터를 가져오는 전략을 의미

HTTP 스펙에 stale content에 대한 Cache-control에 대한 내용이 존재한다고 함.

- 서버가 응답에 담아서 보내는 값.(`Cache-control` 헤더에 `stale-while-revalidate`라는 값을 포함시켜서 보낸다.)
- 이는 서버가 응답을 전송하는, 서버의 응답을 전송받는 주체 중 캐싱 레이어(CDN, browser, proxy cache 등)에 이 데이터를 얼마나 오랫동안 재검증하지 않고 동일한 요청에 대해서 반환할 수 있는지 전달하는 것에 해당됨.
- 아하 내가 조금 잘못 이해한 부분이 있었네. fresh한 시간을 설정하는 값과, stale-while-revalidate 한 시간을 설정하는 값이 있음.
  - fresh 한 시간동안 요청이 들어옴 -> 바로 반환
  - fresh한 시간 초과 후 stale-while-revalidate한 값이 들어옴 -> 캐싱된 값 보내주고 새로운 값 불러옴
  - fresh + stale 시간 둘 다 초과함 -> 새로운 값 요청 후 기다려서 받은 값 돌려줌.

# 추가로 생각해볼만한 부분들

- 컴포넌트 구조와 API 응답 구조 간의 상관관계.
- [web.dev 글 about stale-while-revalidate](https://web.dev/articles/stale-while-revalidate)
