# HTTP의 stateless함과 stateful session(쿠키 + 세션 편)

HTTP는 stateless 하다. 즉 동일한 connection에서 연달아 발생하는 2가지 request 간 연관성이 없다.

그러면 HTTP로는 여러 요청을 연관지어서 처리할 수 없을까? -> 이럴 때 사용할 수 있는 것이 HTTP cookie.

Cookie를 활용해서 Stateful 한 session 구조를 만들 수 있음.

일단 `session`이 정확히 뭔지 모르겠다.

Claude에게 뭔지 물어보니, "refers to a series of related interactions between a specific user and a web application over a period of time" 이라고 알려줌.

그리고 관련해서 Stackoverflow의 좋은 글을 하나 보게 되었음.

[What are sessions? How do they work?](https://stackoverflow.com/questions/3804209/what-are-sessions-how-do-they-work)

- HTTP가 stateless하도록 설계되었기 때문에 하나의 request를 다른 request와 연관짓기 위해서 서로 다른 시점에 발생하는 독립적인 HTTP 요청 사이에 데이터를 저장할 방법이 필요함.
- Cookie 혹은 URL 파라미터는 모두 2개 이상의 요청에 걸쳐서 데이터를 전송하기 위해서 사용할 수 있는 좋은 방법들이지만, 이 방법들은 클라이언트 사이드에서 read/write하면 안되는 데이터를 다루기에는 적합하지 않음.
- 데이터 저장할 방법이 필요한데, 이 데이터가 보안이 중요한 데이터라면? -> 이 문제를 해결하기 위해서 데이터를 서버사이드에 저장하고, id를 부여해서 클라이언트에서 이 id값만 주는 것.

조금 더 알아보기 위해서 예시를 들어서 공부해보았음.

**가상 시나리오를 활용한 실제 테스트(Cookie를 활용한 로그인 인증 정보 persist)**

은행 웹사이트에 유저가 본인의 계정에 로그인하는 상황이라고 생각해보자.

유저가 본인의 인증 정보(예를 들어, id/password)를 입력하고 로그인 요청을 은행의 서버로 전송한다.

그리고 서버는 인증정보가 맞는 정보인지 확인한다.

그리고 DB에 해당 유저의 로그인 이벤트를 정해진 형식으로 저장하며 Cookie형식의 sessionId를 같이 저장한다.

아이디와 비밀번호를 세션아이디를 담고 있는 쿠키와 교환했다고 생각할 수 있음.

sessionId값은 유니크한 식별자이며 무작위로 생성된다.

서버는 이렇게 세션 정보를 DB에 저장하고, 클라이언트는 쿠키에 저장된 session id를 컴퓨터의 파일시스템 어딘가에 저장한다.
(쿠키 - 클라이언트에 저장되는 작은 데이터 조각. 서버가 `Set-Cookie`헤더를 사용해서 클라이언트에게 쿠키를 전달할 수 있음. 그리고 클라이언트는 이후 요청마다 해당 쿠키를 자동으로 서버에 전송함. 서버가 발급한 세션id를 쿠키에 넣어두고 사용하는 것.)

로그인이 최초로 성공해서 서버로부터 세션id를 받아서 쿠키에 저장한 이후에는, 요청을 보낼 때 아이디비밀번호가 필요없음.

세션id를 요청에 담아서 전송하면 서버에서 인증된 유저인지 이를 기반으로 판별.

만약에 유저가 로그아웃을 하게 되면, 서버는 DB에서 세션 정보를 삭제하고 브라우저에 쿠키를 삭제하라는 명령을 전송함.

혹은, 유저가 일정 시간 이상 비활성 상태인 경우에도 지정된 시간 이후에 만료되어서 효력을 잃는다.(사용자의 활성여부를 판단할 기준도 있어야겠지? 예를 들어서 일정 시간 내에 요청이 서버로 전송되면 만료시간을 초기화한다던지 하는 처리)

은행과 같이 보안이 중요한 프로그램은 short-lived session을 활용해서 짧은 시간에 효력이 만료되는 세션을 사용하는 반면에, 페이스북과 같이 사용자가 매번 로그인 하도록 하는 것이 상대적으로 덜 중요한 프로그램은 long-lived session을 활용해서 사용자경험을 개선할 수 있음.

하지만 쿠키는 보안 관련 이슈가 존재한다는 점...(클라이언트에서 전송되기 때문에)

## 직접 한 번 구현해보자...
