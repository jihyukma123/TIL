# 의존성

의존성 주입, 의존성 역전 원칙 같은 용어에서 언급되는 `의존성`이 뭘까?

`의존하다`라는게 무슨 소리임? 몰라서 찾아봄.

왜 찾아보게 되었냐면, agent-builder 만들어보는 과정에서 Tool의 원형이 될 class를 만들었는데, 이 클래스가 파이썬의 abc 라이브러리를 활용해서 만든 추상클래스였음.

근데 왜 이런 패턴을 쓰는지 이해가 안돼서 찾아보는 중이었음. 이게 의존성 역전 원칙에 해당되는 케이스라고 하는데....그것도 솔직히 이해가 잘 안됨.

왜 이해가 잘 안될까 생각해보니 `의존`이라는 단어가 뭔지 모르고 있다는 걸 깨달았음.

## 의존이라는게 뭐임

`의존(Dependency)`이란, 한 객체(클래스, 모듈)가 자신의 기능을 수행하기 위해 다른 객체(클래스, 모듈 등)를 필요로 하거나 사용하는 관계를 의미

쉽게 말해서 A라는 클래스가 doSomething()이라는 메서드 호출 시 B라는 클래스의 인스턴스를 사용하면 A는 B에 의존하는 것.

그냥 A에서 B를 쓰면 B에 의존하는거임.

## 결합(Coupling)

의존성이 있다는 것은 두 객체가 서로 `결합`되어 있다는 의미가 됨.

이 결합의 수준이 높다/낮다(높으면 의존성이 강함)에 따라서 소프트웨어 유연성이나 유지보수성이 같이 영향을 받음.

의존성 주입이나, 의존성 역전 원칙 같은 개념들은 모두 이 `결합`과 관련해서 `느슨한 결합`을 구현하기 위한 메커니즘들임.

의존성 주입 - 객체가 직접 의존하는 객체를 생성하는 대신 외부에서 필요한 의존 객체를 주입 받도록 하는 것. (함수 안에서 초기화 하는게 아니라 함수 파라미터로 전달하도록 구현하는거랑 비슷한 듯.). 포인트는 `의존 객체를 생성하는 책임`을 분리한다는 것에 있음. 내가 직접 생성한다 -> 뭘 생성하는지 구체적으로 알고 있어야 한다.가 됨. 예를 들어서, 나무를 자른다라는 행위를 하는 객체가 있음. 이 객체는 뭘 쓰던간에 결과론적으로 나무를 반토막 내는게 목표임. 근데 객체를 만드는 시점에 보니까, 칼로 자르는게 베스트였어. 그래서 나무 자르는 객체에 '칼을 써서 나무를 자른다'라고 고정을 해놨어. 그러면 지금 당장은 뭐 큰 문제가 없음. 근데 잘 쓰다가 1년 뒤에 보니까 아니 '톱'이라는게 나왔는데 나무를 그렇게 잘 자르네?? 그래서 톱으로 교체하려고 보니까 톱만 추가해서 되는게 아니라 나무를 자르는 역할을 하는 객체 코드도 수정해야돼. 근데 처음에 나무를 자르는 도구를 만들 때, 칼을 써서 나무를 자른다 라고 만들지 않고 '주어진 도구를 활용해서 나무를 자른다'라고 만들었어. 그러면 처음에는 칼을 줘서 자르게 하고, 나중에 톱으로 교체하더라도 사용하는 객체가 변경되었다는 이유 때문에 나무를 자르는 객체를 수정할 필요가 없어지겠지? (물론 주어진 도구에 대한 제약사항들은 존재할 수 있겟찌 예를 들어서 날카로운 날이 있어야 한다던지 하는...) 이게 맞나??

일단 여기까지가 의존성 주입이고, 의존성 역전 원칙은 '도구에 무엇이 전달되는지, 전달받는 도구에 대한 의존성을 어떻게 관리할 것인지?'의 문제라고 이해가 됨.

의존성 주입 -> 도구에 대한 'what, how to initialize'의 책임을 내부에서 외부로 위임하는 것
의존성 역전 원칙을 적용 -> 도구 자체에 대한 제약사항을 일반화해서, 주입되는(꼭 주입이 아닐수도 있지만 무튼) 의존성이 specific한 도구(ex. 칼)이 아니라, SomeKindOfCutter 같은 일반적인 형태의 객체가 될 수 있도록 하는 것. 이런 구조에서 보면, '칼'이라는 하위 객체(인스턴스)에 의존하는 형태에서, 'SomeKindOfCutter'라는 보다 상위의 객체(일반적인 특성을 기술한 재사용 가능한 형태의 객체)에 의존하게 구현함으로써 도구의 변경이 로직의 변경으로 이어질 가능성을 제한하는 것.

근데 '역전'이라는 의미를 내가 좀 잘못 이해한 것 같음. 나는 '칼'이 아니라 'SomeKindOfCutter'에 의존하는 것이 저수준 -> 고수준으로의 의존 역전이라고 생각했는데,
여기서 '고수준 모듈'이란 '나무 자르는 객체'이고, '저수준 모듈'이란 '칼' 이라고 함. 그러니까, 가장 기본적인 형태에서는 고수준 모듈인 나무 자르는 객체가 저수준 모듈의 의존함. (가져다가 쓰는 주체니까)

근데 의존성 역전은 이 고수준 -> 저수준 의존의 일반적인 형태를 역전시킨다는 의미임.(둘 다 추상화에 의존하게 함으로써 그렇게 한다는데 그게 무슨 소린지 이해가 잘 안됨. `역전`이라는 단어만 들어보면 저수준 모듈이 고수준 모듈에 의존하게 해야될 것 같은데, 막상 내용 자체는 고수준 모듈과 저수준 모듈이 둘 다 동일한 추상화 레이어에 의존하도록 한다는 거임. 그러면 사실상 `역전`이라기 보다는, 결합을 느슨하게 만들어주는 중간 매개체를 둔다 정도인데 이게 왜 `역전`임? 이라는 생각이 들었음.)

DIP 이전의 자연스러운 설계에서는 내가 이해하고 있는 것처럼 상위/주요 비즈니스 로직을 담당하는 고수준 모듈(WoodCutter)이 저수준 모듈(Knife)을 가져다 쓰는 형태였음.

근데 생각해보면 `고수준 모듈`이라는 것은 핵심적인 로직이라는 것이고, 핵심 로직이 부가적인 로직의 변경으로 인해서 같이 변경되어야 하는 것은 바람직하지 않다(불필요한 영향도가 크다)라고 이해를 했음.

보다 안정적인 WoodCutter가 보다 불안정한(변경될 가능성이 큰) Knife에 의존하는 것이 바람직하지 않음. (왜 바람직하지 않아? 뭔가 자연스럽게 그럴 것 같긴한데 정확하게는 잘 모르겠음. )

(자동차에 비유해보면, 고수준(바퀴)가 저수준(타이어)에 의존하면, 타이어를 바꿀때마다 바퀴 전체를 바꿔야하는 문제가 발생한다는거지?

그래서 중간에 추상화 계층(타이어 규격과 형태)를 만들어서, 바퀴는 뭐가됐든 그 규칙을 준수하는 타이어를 끼울 수 잇게 만들고, 타이어는 그 규칙을 준수하게 강제하면 저수준 모듈의 교체로 인해서 고수준 모듈이 받는 영향을 최소화할 수 있다는거지?)

그래서 DIP가 등장하게 된 것.(DIP는 아마 ChatGPT처럼 짜잔! 하고 등장한것 아니겠지? 사람들이 객체를 가지고 막 코딩을 하다보니까, 아 근데 이거 칼을 바꿀때마다 woodcutter를 수정해야되네 짱나는데?(유지보수성 저하) 혹은 아 칼만 바꿨는데 왜 WoodCutter기계가 안돌아가 미치겠네!!(안정성 저하) 같은 상황을 겪다보니까 더 나은 방법을 찾는 과정에서 자연스럽게 중간 레이어를 도입했고 이런 코딩 패턴을 명사화한게 DIP겠지?)

자연스러운건 당연히 도구를 상위 개념이 가져다가 쓰는거지. 근데 도구를 쓰긴하되, 개별 도구에 의존을 최대한 줄이고 싶은거임. 그러다보니까 자연스러운 흐름(개별 도구에 의존한다)에서, 약간 더 인위적이지만 고수준으로 변화의 물결이 퍼질 가능성이 적은 흐름(고수준은 추상화된 도구에 의존하고, 개별 도구는 추상화된 도구의 제약사항을 준수하는) 형태로 변경했기 때문에 '역전'이라고 하는 것.

불안정적인 것에 의존하던 형태에서 상대적으로 더 안정적인 것에 의존하도록 하는 것.(어떻게 보면 진짜 추상화 레이어를 추가하는것에 불과하긴 하네. 개별 도구들을 쫙 보니까 이런이런 특성이 공통이야, 혹은 WoodCutter를 만들려고 보니 도구로 사용되는 물건은 이러이러한 기준만 충족하면 돼. 손잡이 모양, 뭐 이런거 안중요함 이런 느낌으로 가는거지.)

불안정한 것에 의존하던 형태에서, 보다 안정적인 것에 의존하는 구조로 역전시킨다는거임.(저수준 -> 고수준으로의 역전이 아니라, 고수준 -> 저수준에서 고수준 -> 추상화된 규칙으로 변경해서 처리하는 것.)

고수준 모듈이 상대적으로 저수준 모듈의 불안정성으로부터 받는 영향을 제거 혹은 최소화. (React에서도 이와 비슷한 느낌의 구현을 했던건가? 예를 들어서 목록 렌더링할 때, 목록의 각 항목을 동일한 규칙으로 받아서 렌더링하는 재사용 가능한 컴포넌트에 의존하도록 만들면 목록의 변경으로 인한 컴포넌트 구현 변경이 필요없음. 근데 목록 개별 아이템에 맞춰서 컴포넌트를 구현하면, 목록 아이템이 변경되거나 추가될 때마다 목록을 렌더링하는 컴포넌트의 수정이 많이 필요함 이런 느낌으로 이해해볼 수 있는 것 같음. )

## Always DIP??

DIP 원칙을 지키기 위해서 모든 의존관계에 대해서 추상화 계층을 도입해야돼? 아니지 않을까 싶어서 gemini랑 대화하면서 배운 점은....소프트웨어 개발 뿐만 아니라 인생에서도 적용되는 몇 안되는 절대 법칙 중 하나인 '얻는게 있으면 잃는게 있다'임..항상 기본적으로 깔고 가야하는 사실인데 자주 까먹음(이렇게 하면 좋아! 만 볼게 아니라 이렇게 했을 때 잃는게 뭔지도 같이 보는 습관을 들여야함.) TRADE-OFF를 항상 고려해야함.

그러면 DIP를 지키기 위해서 추상화 계층을 도입했을 때 잃는게 무엇인지?
코드의 양이 늘어나고 이해하기 어렵게 됨.(개발자의 cognitive load가 증가함.)

이 비용을 감수할 가치가 있다고 판단될 때 DIP를 적용하는게 좋음.

그러면 언제는 적용하지 않는게 나을까? (나는 근데 요즘 드는 생각이 거의 대부분의 미래를 고려한 설계는 빗나가는 경우가 많다는 거임...BP를 최대한 지키되 지금 모르는걸 너무 미리 판단하려고 할 필요가 없음.)

1. 변경될 가능성이 낮다고 판단되는 `조합`인 경우(안정적인 결합)

두 모듈 간 결합이 안정적이라서 미래에 변경될 가능성이 거의 없다라고 현재 시점에 판단되는 경우 굳이 DIP를 적용해서 어렵게 만들 필요가 없음.

2. 구체적인 구현을 감출 필요가 없는 경우

3. 단순하고 작은 프로젝트

빨리빨리 일단 찍어내는게 중요한 경우..

## DIP는 DI없이 구현될 수 없다?

이 부분이 이해가 잘 안됨.

제미나이도 그렇고 [LogRocket블로그](https://blog.logrocket.com/dependency-inversion-principle/)(`In other words, without dependency injection, there is no dependency inversion.`)도 그렇고 DI가 DIP구현에 필수적이라는데 나는 그동안 내가 코딩했던 습관대로 생각해봤을 때 이해가 잘 안됨.

```python

class WoodCutter {
  # DI로 특정 interface를 준수하는 객체의 원형을 받아서, 초기화는 안에서 해도 DIP는 되는거 아닌가??
  cut(cutter: CutterType):
    cutterInstance = cutter()
}
```

이게 안된다는데 왜 안된다는건지 설명을 봐도 이해가 잘 안되네.

그래서 조금 더 알아봄. 이런 식으로 하는게 왜 DIP에 위배되는 형태가 될 가능성이 있는지.

일단 이렇게 했을 때 '저수준 모듈의 변경이 고수준으로 ripple'되는 현상이 발생할 수 있음.

더 엃히는 방향임 기본적으로

1. init() 함수가 구현체마다 다른 경우

새로운 구현체가 추가되면서 init() 함수의 수정이 필요할 수 있음.

만약에 init함수 호출을 고수준 모듈 외부가 아니라 내부에서 처리하면,(DI를 안쓰면) 고수준 모듈이 저수준 모듈(구현체)의 구현에 대한 내용을 알아야 하게 됨.

this breaks DIP. 몰라야되는데 알아버렸어. 저수준 모듈 추가했는데 고수준 모듈 코드를 수정해야돼. 으억.

하지만 DI를 활용해서 외부에서 주입해버리면? 얘가 뭘 받아서 초기화하건 신경쓸바가 아님. 그냥 주입된 정해진 프로토콜을 따르는 객체를 가져다가 쓰기만 하면 됨.

구현체별로 초기화 절차가 서로 다른 경우도 마찬가지로 문제가 됨

2. 생성 방식이 고정되어버림.

초기화하는 방식이 모든 구현체에 대해서 고정되어 버림.(유연성 저하)

what if i want to make one implementation a singleton?

DI를 활용하면 어떻게 생성된 객체건 신경쓸 필요가 없음. 외부에서 필요한 형식으로 만들어서 주입만 하면 되는거지. 나머지는 니가 하고싶은대로 해가 가능함.

3. 특정 도구별로 필요한 부가기능을 붙이는 것도 어려움

예를 들어서 어떤 도구만 logger를 추가하고 싶다고 생각해보자.

logger(init()) 뭐 이런 식이 된다던지 해야된다고 하면, 개별적으로 어케할거임?

결국 또 고수준모듈을 건드려야하는 상황이 오지.

---

이렇게 고수준 내부에서 뭔지 모르겠고 나는 send()만 호출할래. 외부에서 이거에 맞춰서 넣어주기만 해. 라는 형식이 되지 않아서 문제가 됨.

## 목적이 무엇인지 기억하기

DI/DIP의 목적 -> coupling을 낮추는 것.

coupling을 낮추는 것의 목적은? -> 프로그램 유지보수가 용이하도록 하는 것. 변화에 resilient 한 구조를 만드는 것.

그러면 유지보수에 도움이 된다고 판단되는 경우에만 coupling을 낮춰야지. 혹은 coupling을 낮춰야할 확실한 근거가 있거나.

그래야지 어떻게 coupling을 낮추지? -> 경우에 따라서 DI나 DIP를 적용해서 문제를 해결해야되는 상황들이 있음. 이렇게 이해하는게 맞을것 같기도..?

coupling을 낮추는 방법들이 여러가지가 있으니께....

커플링을 낮출 방법이 있을까?라는 생각이 들었을 때 적절하다고 판단되면 DIP 방법론을 적용해서 해결해보기 같이 해보는것.

## IoC..?

이건 또 머여 ㅋㅋㅋㅋ

좀 헷갈리긴 하는데 개념을 머리에 한 번 제대로 박아서 구조화하는게 필요해보임. 아니면 계속 보고 또보고 또보고 반복쓰..

[Dependency inversion without inversion of control](https://blog.ploeh.dk/2025/01/27/dependency-inversion-without-inversion-of-control/)
