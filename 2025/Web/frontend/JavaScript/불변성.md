- 식별자에 연결된 변수 공간에 바로 값을 저장하지 않고, 값이 저장되어 있는 메모리 주소를 저장하는 방식이라고 함.

  - 근데 그러면, 식별자가 연결된 변수를 바꾸면 되는거 아닌가? 그러면 새로운 값을 저장한 메모리 주소를 연결하는 메커니즘 자체는 동일하잖아(불변성).
    -> 이에 대해서 제미나이랑 이야기를 나눠봤는데, 공감되는 이유는 이거였음. 메모리 공간 효율성을 위해서 새로운 변수에 값을 할당할 때, 기존에 이미 동일한 값을 가진 데이터 영역 주소가 있으면 그 주소값을 저장해서 중복데이터 생성을 최소화한다고 함. 근데 식별자에 연결된 변수 공간에 값을 저장하고 업데이트 하는 방식에서는 이게 까다로워짐. 만약에 a라는 변수값이 10이라서 b에 10을 할당할 때 a의 메모리 주소를 참조했다고 생각해보자. 그러면 일단 a와 b가 동일한 레벨의 데이터(식별자)인데 1대1로 주소가 매칭되는게 아닌것도 이슈가 있을 수 있을 것 같고, 만약에 a의 값이 변경되어서 다른 값이 할당되어야 한다면? 같은 문제도 생각해봐야하고....그리고 일관성이 떨어지는 문제도 있음. 어떤 변수공간에는 값의 주소가 저장되어 있고, 어떤 변수 공간에는 값 자체가 저장되어 있으면 일관성이 없음. 식별자 - 데이터가 저장된 변수 공간 주소 - 데이터 구조로 통일하면 모든 식별자가 동일한 구조로 처리가능함.

- `불변하다` -> 한 번 특정 메모리 공간에 primitive 값(string, number, boolean, null, undefined, bigint, symbol)이 저장되면, 해당 값을 지우고 동일한 공간에 다른 값을 넣는 일은 없음(변수 재할당이라는 프로세스에서). 그러니까, 원시값은 한 번 생성되면 생명주기동안 바뀔일이 없음. 참조되는 동안에는 계속 동일한 값이 유지된다. 그래서 불변성이라고 하는거임. 왜 이렇게 만들었을까를 생각해보면 메모리 공간 관리의 효율성 때문이고. (새로운 값을 할당하는게 기존 메모리 공간 늘리는 것보다 효율적이고, 메모리 중복을 방지할 수 있는 구조가 됨)
- 객체의 프로퍼티에도 계속 객체를 중첩하는게 아니라면 언젠간 원시값이 저장될텐데 이 원시값도 불변임. 다만 객체의 프로퍼티에 연결된 메모리 주소가 변경된다고 해서 객체 식별자에 연결된 메모리 주소가 업데이트 되는 것은 아님. 그래서 객체는 동일하지만 객체 프로퍼티는 불변하지 않다고 여겨지는 거임. '불변'의 영역인 데이터 영역이 불변하는건 동일하지만, 객체의 변수영역(객체의 프로퍼티 별 변수영역)에는 얼마든지 다른 값을 연결할 수 있음. (name이라는 프로퍼티에 연결된 값의 주소를 담고 있는 변수 영역의 값은 언제든지 업데이트 가능, 하지만 name이라는 프로퍼티의 값이 담겨있는 데이터 영역의 주소에 담긴 name의 값은 불변임 변경하면 다른 주소를 할당해야됨). 객체와 같은 참조형 데이터가 가변적이라는 말은, 객체식별자에 연결된 메모리 공간은 동일한 상태에서 프로퍼티에 연결된 메모리 공간이 변경될 때만 해당됨.(객체식별자는 변경되지 않으면서 그 안에 있는 값이 변경되니까 가변적이라는거고, 만약에 객체 식별자 자체에 새로운 객체가 할당되면 기존 객체 메모리 공간은 불변이라서 이때는 불변임.)

- 복사 시 원시값 복사와 참조값 복사 후 값 변경 시 다르게 동작하는 부분은?

  - 원시값은 복사 후 재할당 시 식별자 변수 공간에 저장된 메모리 주소 자체가 변경됨
  - 참조값은? 복사 후 프로퍼티에 값 재할당 시, 객체 식별자 변수 공간에 저장된 메모리 주소는 동일함. 프로퍼티 변수 공간에 저장된 메모리 주소만 변경됨. 그러므로 복사한 식별자에 연결된 변수공간과, 원본에 연결된 변수공간은 여전히 동일하므로, 프로퍼티 값 변경이 원본에도 영향을 준다(원본에도 영향을 준다라기 보다는, 원본을 변경하는것과 같다.)

- 원시값은 불변이고 참조값은 가변적이다, 혹은 원시값은 값을 복사하고 참조값은 주소를 복사한다는 둘 다 일부만 맞는 말이거나, 정확하게 따져보면 틀린 말임.
  - 원시값이 불변이지만, 참조값도 객체 자체를 재할당하지 않는 범위 내에서 가변적이다.
  - 원시값을 복사하는 것도 주소의 복사긴 하다.(식별자에 연결된 변수 공간에는 값이 있는 '주소'가 저장되어 있으니까 해당 주소를 복사하는 것.).

# 기타

## JavaScript에서 객체 깊은 복사 로직 간단하게 구현해보는 과정에서 배운 점

- typeof null은 `object`로 평가된다. 이는 레거시 때문에 보존되어야 하는 일종의 버그라고 함.
  - 이 블로그 글 [The history of “typeof null”](https://2ality.com/2013/10/typeof-null.html?utm_source=chatgpt.com)에 의하면 `This is a bug and one that unfortunately can’t be fixed, because it would break existing code.`이라고 함. ㅎㅎ 약간 비하인드가 있는 이야기군 허허
  - 하위호환성?이라고 해야하나? 무턱대고 새로운걸 막 도입할 수 없다는걸 배우기도 했음. 레거시를 망가뜨리지 않으면서도 어떻게 새로운 기능을 도입할지 등에 대한 역량이 있는 사람이 되는것도 필요하지 않을까.
- for..in loop을 이용해서 JavaScript 객체를 순회하면 눈에 보이지 않는 key값이 iterate될 수 있음. for..in은 프로토타입 체인 상에 존재하는 모든 '열거 가능한(iterable)한' 프로퍼티 키를 순회한다고 함.
  - 이게 무슨소린고 했는데, Object.create(obj)라고 Object.create를 사용하면 obj를 상속하는 새 객체가 생성됨(빈 객체로)
  - 그러면 새롭게 생성된 객체를 console로 찍어보면 빈 객체이지만, for..in loop을 돌리면 프로토타입 객체의 프로퍼티값을 순회해서 기대와 다르게 동작할 수 있음.
  - 이 문제를 방지할 수 있는 방법은? `hasOwnProperty`를 통해서 말그대로 'own' 프로퍼티인지 프로토타입 체인에 있는 값인지 구분이 가능함.
- edge케이스를 기본적으로 확인하는 습관을 가지자.
  - 간단한 copyDeep로직을 구현할 때, 인자로 전달받은 값이 obj인지 아닌지 확인하는 로직을 짜지 않았는데 `코어 자바스크립트` 책의 저자는 해당 부분을 체크했음.
- 간단하게 깊은 복사를 할 수 있는 JSON으로 변환했다가 되돌리는 방법의 한계는, JSON으로 변환할 수 없는 값이 무시된다는 점.(메서드, **proto**, getter/setter 등)
  - `무시된다`라는게 무슨 의미야?
  - 간단하게 코드 짜서 테스트해보니, method는 변환된 객체에 아예 존재하지 않고, getter는 해당 getter함수 이름에 return value가 매핑되어서 들어오고, setter도 사라짐.
  - **proto** 에 저장되어 있는 프로토타입 객체가 Object가 아니라 별도 객체였다면 해당 정보도 유실됨.
  - 웬만하면 순수한 정보 다룰때만 써라.

---

작성했었던 코드들

```javascript
// 재귀를 활용해서 중첩객체 깊은 복사하는 방법

// 라이브러리를 써도 되지만 직접 구현해야 한다면 어떻게 구현할 것인가?

// null도 typeof를 처리하면 객체라고 나온다고 함
console.log(typeof null); // object (not 'null' for legacy reasons)
// null value represents the intentional absence of any object value. It is one of JavaScript's primitive values and is treated as falsy.

// 참고로 중첩 객체일 때만 동작하고, 프로퍼티값이 배열인 경우는 처리하지 못함.(모든 케이스를 커버하지 않는다는 뜻.)
function copyDeep(obj) {
  // sudo
  // obj의 key를 순회하면서,
  // 만약에 key의 값이 object인 경우에는? 어떻게 판별할거야 object인지 여부를?
  // object인것만 체크하면 되나???
  // object라면 어떻게 재귀적으로 처리할 것인지?
  const result = {};

  for (const key in obj) {
    // null도 object로 type이 평가되니까 방지 로직이 같이 들어가야함.
    if (typeof obj[key] === "object" && obj[key] !== null) {
      // 중첩 복사
      result[key] = copyDeep(obj[key]);
    } else {
      result[key] = obj[key];
    }
  }

  return result;
}

const notNestedObj = {
  name: "jeff",
  age: "20",
};

const nestedObj = {
  language: "javascript",
  developer: {
    name: "jeff",
    level: "junior",
  },
};

const newNotNestedObj = copyDeep(notNestedObj);
const newNestedObj = copyDeep(nestedObj);

console.log(newNotNestedObj === notNestedObj); // false
console.log(newNestedObj === nestedObj); // false

console.log(newNestedObj.developer === nestedObj.developer); // false

newNestedObj.developer.level = "mid";
console.log(nestedObj.developer.level); //junior

const origin = { origin: "jeff" };

const inherited = Object.create(origin);

console.log(inherited); // {}

// 처음알았네. Object.create를 하면

inherited.inherited = "inherited value";

for (const key in inherited) {
  console.log(key, ` ${inherited[key]}`);
}
```

---

```javascript
// JSON으로 변환해보기

function copyWithJson(obj) {
  return JSON.parse(JSON.stringify(obj));
}

const normalObj = {
  name: "jeff",
  age: 20,
};

const inheritedNormalObj = Object.create(normalObj);

inheritedNormalObj.name = "inherit";
inheritedNormalObj.age = "20000";

// 메서드는 어떻게??
const objWithMethod = {
  number: 1,
  someFunc: () => {
    console.log("someFunc");
  },
};

// getter는 어떻게?>
const objWithGetter = {
  name: "ji",
  // get Name() {
  //   return this.name;
  // },
  set Name(newName) {
    this.name = newName;
  },
};

console.log(inheritedNormalObj.__proto__);
console.log(copyWithJson(inheritedNormalObj).__proto__);
console.log(copyWithJson(objWithGetter));
console.log(copyWithJson(objWithMethod));
```
