# 13 best practices for user account, authentication, and password management

[13 best practices for user account, authentication, and password management](https://cloud.google.com/blog/products/identity-security/account-authentication-and-password-management-best-practices?hl=en)

사이드 프로젝트(자산관리 앱) 만드는 과정에서, api 인증 로직을 구현할 때 유저의 어떤 정보를 가지고 인증을 해야되는지 고민돼서 찾다가 보게 된 글.

# 1. hash those passwords

민감정보를 안전하게 관리하는 것이 가장 중요함.

암호학적으로 견고한 해싱 알고리즘을 써서 비밀번호 꼭 해싱해서 저장해라(SKT가 아마 해싱도 안하고 비밀번호를 통으로 DB에 저장했었다고 했지..)

해시함수를 통해서 생성된 해시값을 `salt`하라고 함. 그냥 해시값만 저장하면 레인보우 테이블이라는, 해시값에 대한 비밀번호 쌍을 엄청 많이 만들어두고 매칭되는 값을 찾는 공격에 대해 취약하다고 함.

왜? 해시값은 동일한 입력에 대해서 항상 결과값이 동일하기 때문에.

그래서 `salt`라고 부르는 임의의 문자열을 비밀번호에 추가해서 암호화함. 그러면 레인보우 테이블이 쓸모가 없음.

근데 그러면 나는 유저 인증을 어떻게 진행해?라는 의문이 들었음 -> salt값도 DB에 같이 저장하는거라고 함(유저마다 다 다르게 생성되는 임의의 값이라서 그럴 수 밖에 없다) -> 근데 그러면 salt같이 탈취하면 되지 않아? -> salt + 비밀번호를 통해서 생성된 hash 값은 이미 저장해둔 매칭 테이블 사용불가 -> 계산 비용이 너무 커서 공격 속도가 느려진다.(사실상 불가능이라고 보기도 한다고 함.)

(참고로 key stretching이라고 해시를 N번 수행하는 방법도 레인보우 테이블 방어에 효과적이라고 함. 그리고 pepper라고, DB에 저장하지 않지만 어딘가에 보관하는 global하게 암호화에 적용되는 값을 사용하는 것도 하나의 방법.)

무튼 이번에 서비스 만드는 것도(그리고 앞으로도) 최소한 salt값은 이용해서 비밀번호 저장하자(내가 의사결정이 가능하고, hash해서 저장하는 시스템이라고 하면)

DB가 뚫릴 가능성이 항상 존재한다고 생각하고 인증 시스템을 구축해야한다고 함.(이렇게는 생각 못해봤는데 맞는 것 같음. SKT사태를 생각해보면 뚫려도 해싱값이었으면 더 안전했겠지..)

지금 DB가 뚫려도 개인정보가 위험하지 않도록 저장하는 방법에 대해서 이해해야함.

# 2. Allow for third-party identity providers if possible

구글 로그인 같은 검증된 써드파티 identity provider를 사용하라고 추천함.

그러면서 IDaaS 같은 것도 써보라고 하는데...이건 약간 홍보같기도..?(물론 쓰면 더 안전하겠지만 너네 그거 돈받쟈나...) 이런 마인드 때문에 보안이 경시되는건가..?

비판적으로 볼 필요는 있다. 실제로 그정도의 도움이나 효용이 있는지 등등 비용은 어떻게 되는지..

# 3. Separate the concept of user identity and user account

이 부분이 제일 좀 와닿은 부분임.

email, 폰번호, unique username 등 인증을 위해서 흔히 사용되는 요소들을 해당 유저를 식별하는 key같은 역할로 쓰지 말라고 함.

이런 값들은 사용자와 연관된 데이터를 변경하지 않고, `PII(Personally identifiable information)`을 변경하지 안하고 수정이 가능토록 해줘야 한다고..

이걸 분리를 잘하면,

- 써드파티 인증 도입 수월하고
- 유저네임 변경 쉽고
- 여러 identity를 하나의 계정에 연결할 수도 있음.

쉽게 말하면, User테이블 하나 만들고 식별자를 email, username과 같이 User를 나타내는 일부의 정보와 결합시켜서 구현하지말고,

유저마다 시스템 안에서 Global하게 사용할 수 있는 별도의 user_id를 만들고, 여러 가지 정보를 해당 id 값에 연계해서 관리하라는 소리임.

많은 경우 이렇게 설계되어 있는데(내가 이번에 만드는 서비스도 그렇고...)

```
사용자 테이블
- email (기본키)
- password
- 프로필 정보
- 사용자 데이터
```

이메일 변경도 어렵고, 소셜 로그인 추가하려면 복잡하고 등등 문제가 생김.

```
사용자 테이블
- user_id (내부 고유 식별자)
- 프로필 정보
- 사용자 데이터

인증 테이블
- auth_id
- user_id (외래키)
- provider (email, google, facebook 등)
- credential (이메일, 소셜ID 등)
- password_hash (해당되는 경우)
```

분리해서 설계하면?

- 한 사용자가 여러 인증 방법 사용 가능(이메일 로그인이건 구글 로그인이건 하나의 계정으로 연결할 수 있음. 이 글의 4번이 Allow multiple identities to link to a single user account 인데, 이게 가능해지겠지?
- 정보 변경 용이함(식별하는 기능에 영향을 주지 않고 이메일, 유저이름 등 정보를 변경할 수 있음)
- 로그인 방법 변경이 유저 정보에 영향을 주지 않음.
- 데이터 무결성: 사용자가 여러 개의 로그인 방법을 가지고 있더라도, 이 모든 정보가 하나의 고유한 아이덴티티에 연결되어 있어 데이터의 일관성을 유지할 수 있습니다.
- 보안 강화: 인증 정보(계정)와 사용자 정보(아이덴티티)가 분리되어 있어, 한쪽의 보안이 침해되더라도 다른 쪽에 미치는 영향을 최소화할 수 있습니다.

결합도를 낮추고(이메일 변경이 다른 모든 외래키 업데이트를 유발하는 등의 일이 없도록) 응집도를 높이는(User테이블에 인증 관련 정보, 프로필 관련 정보 등등이 섞여있는게 아니라 각각 정보가 분리) 방향이라고 함

만약에 User테이블 하나에 다 때려넣었다면..?

구글 로그인 추가하려면,

- 사용자 테이블에 컬럼 추가해야함(google_id)
- 로그인 로직 수정되어야 함
- 관련 코드 수정되어야 함

분리된 방식에서는?

- 인증 테이블에 새 레코드만 추가하면 됨
- 사용자 데이터 아예 건드릴 필요 없음
- 인증 로직만 약간 수정하고, 다른 모듈은 영향 받지 않음(어차피 시스템 안에서 user를 식별해서 해당되는 리소스를 연결하는 value는 user_id같이 있으니까..)

**실용적인 구현 방법**
이 개념을 실제로 구현하기 위해서는 내부적으로 모든 사용자를 식별하는 고유한 ID를 만드는 것이 좋습니다. 이 ID는 이메일이나 전화번호 같은 외부 인증 정보와는 아무런 관련이 없는, 추상적인 식별자입니다.

사용자 아이덴티티: 이 고유 ID를 중심으로 사용자의 프로필, 설정, 데이터 등 모든 정보가 연결됩니다.

사용자 계정: 이 고유 ID에 사용자가 로그인에 사용하는 이메일, 전화번호, 소셜 로그인 정보 등을 연결합니다.

예를 들어, 한 사용자가 "이메일 A"와 "구글 계정 B"로 로그인할 수 있다면, 이 두 계정은 내부적으로 동일한 "고유 ID 123"에 연결되는 구조입니다. 이렇게 하면 사용자는 어떤 계정으로 로그인하든 동일한 프로필과 데이터를 볼 수 있게 됩니다.
