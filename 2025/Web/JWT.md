# JWT..? JSON Web Token??

JSON Web Token이라는 것의 의미가 뭐지??

RFC 7519에 정의된 표준으로, JSON 객체를 사용하여 정보를 안전하게 전송하는 방법을 제공한다.

**JSON**

토큰의 형식과 구조가 JSON 기반이다.

JSON은 Data Interchange Format으로, 사람에게는 읽기 쉽고 기계에게는 파싱하기 쉬운 데이터 형식이다.

JSON이 왜 이름에 들어갔냐? JWT를 구성하는 요소 중 하나인 payload, 즉 전달하고자 하는 데이터가 JSON 형식으로 담겨있기 때문이다.

참고조 JWT는 세 부분으로 구성된다.

HEADER + PAYLOAD + SIGNATURE

각 부분은 Base64로 인코딩되어 있고, 문자열에서는 .으로 구분된다.

참고로, JWT는 보통 인코딩되어 있긴하지만, 암호화되어 있지 않기 때문에 누구나 탈취에 성공하면 정보를 해석할 수 있다. 그러므로 중요한 점은 정보 전달을 위해서 JWT사용 시 민감정보를 전달하지 않는 것이다.

SIGNATURE는 개인적으로 직관적으로 와닿지는 않는 개념인데, 이 정보가 위조되지 않았음을 증명하는 역할을 한다. 즉, JWT가 유효한지 검증하는 역할을 한다.
대칭키/비대칭키 알고리즘을 사용해서 서명한다.

```json
// HEADER의 일반적인 구성
{
  "alg": "HS256", // 알고리즘
  "typ": "JWT" // 토큰 타입
}

// PAYLOAD의 구성
// claim이라고 하는, 이 사람이 이런 사람이야!라는 정보가 담겨 있음.
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "admin": true
}

// SIGNATURE의 구성
```

```json

```

**Web**

JWT는 주로 웹 환경에서 사용됨.

HTTP 헤더에 담아서 stateless 인증 구현을 위해서 사용됨.

**Token**

인증이나 권한 정보를 담은 짧은 문자열로, 클라이언트가 서버에 요청 보낼 때 이 토큰을 함께 전송한다.

# JWT를 이용한 인증 과정

1. 로그인 요청 - 클라이언트에서 사용자 인증정보(아이디 비밀번호 조합 같은...)를 서버로 전송
2. 서버에서 인증 정보 검증 - 서버는 클라이언트가 보낸 인증 정보를 검증하고, 유효한 경우 JWT를 생성하고 서명에서 클라이언트에 반환
3. 클라이언트는 JWT를 locally store
4. Authorization: Bearer {token} 형식으로 헤더에 담아서 권한이 필요한 리소스를 요청함
5. 서버는 JWT를 검증하고, 유효한 경우 요청을 처리함

# 언제 사용하지 말아야 하는가??

- 민감 정보 전송
  - JWT는 암호화되지 않기 때문에 민감한 정보를 담지 말아야 한다. 예를 들어, 비밀번호나 신용카드 정보 같은 것은 JWT에 담지 않는 것이 좋다.
- 세션관리
  - JWT는 stateless 인증을 위해 설계되었기 때문에 세션 관리가 필요한 경우에는 적합하지 않다. 예를 들어, 사용자의 세션 상태를 서버에서 관리해야 하는 경우에는 JWT보다는 세션 쿠키를 사용하는 것이 더 적합하다.

# 근데 애초에 왜 이런 인증 방식이 필요하지??

다음 영상을 보면서 정리한 내용이다. [What is JWT? JSON Web Tokens Explained (Java Brains)](https://www.youtube.com/watch?v=soGRyl9ztjI)

기본적으로 클라이언트와 서버가 통신하는 구조를 보자.

클라이언트는 원하는 리소스를 주소로 요청하고, 서버는 요청된 리소스에 대한 정보를 반환.

각 요청-응답은 독립적이다. 이전/이후 응답과 전혀 관계가 없으며, 각 요청이 필요한 정보를 담고 있는 self-contained 한 구조. 더 명확히 말하면 서버가 요청을 처리하기 위해서 이전의 요청을 기억할 필요가 없다.

이 구조는 누구한테나 동일한 정보를 제공하는 Static Server App인 경우에는 인증을 위해 별도의 시스템을 고안할 필요가 없음. 그냥 누구에게나 동일한 정보를 제공하면 됨.

하지만 요청하는 사람에 따라 정보를 다르게 제공해야 하는 Dynamic Server App인 경우에는..? 요청을 처리해줘도 되는지, 안되는지 판단할 근거가 필요해짐.

그러면 서버에 보내는 정보가 2가지가 필요해짐

- information you want
- who you are

Remember, 서버가 요청에 대해서 처리하기 위해서 사용하는 정보는 전부 Request에 담겨있어야 한다. 그래서 이 Who you are에 대한 정보를 담아서 보내기 위한 방법이 필요한 구조였다.

# Authorization Strategies, 인증을 위해서 사용되는 방법들.

Token을 사용하는 방식

- Session Token
- JWT

## 세션 토큰 방식은..?

최초 인증 후, 서버에서 세션에 대한 정보를 저장하고 세션 ID를 클라이언트에 전달한다. 클라이언트는 이후 요청 시 이 세션 ID를 함께 보내고, 서버는 세션 ID를 통해 세션 정보를 조회하여 인증을 처리한다.

이 방식은 Stateful한 방식으로, 서버가 세션 정보를 유지해야 한다. 즉, 서버는 클라이언트의 상태를 기억해야 한다.

그리고 통상적으로 이 Session ID는 쿠키에 저장되어 전송된다.

이 방식이 Most Popular한 인증 방식이었다고 함.

하지만 이 방식은 몇 가지 문제점이 있었고, 그래서 This is where JWT comes in.

가장 큰 문제점은 이 방식이 단일 서버를 가정하고 있다는 점이다. 이 방식이 만들어질 당시에만 해도 단일 서버로 구성된 애플리케이션이 대부분이었다.

하지만 요즘은 어떻지? 단일 서버로 구성된 애플리케이션이 아닌 경우가 많다. (현대 애플리케이션들은 대부분 로드밸런서를 사용해서 여러 서버로 구성되어 있다.)

이게 왜 문제가 돼? 동일한 클라이언트가 보내는 서로 다른 요청들이 동일한 서버로 전송된다는 보장이 없다. 즉? 세션 정보를 서버1에 생성했는데 서버2로 다음 요청이 전송되면..? 세션 정보를 어떻게 공유하지 같은 문제가 발생함.

그래서 이런 문제를 해결하는 일반적인 접근법이 Shared Session Cache(Like Redis)를 사용하는 것

근데 이 Shared Session Cache를 사용하는 구조의 가장 큰 문제점은..? one single point of failure가 발생한다는 점이다. 즉, Shared Session Cache가 다운되면..? 모든 서버가 세션 정보를 조회할 수 없게 된다.

그래서 이 방식 말고 Sticky Session을 사용하는 방법도 있다. Sticky Session은 로드밸런서가 클라이언트의 요청을 항상 동일한 서버로 보내는 방식이다. 이 방식은 세션 정보를 서버에 저장할 수 있지만, 로드밸런서가 다운되면..? 모든 세션 정보가 사라지게 된다. 확장성이 떨어진다 그리고 왜냐하면 Sticky Session은 로드밸런서가 클라이언트의 요청을 항상 동일한 서버로 보내야 하기 때문에, 서버의 부하가 불균형하게 분산될 수 있다.

또한 마이크로서비스 구조에서는 세션 정보를 공유하는 것이 어렵다. 각 서비스가 독립적으로 동작하기 때문에, 세션 정보를 공유하는 것이 복잡해진다.

최초 요청 이후에 세션 정보를 서버에 보관하고 이를 기반으로 인증을 처리하는 구조 자체가 가지는 한계가 있다. 즉 State를 보관해야된다는 점에서 생기는 여러 가지 문제점들을 애초에 해결할 필요가 없다면..? 짐 켈러가 말했던 그런 느낌인 것 같은데, 예전에 봤던 영상에서 짐 켈러는 3~5년마다 시스템을 처음부터 다시 재설계하는게 큰 발전을 가져온다고 했었던 것 같다.

기존 구조에서 생기는 문제점들을 해결하기 위한 방법들을 고안해내는 것도 당연히 중요하고 하나의 접근법이지만, 태생적 한계가 파악이 되었따고 하면..? 애초에 다른 인증 방법을 고안하면 여러 가지 문제점들이 애초에 해결할 필요가 없는 문제가 될 수 있겠지.

State를 보관해야한다는 점에서 생기는 문제점들이라는 점에서, State를 보관하지 않아도 되는 구조를 만든다면??

예를 들어, 고객이 CS 센터에 방문했을 때 당장 고객의 요청을 처리할 수가 없다고 생각해보자. 근데 그러면 고객이 내일 다시 와서 다른 사람한테 또 비슷한 CS를 설명하는건 비효율적이잖아. 그러면 CS센터가 고객에게 CS내용을 담은 종이를 하나 주고, 내일 이거 들고 오면 알아서 처리될거임 하면 어떨까? 그리고 다음날 CS센터는 그 종이만 보고 상황을 알 수 있어서 고객이 굳이 다시 설명할 필요가 없는거지.

CS센터는 별도로 정보를 관리할 필요가 없고, 종이 받아서 처리하면 된다.

하지만 여기서 한 가지 문제점은..? 종이를 들고 왔을 때, 이 종이가 CS센터에서 발급해준 종이가 맞고 내용 또한 변조되지 않았음을 어떻게 알 수 있을까?

이 종이가 바로 JWT이다.

그리고 무결성 문제는?? JWT는 서명(Signature)을 통해 해결한다. JWT는 Header, Payload, Signature로 구성되어 있고, Signature는 Header와 Payload를 조합하여 비밀 키로 서명한 것이다. 이 서명을 통해 JWT가 변조되지 않았음을 검증할 수 있다.

그래서 서버는 요청을 처리하기 전에 JWT를 검증하고 서명이 유효한지 확인한다. 만약 JWT가 유효하다면, 서버는 JWT에 담긴 정보를 사용하여 요청을 처리한다.

State가 서버에서, 클라이언트 및 클라이언트에서 보내는 요청에 담겨있는 형태로 옮겨간 것.

# 그러면 이거는 웹에서만 유효한 전략이야??

아니지. 진짜 자유롭게 보면 어떤 상황에서든 인증 및 인가를 위해서 JWT를 사용하는게 가능하다.

# Reference Token vs Value Token

세션 토큰은 Reference Token이라고 볼 수 있다. 실제 인증 정보를 참조할 수 있는 키값을 담고 있는 토큰

반면 JWT는 Value Token이라고 볼 수 있다. JWT 자체가 인증 정보를 담고 있는 토큰이기 때문이다.
