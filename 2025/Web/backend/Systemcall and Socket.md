# 서버가 어떻게 클라이언트 요청을 수신하는지 공부하는 과정에서 Gemini가 알려준 내용

**공부는 해야됨 시간이 너무 늦어서 그냥 답변만 정리해두고 잔다...**

✦ 네, 정확한 핵심을 짚으셨습니다. 운영체제(OS)가 중간에서 중요한 다리 역할을 합니다. 프로그램이 직접
하드웨어(네트워크 카드)를 제어하는 것은 매우 위험하고 비효율적이기 때문에, OS가 이 모든 과정을 관리하고
프로그램에게는 추상화된 통신 방법을 제공합니다.

이 과정을 "시스템 콜(System Call)" 과 "소켓(Socket)" 이라는 키워드로 설명할 수 있습니다.

1단계: 사전 약속과 창구 개설 (프로그램 -> OS)

서버 프로그램(예: Nginx)이 시작될 때, OS와 미리 약속을 맺습니다.

1.  `socket()` 시스템 콜: 프로그램이 OS에게 "저 이제부터 네트워크 통신을 할 거니까, 통신할 때 쓸 수 있는
    '창구' 하나 만들어주세요" 라고 요청합니다.

    - OS의 역할: OS는 이 요청을 받고, 네트워크 통신에 필요한 내부 데이터 구조(메모리 공간 등)를
      만듭니다. 그리고 그 창구를 식별할 수 있는 '번호표'를 프로그램에게 돌려줍니다. 이 번호표를 파일
      디스크립터(File Descriptor) 또는 소켓 디스크립터라고 부릅니다. 프로그램은 앞으로 이 번호표를
      가지고 통신 관련 모든 요청을 하게 됩니다.

2.  `bind()` 시스템 콜: 프로그램은 받은 번호표(소켓)를 가지고 OS에게 "이 창구(소켓)는 80번 포트 전용으로
    사용하겠습니다" 라고 특정 포트와 연결(바인딩)합니다.

    - OS의 역할: OS는 "알겠다. 이제부터 80번 포트로 들어오는 모든 요청은 이 프로그램과 관련된 것이다"
      라고 기록해 둡니다.

3.  `listen()` 시스템 콜: 프로그램이 "이제 80번 포트 창구로 손님(연결 요청)을 받기 시작해주세요" 라고
    OS에게 알립니다.
    - OS의 역할: OS는 이때부터 네트워크 카드를 통해 80번 포트로 들어오는 TCP 연결 요청을 감지하고 받기
      시작합니다.

2단계: 데이터 도착과 전달 (OS -> 프로그램)

이제 클라이언트로부터 HTTP 요청 데이터가 서버로 들어오는 상황입니다.

1.  데이터 수신 (하드웨어 -> OS):

    - 네트워크 카드(하드웨어)가 전기 신호로 된 데이터 패킷을 받습니다.
    - 네트워크 카드는 이 데이터를 OS가 관리하는 메모리 영역(커널 공간 버퍼)으로 옮깁니다. 이때 데이터는
      아직 프로그램에게 전달되지 않았습니다. OS가 안전하게 보관하고 있는 상태입니다.

2.  프로그램 깨우기 (OS의 역할):

    - OS는 80번 포트와 연결된 소켓으로 데이터가 들어온 것을 확인합니다.
    - OS는 이 소켓을 사용 중인 서버 프로그램에게 "너한테 데이터 왔어!" 라는 신호를 보냅니다. 만약
      프로그램이 다른 일을 하느라 잠시 쉬고 있었다면(sleep 상태), OS는 이 프로그램을 깨워서(wake up)
      CPU를 사용할 수 있도록 스케줄링합니다.

3.  데이터 복사 (OS -> 프로그램):

    - 잠에서 깨어난 프로그램은 `read()` 또는 `recv()` 라는 시스템 콜을 호출합니다. 이것이 바로 "데이터
      주세요" 라는 요청입니다.
    - 이 요청을 받은 OS는 자신이 보관하던 커널 공간 버퍼의 데이터를 프로그램이 지정한 메모리 공간(사용자
      공간 버퍼)으로 복사해줍니다.

    !Kernel to User Space Copy (https://i.stack.imgur.com/q6n4m.png)
    (위 그림처럼 OS 영역(Kernel)에서 프로그램 영역(User)으로 데이터가 복사됩니다.)

3단계: 코드 실행 (프로그램의 시간)

- 이제 데이터가 프로그램의 메모리 안으로 완전히 들어왔습니다.
- 이때부터는 온전히 프로그램의 시간입니다. CPU는 OS의 스케줄링에 따라 이 프로그램의 코드를 실행합니다.
- 프로그램은 메모리에 복사된 데이터를 읽고, "아, GET /index.html 이라는 요청이구나" 라고 HTTP 규약에
  따라 해석한 뒤, 그에 맞는 로직(예: 디스크에서 index.html 파일을 읽는 코드)을 실행하게 됩니다.

핵심 정리

- 프로그램은 OS에게 '시스템 콜'이라는 정식 절차를 통해서만 네트워크 관련 요청을 할 수 있습니다. (창구
  만들어줘, 데이터 들어오면 알려줘, 데이터 줘 등)
- 데이터는 OS가 먼저 받아서 '커널 메모리'에 안전하게 보관합니다.
- 프로그램이 read() 시스템 콜을 호출하면, 그때 비로소 OS가 프로그램의 메모리로 데이터를 '복사'해줍니다.
- 데이터가 프로그램 메모리로 넘어온 이후에야, CPU가 해당 프로그램 코드를 실행하여 그 데이터를 '해석'하고
  '처리'합니다.

이러한 OS의 중재 덕분에 여러 프로그램이 동시에 네트워크를 사용해도 충돌이 나지 않고, 프로그램은 복잡한
하드웨어 제어 없이도 편리하게 통신 기능을 구현할 수 있는 것입니다.
