# 섹션2 설계의 중요성

다음 영상들에 대한 내용 정리(영상6~9번)

- 데이터베이스 설계의 첫걸음
- 잘못된 설계가 부르는 재앙
- 설계의 3단계: 개념, 논리, 물리

## 데이터베이스 설계의 첫걸음.

질문에서 시작하네. 좋은 것 같음. 왜 설계를 해야될까.

그냥 필요하면 테이블 추가하고 컬럼 추가하고 하면 되는거 아님?

집 짓는 걸 생각해보면, 갑자기 생각났다고 해서 기둥 하나 더 세우고, 구멍하나 더 뚫고 이러다가는 망하기 십상임.

- 이쁘지 않거나,
- 구조적 결함이 생기거나

뭐라도 문제가 생기겠지.

DB 테이블도 마찬가지로 일단 만들고 보자는 식으로 가면

- 처음에 속도는 빠를 수 있음.
- 서비스가 커지면서 데이터가 복잡해지면 문제가 기하급수적으로 증가.

어떤 문제들이 생길 수 있어?

- 간단한 기능 추가를 위해서 기존 코드를 엄청 수정해야된다던지
- 앱 속도가 느려져서 고객 만족도 하락으로 리텐션이 떨어진다던지 하는..서비스 자체의 건전성을 해치는 문제로 이어짐.

강의에서 언급된 이 부분이 좋다고 생각이 들었음.

`감`에 의존해서 만드는게 아니라, 체계적인 원칙과 절차에 따라서 데이터의 구조를 잡아나간다는 점.

감으로 하면 타인을 설득할 수도 없고, 문제가 생겼을 때 왜그렇게 했어라고 하면 '그냥 느낌이었어요' 라고 할건가? 하는 생각이 들었음.

키/식별/비식별 관계 등 사항들을 얼마나 잘 설계하는지에 따라서 미래의 변경사항이 왔을 때 잘 대처하거나/모든걸 뜯어고치거나 기로에 서게 됨.

그리고 DB설계가 가장 중요하다고 보는 이유 중 하나는, 파이썬코드/자바 코드는 상대적으로 수정하기가 쉬운 반면 DB스키마(구조) 수정은 소요되는 리소스가 훨씬 크다고 함. (기둥 위치 바꾸려면 집 전체 안정성을 고려해야되는것과 비슷함)

요즘처럼 서비스에 대한 요구사항이 시시각각 변하는 시대에는 설계할 때 요구사항 변화에 유연하게 대처할 수 있는 '튼튼한 기반' 마련이 중요한 포인트임. '튼튼한 기반'이 뭔지 알아보자.

너무 어렵게 생각할 필요는 없다고 보이는게,

'몇 가지 정말 중요한 원칙을 기반으로 그대로 설계하면 무난하게 좋은 설계를 하는게 가능함'이라고 함.

## 잘못된 설계가 부르는 재앙

**'나쁜 설계'란?**

고객/주문정보 관리를 위해 `orders` 테이블을 만들어서 모든 정보를 때려박았다고 생각해보자.

(내가 그랬을 것 같음..)

`주문번호/고객 아이디/고객 이름/고객 주소/상품 번호/상품 이름/상품 가격/주문 날짜`로 구성됨.

강의를 듣기 전에 생각해보자. 이 테이블로 인해서 어떤 문제가 생길 수 있을까?

어떤 요구사항 변경이 이 테이블에 영향을 줄 수 있을지를 생각해보자.

진짜 모르겠긴한데 하나라도....진짜 모르겠다 근데 ㅠㅠㅠ ....배워보자..허허

**`나쁜 설계`의 3대 문제점**

데이터 무결성 훼손/성능 저하/유지보수 비용 증가라는 3가지 문제가 발생됨

1. 데이터 무결성 훼손(신뢰도 하락)

데이터 정확하고 일관되게 관리되고 있다고 믿고 가져다 쓸 수가 없게 됨.

- 같은 고객이 여러 번 주문하는 경우에 어떤 문제가 발생할까?
  - 고객아이디/이름/주소 같은 데이터가 매번 중복 저장됨.
  - 중복데이터로 인한 저장공간 낭비도 문제지만 더 심각한 문제는 `이상현상(Anomaly)`에 있음.
  - 어떤 고객이 본인의 주소지 정보를 변경하는 경우를 생각해보자. 개발자가 고객 아이디를 기준으로 UPDATE쿼리를 짜면 괜찮지만, 뭔가 놓쳐서 주문 아이디를 기준으로 주소지를 업데이트 시켜버린다면? 같은 테이블에 고객 아이디가 같은데 주소가 다른 데이터들이 존재하게 됨. 나중에 보면, 이 고객의 진짜 주소가 뭔지 어떻게 알 수 있을까? PROBLEM!
  - 이걸 `수정 이상`이라고 한다고 함. 하나의 정보를 바꾸기 위해서 여러 데이터를 수정해야하고(여러 row) 그 과정에서 변경대상인 데이터를 전부 수정하지 않았을 때 데이터 불일치가 발생하는 현상을 말함.
- 새로운 고객을 추가해야되면?

  - 고객테이블이 없이 주문으로 고객정보도 같이 관리하고 있어서, 주문정보 없이 고객정보를 추가할 수 없는 문제가 발생한다. - 이를 `삽입 이상`이라고 함. 불필요한 정보를 넣어야지만 원하는 데이터를 저장할 수 있는 불합리한 상황.

- 고객이 탈퇴해서 정보를 날려야한다면?
  - 고객정보를 지우기 위해서는 모든 주문 내역을 지워야하는데, 이래버리면 이 고객이 우리 서비스를 이용했었다는 데이터 자체가 다 날라가버림. 유지되어야 하는 정보(어떤 물건이 언제 얼마나 팔렸는지 등등) 같이 날라가버림.
  - 이걸 `삭제 이상` 이라고 한다. 특정 정보를 삭제하는게 유지되어야 하는 다른 중요한 정보까지 연쇄적으로 삭제되는 현상.

2. 성능 저하

orders 테이블에 수억건의 데이터가 쌓였다고 생각해보자.

데이터 조회속도가 눈에 띄게 느려진다고 함.

특정 고객의 주문 내역을 조회하는 쿼리를 수행하면, 모든 테이블 전체를 뒤져야한다.(근데 이거는 테이블을 분리해도 결국 주문 정보가 있는 테이블의 데이터를 다 조회해야되지 않나..?)

앞으로 배워보자.

3. 유지보수 비용 증가

`비즈니스는 계속 변한다.`

잘못된 설계는 변하는 비즈니스에 빠르게 대응하는데 발목을 잡을 수 있다

- 작은 변경의 큰 파급효과
  - 고객등급을 도입한다고 생각해보자. 테이블 전체에서 해당 고객 주문정보 다 찾아서 일일이 수정해야됨.
- 애플리케이션 로직 복잡성 증가
  - 이상 현상 방지하기 위해서 방어 로직을 짜게 됨. (앞서 봤던 것처럼 고객 아이디가 아니라 주문 아이디로 업데이트하도록 강제하는 코드를 넣는다던지 하는...)

이런 식으로 작은 문제들이 누적되어서 갈수록 변화에 대응하는 속도와 앱 속도가 같이 느려질 수 있음.

## 설계의 3단계: 개념, 논리, 물리

### 1단계: 개념적 설계

우리가 다루어야할 데이터(Entity)는 무엇이며, 그 데이터들은 서로 어떤 관계(Relationship)에 있는가?라는 핵심 질문에 대한 답을 내고, 산출물로 `ERD(Entity-Relationship Diagram)` 도출.

ERD

- 사람의 눈으로 이해하기 쉬운 설계도
- 고객은 주문을 할 수 있고, 하나의 주문에는 여러 개의 상품이 포함될 수 있다 같은..

이 단계에서 중요한 점은, 복잡한 설계 이론을 가지고 **설계를 하는게 중요한게 아니라는 점.**

이 단계에서 제일 중요한 것은 해당 프로젝트 관계자(개발자, 디자이너, 사업 부서, 등등)들이 이 그림 한 장 가지고 '아 우리 시스템이 이렇게 되어야 하는구나'라고 공통된 이해를 기반으로 대화를 할 수 있어야 함. `대화`가 핵심. 이야기를 맞춰야 한다고 함.

그래서 절대 개발자만 아는 언어로 작성하면 안된다. 모두가 이해할 수 있는 언어로 작성되어서 대화의 기반자료가 되어야 함.

이 단계는 RDB랑 아예 상관이 없음 그냥 객체 만들 때 써도 됨

### 2단계: 논리적 설계

이 단계부터는 RDB에 연관된 작업을 시작하는 단계임.

핵심은 관계형 데이터베이스 이론에 맞게 설계하되, 특정 DB에 종속적이지 않은게 중요함.

핵심 질문

- 개념모델의 각 요소를 어떤 테이블 구조로 표현할 것인가?
- 데이터 중복을 막고 관계를 명확하게 하기 위해서 어떤 규칙(정규화)를 적용해야 하는가?

산출물: 정규화된 테이블 스키마

- 엔티티를 테이블로 만들고, 어떤 컬럼을 가질지, 기본키와 외래키는 무엇으로 할지 등을 명확하게 정의한다.
- 1단계에서 만든 대략적인 스케치를 가지고 각 방의 정확한 크기, 창문의 위치, 구조물의 재질 등을 명시한 상세 설계도를 작성하는 것과 같음.

### 3단계: 물리적 설계

논리적 설계 단계에서 만든 스키마를 바탕으로 실제로 사용할 RDBMS의 특성에 맞게 구현하는 마지막 단계

핵심 질문

- 각 컬럼에 어떤 타입을 할당해야 효율적일까?(VARCHAR, INT 등..)
- 어떤 컬럼에 인덱스를 설정해야 조회 속도가 올라갈까?

산출물

- 실제 테이블 생성을 위한 SQL

시공계획서 같은거임. 어떤 철근을 쓸건지, 어떤 공법을 쓸건지 등등...

### 개념 모델

- 비즈니스적 관점에서 봐야함.
- 요구사항 이해 -> 핵심 데이터가 무엇인지 정의하는 것. 관련된 인력들 간 소통이 핵심.

대상(엔티티), 대상의 특징(속성), 대상간의 관계(Relationship)

### 논리 모델

어떻게 구조를 잡을 것인가?

정규화를 여기서 진행한다는 점.

참고로 Relation이란 테이블 간의 관계가 아니라 테이블 자체를 의미한다는 점.

### 물리 모델

어떤 자재로 어떻게 시공할 것인가?
