# 패키지 매니저 - 2

패키지 매니저가 무엇인지, 그리고 왜 필요한지 알아보았음.

이번에는 패키지 매니저가 동작하는 단계를 살펴보자.

## 패키지 매니저가 동작하는 세 단계

Resolution - Fetch - Link 세 단계로 동작한다.

**Resolution 단계**

`package.json`파일에 명시된 버전 범위를 기반으로 설치할 정확한 패키지 버전을 결정한다. 한 가지 버전이 명시되어 있는 것이 아니라 `^`문자를 사용된 경우 패키지 매니저는 범위 내의 가장 최신버전을 사용하려고 함.

그리고 설치한 패키지가 사용하는 다른 패키지가 존재하는지 확인한다. 그리고 sub-package의 버전도 똑같이 고정하는 작업이 처리됨.

`package.json`에 명시된 버전을 기준으로 해당 패키지와 그 패키지가 의존하는 다른 패키지들의 버전을 각각 하나의 버전으로 고정하고, 결과물을 `package-lock.json` 파일에 저장한다. 이를 통해서 모든 기기에서 고정된 버전을 사용할 수 있어서 버전 차이에 따른 동작의 차이로 인한 문제를 줄일 수 있음.

**Fetch 단계**

Resolution단계에서 lock 파일에 명시된 버전의 패키지를 다운받는 과정으로, 거의 대부분 [npm registry](https://www.npmjs.com/)에서 가져온다.

**Link 단계**

Resolve된 버전으로 Fetch된 패키지를 소스코드에서 사용될 수 있도록 처리하는 과정.

[1] npm Linker

`package.json`파일에서 명시된 모든 의존성을 그냥 `node_modules` 디렉토리 밑에 하나씩 쓰는게 npm Linker의 역할.

이런 방식은 단점이 좀 있음.

- 패키지를 찾으려면 node_modules를 계속 타고 가면서 파일을 여러번 봐야하기 때문에, import나 require의 속도가 느려진다.
- 파일 시스템에 디렉토리와 파일을 하나하나 만들고 쓰기 때문에 디렉토리 크기가 너무 커진다.

[2] pnpm Linker

퍼포먼스가 향상된 버전의 npm이라고 볼 수 있음. npm에서 `node_modules`에 하나씩 쓰는 것으로 인해 느리고 용량이 커지는 문제를 어떻게 해결했을까??

`node_modules`디렉토리는 그대로 사용하되, Hard link방식을 사용해서 디스크 사용 효율을 개선함. Hard link 방식은 간단하게 표현하면 alias를 거는 것이다. npm처럼 매번 복붙하는게 아니라 alias에 바로 접근하는 방식을 사용해서 디스크에는 필요한 의존성이 하나만 설치된다.

그로 인해서 `node_modules` 디렉토리 크기가 훨씬 작다.

하지만 여전히 `node_modules`에 파일을 쓰는 형태는 동일하기 때문에 require나 import 시 파일 읽기가 많이 발생해서 중간중간 멈추기도 한다.

[3] PnP Linker

`node_modules` 없이 의존성을 처리하는 방법.

PnP는 패키지를 불러올 때,

- 어떤 파일에서 import하는지
- 무엇을 import하는지

2가지에만 집중한다. 이 문제를 해결할 수 있다면 굳이 `node_modules`를 순회하는 과정이 필요없다는 접근 방법임.

그래서 이를 **JavaScript 객체**로 처리한다.

JavaScript map을 메모리에 올려서 이를 활용해서 import를 처리한다고 함(이 부분이 잘 이해가 되지 않아서 더 공부해야 함.)
