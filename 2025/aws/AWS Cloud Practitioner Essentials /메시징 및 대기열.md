# 메시징과 대기열

스타벅스에서 카운터에서 계산원이 주문 받아서 바리스타에 전달하고 바리스타가 커피 만드는 구조에서

계산원이 주문 전달하려고 하는데 바리스타가 unavailable 하다면..?

계산원이 주문을 버릴수는 없으니 바리스타 올때까지 다른거 못하고 기다려야겠지..

물론 일정 시간이 지나면 주문 버리고 다시 자기 일 하러가도 되겠지만...

이 구조는 큰 결함이 있음.

서로 손발이 맞지 않는 순간들이 생기면 점차 프로세스가 저하되어서 주문 받는 속도가 느려지고 주문 완료가 실패하는 케이스가 생김

# 이런 문제를 해결하기 위해서 버퍼 개념 도입

계산원은 자기 페이스대로 주문 받아서 어디에 저장하고, 바리스타도 자기 페이스대로 주문목록을 보고 커피 만드는 식으로 계산원과 바리스타 사이의 작업속도나 상황이 맞지 않는 상황을 어느정도 해소시켜줄 수 있는 완충 장치가 있다면 문제를 해결할 수 있다.

이런 버퍼와 같은 완충기억장치에 배치하는 개념을 `메시징` 혹은 `대기열`이라고 한다.

# 밀결합된 아키텍처와 소결합된 아키텍처

밀결합된 아키텍처 - 계산원이 바리스타에게 주문서를 전달하는 것은 App A가 App B에 메세지를 직접 전달하는 것과 비슷한 형태.

이 구조의 특징은, 장애가 전파된다는 것. 구성요소가 하나 고장나거나 변경되면 다른 구성요소, 더 나아가서는 시스템 전체에 영향을 준다는 것.

더 안정적인 아키텍처는 소결합된 아키텍처

왜? 장애가 해당 구성요소 안에 격리되기 때문에 전체 시스템 장애로 확장되지 않음.

계산원과 바리스타 사이에 버퍼가 있음. App A와 App B 사이에 메세지 대기열이 있고, App A는 App B로 바로 전송하는게 아니라 메세지 대기열로 메세지를 전송한다.

이 구조에서는 App B에 일시적인 장애가 발생해도 App A는 장애가 발생하지 않아 왜? 메세지 대기열에 보내면 되니까. 그 사이에 App B가 다시 복구되어서 메세지 대기열에 저장된 메세지를 처리하면 장애가 App B안에서 contain된 상태에서 최소 피해로 서비스를 제공할 수 있음.

# 이를 도와주는 AWS 서비스 2가지

- AWS SQS(Simple Queue Service)
- AWS SNS(Simple Notification Service)

## AWS SQS

SQS를 사용하면, 규모에 관계없이 소프트웨어 구성요소간 메세지를 전송/저장/수신할 수 있음.

커피 주문에 해당되는게 메세지, 저장된 주문 목록이 SQS에 해당됨.

Payload라고 불리는 메세지에 저장된 데이터는 안전하게 보관되며, SQS는 자동으로 규모조정이 이뤄져서 안정적임

## AWS SNS

메세지를 서비스에 전달하지만, 알림을 최종 사용자에게도 전송할 수 있음.

게시 구독(Pub Sub)..? 무슨 뜻인지 잘 모르겠다.

메세지를 전달할 채널인 SNS 주제를 만들고, 주제를 구독할 대상자를 지정한다음, 구독자에게 최종적으로 메세지를 게시함.

주제에 전달하면 한 번에 모든 구독자에 메세지가 전달됨.

SQS 대기열, 람다, https, webhook 과 같은 것들이 다 구독자가 될 수있고, 모바일 푸시나 이메일도 전달하는게 가능하다.
