# 실전 요구 사항 분석

이론은 배웠지만, 보통 실전은 이론처럼 흘러가지 않는다.

다음과 같은 어려움들을 겪게 될 것...

**폭풍처럼 쏟아지는 요구사항**

이런 상황을 마주하게 되면 보통 개발자는 2가지 선택의 기로에 놓임.

1. 기술만 생각하는 개발자의 접근법

주어진 모든 요구 사항을 그대로 받아들여서 개발 일정 산정하기 시작함 -> 엄청 복잡해서 6개월 정도 걸린다고 일정 산정하니까, 사업팀이 난리가 남(3개월 안에 서비스 런칭하려는 계획을 가지고 있었음...ㅋ) -> 시작부터 삐걱..

2. 전체를 보는 개발자의 접근법

훌륭한 개발자는 무턱대고 주어진 기능을 '어떻게' 구현할지에 집중하지 않음.

`이보단, 먼저 이 기능을 '왜' 만들어야 하는지 질문해야 한다.`

다음과 같은 질문을 해보는 것

- 우리 사업의 성공을 위해, 이 모든 기능이 정말 지금 당장 필요한가?
- 지금 시점에 가장 중요한 것은 무엇이고, 덜 중요한 것은 무엇일까?

본질적인 목표인 비즈니스 성공에 집중하는 것. 기술 구현에 매몰되지 않는 것.

이를 위해서는 기획자와 논의하는 과정이 필요함.

논의를 통해서,

- 지금 당장 서비스 런칭을 위해서 필수적인 사항
- 런칭 이후에 다시 준비해서 나머지 기능을 추가

이런 식으로 접근하면, 비즈니스적인 니즈를 제한적인 리소스 안에서 충족시킬 수 있는 방향성을 찾아나갈 수 있음.

이런 노하우와 지혜?가 필요하다

# 실전 개념적 모델링 - 시작

## 1단계: 핵심 요구 사항 다시 정의하기(MVP)

1차 오픈 스팩을 정의하는 것에서 다시 시작하는 거임.

다음과 같이 MVP 기능 명세서를 뽑아내는거지(action plan)

- 회원: 고객이 가입하고 자신의 정보를 관리할 수 있어야 한다.
- 상품: 우리가 판매할 상품을 등록하고 관리할 수 있어야 한다.
- 주문: 회원이 상품을 구매할 수 있어야 한다.
- 결제: 주문에 대한 결제 정보를 기록하고 관리할 수 있어야 한다.
- 배송: '결제가 완료된' 주문의 배송 상태를 관리할 수 있어야 한다.

이렇게 쪼개서 접근하는 이유는, 너무 큰 단위로 기능을 개발해서 출시했을 때의 리스크를 줄이기 위해서라고 함.

너무 많은 걸 한꺼번에 개발해서 출시하면,

- 테스트도 해야되고
- 문제생길 지점이 많음.

## 2단계: 핵심 엔티티 도출

단순해진 요구사항에서 데이터 뼈대가 되는 엔티티 도출하는 단계

- 회원: 서비스를 사용하는 고객
- 상품: 판매의 대상이 되는 물건
- 주문: 회원의 구매 활동 결과
- 결제: 주문에 대한 지불 정보
- 배송: 주문된 상품의 물리적 이동에 대한 정보

## 3단계: 속성 정의 및 관계 설정

이제 각 엔티티의 세부 정보(속성)을 정의하고, 엔티티 간의 관계를 설정함

- 회원: 회원id, 로그인id, 비밀번호, 회원명, 이메일 주소
- 상품: 상품id, 상품명, 가격, 재고 수량
- 주문: 주문id, 주문 상태, 배송지 주소, 주문 일시
- 결제: 결제id, 결제 수단, 결제 금액, 결제 상태, 결제 일시
- 배송: 배송id, 배송 상태, 운송장 번호

참고로,

회원을 보면 식별자가 회원id임(auto incrememt 해서 할당되는 값). 로그인id/이메일도 중복되지 않는 값이기 때문에 사용해도 될텐데 왜 별도로 id값을 만들어서 식별자로 사용할까?

이런 식별자 선택 전략은 DB설계에서 가장 중요한 부분 중 하나로, 논리적 모델링 단계에서 설명 더 해준다고 함.

관계

- 회원과 주문의 관계: 1:N
- 주문과 결제의 관계: 1:1
- 주문과 배송의 관계: 1:1 (쿠팡 같은 경우 보면 1:N으로 하나의 주문에 대해서 여러 배송으로 나눠서 처리되는 경우도 있던데
- 주문과 상품: M:N

## 4단계: M:N관계의 해소와 '연관 엔티티'

주문과 상품은 M:N의 관계가 있어서 해소가 필요함.

다대다 관계가 가지는 문제점

- M:N 관계는 물리적으로 구현할 수 없음.
- 관계에 속한 데이터를 저장할 장소가 없음.

문제 해결을 위해서 `연관 엔티티` 도입이 필요함.

그리고 반드시 다음 질문을 해야함

- 두 엔티티의 관계 속에서만 의미를 가지는 속성이 있는가?

어떤 상품을 주문하는 시나리오를 생각해보자.

보통 특정 상품을 n개를 1개당 x원에 구매한다.

그러면 이 n(주문수량)과 x(개당 주문가격)은 어디에 속하는 데이터일까?

둘 다 주문/상품 어디에도 속할 수 없다 왜냐하면 이 `주문`이라는 행위가 발생한 것에 따라서 생성되는 데이터이기 때문에, 어떤 하나의 엔티티 고유 속성이 아님(주문가격도 변동 가능성이 있기 때문에 해당 시점에 대한 도장 느낌으로 데이터 저장 필요)

그래서 `주문 항목`이라는 연관 엔티티 도입 -> M:N 관계 문제 해소

- 주문과 주문 항목의 관계(1:N) -> 하나의 주문에 여러 주문항목 포함 가능, 주문 항목은 오로지 하나의 주문에만 속할 수 있음.
- 상품과 주문 항목의 관계(1:N) -> 하나의 주문 항목에 상품은 하나만 매칭, but 상품 하나는 여러 주문항목과 매칭 가능.

이러면, 주문 - 주문항목 - 상품의 관계가, 1 : N : 1 이렇게 해소된다.

# ERD 작성

draw.io를 사용해서 작성

ERD에 비즈니스 로직을 다 나타내주는 것이 핵심임

주문에는 최소 하나의 상품이 있어야 한다.

주문과 결제는 서로 1:1 관계이며 필수적인 관계이다.(주문이 있으면 매칭되는 결제가 있어야하고, 마찬가지로 결제가 있으면 매칭되는 주문이 있어야 함)

서로 몇대 몇의 관계인지, 필수적인지 선택적인지 등을 같이 파악하는게 필요함.

**여기서 중요한 포인트**

개념적 모델링의 목표는 모든 것을 다 포함시켜서 나타내는 것이 아니라는 점이 중요함.

그러면 목표가 뭔데?
-> 기획, 개발 등 모든 이해관계자들의 이해를 돕는 것이 목적임. 공통으로 이해하는 비즈니스 설계도라고 해야될려나?

그렇기 때문에 ERD에 모든 정보를 우겨넣을게 아니라, 중요한 정보 위주로만 표시하는 것이 필요함.

예를 들어서, 등록일과 같이 거의 모든 엔티티에 기본으로 포함되는 속성은 굳이 표기하지 않아도 됨 왜? 상호 이해에 더 도움이 되거나 하는건 아니기 때문에. (이런건 문서에 남겨야하는 영역임. -> 내가 작성하는 문서의 목적이 무엇인지 명확하게 인지하고 있는게 도움이 되는구나. 모든걸 기입해야되는 문서인지, 아니면 중요한 것만 입력하면 되는 문서인지에 대해서 이해가 필요)

# 추가 - 개념적 모델링에서 외래 키를 생략한 이유

FK가 생략되어 있음.

주문 테이블에는 누가 주문했는지 알아야 하므로, 회원id값이 FK로 포함될거임.

근데 개념적 모델링에서는 FK를 표기하지 않는것이 원칙이다(실무에서는 표시하는 경우도 있음)

그러면 어떤 윈칙 때문인지?

**특정 기술과 독립적으로 설계되어야 한다**라는 원칙 때문임.

개념적 모델은 RDBMS, NoSQL등 특정 기술과 관계없이 큰 그림에서 `데이터의 구조와 관계`를 이해하기 위한 설계도임. 즉 특정 기술을 염두에 두고 작성하는 것이 아니다.(그렇다는건, 실무에서 표시하는 경우도 있다는 것은 실무에서는 RDB를 사용할 것을 미리 전제하고 개념적 모델링을 진행한다는 뜻이겠지?)

외래키 -> RDBMS의 전용 기술임.

그래서 개념적 모델링의 산출물인 ERD에서는 FK를 보통 표시하지 않고, 대신 관계를 선으로 표시함.

하지만 실무에서는 보통

- RDB를 쓸거라고 가정하는 경우가 많고
- 어차피 나중에 FK 추가할거니까 미리 설계시 고려하는 경우가 많음.

사실 미리 포함하는 경우가 훨씬 많거니와, 개념적 모델링과 논리적 모델링을 같이 진행하는 경우도 많음.

# 가장 중요한 포인트

DB설계는 단순히 기술적인 작업이 아니라는 점.

비즈니스 목표를 이해하고, 현실적인 제약 조건(시간, 인력)을 파악하며, 이해관계자들과 소통하고, 논리적 허점을 찾아 보완하는 전략적인 과정임.

복잡한 문제일수록 작게 나눠서 핵심적인 것부터 해결하는 것이 성공하는 프로젝트의 비결임.

# 용어 사전 작성

개념적 모델을 기반으로,

개발에서 사용할 용어를 명확하게 정의하는 용어 사전을 작성함

이를 기반으로 모든 팀원(기획자, 개발자 등)이 같은 언어로 소통하기 위해서 매우 중요한 과정
