# 논리적 모델링 - 관계

개념적 모델링에서는 외래키가 없었음.(아직 어떤 기술적인 제약을 두고 정의하는 단계가 아니었기 때문에, 관계를 그냥 선으로 표시)

이 관계선이 논리적 모델링에서는 외래 키 라는 구체적인 형태로 구현됨.

이번 세션의 목적

- 다양한 관계의 이해
- 현대적인 설계에서 특정 방식의 관계 설정을 선호하는 이유 이해

## 관계형 DB와 관계의 방향

RDB에서 관계라는 개념은 방향이 없음.(중요한 포인트임)

객체지향 개발자들은 방향이 있다고 생각하기 쉬움.

Team과 Member라는 개념이 있고, Member가 Team에 속할 수 있는 관계를 보자.

그러면 Member는 보통 어떤 팀에 속했는지 알고 있지 않음.(데이터에 저장하지 않음)

Team만 속해있는 Member 목록을 가지고 있음. 즉 관계가 단방향이 됨(Team -> Member만 성립, Member에서 Team을 유추하는 것은 불가)

만약에 양방향 관계를 성립시키고 싶다면? -> Member에도 속한 Team에 대한 정보를 담아야 함. 즉 서로 각각 couterpart에 대한 정보가 있어야지만 양방향 관계를 만들수가 있음.

근데 재밌는 건, 관계형 DB에서는 외래 키 하나의 단일 값(외래 키는 자식 테이블에 존재하는 부모 테이블의 컬럼값임.)으로 양방향 관계(서로를 알 수 있음)을 구축할 수 있음.

왜? PK -> FK, FK -> PK 양방향 조인이 되기 때문임.

- 개발팀에 속한 모든 Member를 찾아라 -> Member table에서 개발팀 PK 값인 team_id값을 가지는 값들을 조인해서 찾으면 됨(PK -> FK로 데이터 식별)
- Member A가 속한 팀을 찾아라 -> Member A의 외래키 team_id 값을 기준으로 Team 테이블과 조인(FK -> PK 로 데이터 식별)

여기서 중요한 포인트는, FK를 어떤 테이블에 둘 것인가(이게 수 많은 설계 정책에 영향을 주기 때문에 적절한 위치를 고르는게 매우매우 중요함)

## 관계의 2대 핵심 요소: 카디널리티와 참여도

이 2가지를 어떻게 조합하느냐에 따라서 관계의 성격이 결정됨.

- 카디널리티: 한 테이블의 행이 다른 테이블의 행과 몇 개나 연결될 수 있는지?(1:1, 1:N, N:1, M:N)
- 참여도: 한 테이블의 행이 관계를 맺고 있는 다른 테이블에 반드시 대응되는 행을 가져야 하는지(필수 참여), 아니어도 되는지(선택 참여)

# 참여도

엔티티가 관계에 꼭 참여해야되는지 여부

- 필수적 관계: 모든 회원은 반드시 어떤 팀에 속해야 한다
- 선택적 관계: 회원은 팀에 소속될 수도 있고 아닐수도 있다.

## 외래 키와 참여도 구현

- 회원의 외래 키 team_id를 NULL 제약조건을 걸고 안걸고 이용해서 필수적/선택적 참여 관계를 만들 수 있음.

근데 팀이 반드시 하나의 회원을 가져야 한다. -> 이거는 어떻게 구현해??(선택적 참여는 그냥 자연스럽게 구현됨. 필요한 팀을 생성하면 돼. 근데 필수적 참여라면??)

결론부터 보면...외래키가지고는 이걸 강제할 수 없다..(엥) -> 왜? 제약을 걸어야 하는 대상(member_id같은 값)이 team table에 존재하지 않기 때문임. team -> member의 관계는 강제할 수가 없게 되는거지.

그러면 어떻게 해????? 이거는 **애플리케이션 계층에서 로직으로 해결**한다고 함.

예를 들어서, 팀 생성 로직에는 반드시 하나의 트랜잭션 안에 해당 팀에 속하는 멤버를 최소 하나 같이 삽입하도록 구성한다던지 해서...

DB로도 할 수 있는데, 현실적으로는 앱단에서 트랜잭션으로 처리하는게 더 선호된다고 함.

## 중요한 포인트!!! ERD와 비즈니스 규칙의 중요성

DB단에서 적용하는 제약조건이 아니면, ERD에 표시하지 않는다..? NOOOOOOOOOOOOOOOO!!

ERD에는 가능하면 비즈니스 규칙을 잘 표현하면 좋다. (설계도잖아 기억해? 단순히 DB만을 위한게 아니라 메인 목적은 관계자 간 투명하고 확실한 소통임)

ERD -> 일단 비즈니스 규칙을 온전히 표현
DB -> 가능한 범위 내에서 규칙 강제
App -> DB 단에서 강제하지 못한 나머지 비즈니스 규칙을 책임지고 시마이쳐서 데이터 무결성을 완성한다.

## DB 설계는 단순히 테이블과 컬럼을 기계적으로 뽑아내는 작업이 아니라는 점.

기억해야함 DB는 도구라는 것을. (a way to express/implement the BUSINESS LOGIC)

중요한건 BUSINESS LOGIC임. ERD에 표현되어야 하는 것은 RDB에 필요한 관계가 아니라 비즈니스 규칙이며,

ERD에 표현된 비즈니스 규칙은 DB와 App이 나눠서 강제해야만 한다.

# 일대다(1:N), 다대일(N:1) 관계 - 외래 키 위치1

가장 흔하게 보는 케이스임

Team/Member를 예로 보자.

Member는 하나의 Team에만 소속되고, Team은 여러 회원을 가질 수 있는 상호 선택적 관계에서,

- team -> member는, 1:N 관계임.
- member -> team 은 N:1 관계임.

1:N/N:1은 바라보는 방향의 차이임.

그러면 외래키는 어디에..? **항상 다(N)쪽에 위치해야 한다.**

그치그치. 1쪽에 두면, team하나에 대해서, member_id를 외래키로 가지게 하면, member_id 수만큼 동일한 team 값이 생성되는데...그러면 team을 어떻게 식별할거임? 뭐가 team에 대한 정보임. 그리고 중복 문제도 생기고...(동일한 team에 대해서 team_id를 다르게 해야됨....읭..?뭥미)

그러면 또 발칙한 친구들이, member_ids 같은 컬럼 만들어서 다 저장하면 되는거 아님!? 이라고 하겠지..?(그게 나야..)

응 그러면 DB 기본 원칙에 위배된단다...그리고 여러 문제들이 발생하지.

- 제 1 정규형 위반: DB컬럼은, 원자성, 즉 컬럼 하나에 하나의 값만 저장되어야 한다.
- 데이터 검색의 어려움: 특정회원이 속한 팀 찾기가 아주 엿같아짐, 인덱스 활용할 수 없어서 테이블의 모든 데이터를 다 확인하는 풀스캔을 때려야함 -> 성능저하는 덤임...
- 데이터 수정이 복잡함: 1,2 가 있는 상태에서 3을 추가하려면? 1,2 가져와서 -> 3 넣고, -> 1,2,3을 입력..

4. 참조 무결성 제약 불가: member_id는 BIGINT인데, member_ids는 VARCHAR 가 되어버리면, member_id가 존재하는 값인지 체크하는 참조 무결성 보장이 안됨 왜냐하면 외래키 설정이 안되니까...

무튼 안좋으니까. 다 쪽에 둬라! 좋은말로 할때....

## 부모 테이블과 자식 테이블

보통 일대다 관계에서, 1이 부모, 다가 자식 테이블이 됨.

자식 테이블이 외래키를 가지고 있고, 이 외래키를 PK로 가지고있는게 부모테이블임.

부모테이블에 없는 데이터가, 자식 테이블에 입력되는 것을 방지해서 참조 무결성 지켜줌(외래키 제약조건을 활용해서)

# 일대다(1:N), 다대일(N:1) 관계 - 외래 키 위치2

실무적인 관점에서, 그냥 평범하게, make sense하는가의 관점에서 말고 관계형 DB 이론적인 관점에서 한 번 보자.

## 관계형 DB의 법칙과 외래 키의 위치

RDB에서 행은 다음과 같은 법칙을 가진다

1. PK는 반드시 유일하다
2. 외래 키는 단일 행만 참조한다.

외래 키 값 하나는 상대 테이블의 정확히 한 행, 즉 mapping되는 단일 행이 존재함

3. 컬럼은 atomic해야한다.

제 1 정규형 준수하라는 소리

위 3가지 원칙을 기반으로 왜 다 쪽에 외래 키가 반드시 위치해야되는지 증명해보자.

- team에 여러 member를 저장하려면?(컬럼에 값 하나만 가진다고 할 때) -> 불가능하잖아 개발팀에 멤버 두명이면, team 테이블에 개발팀에 해당되는 데이터 2개 생겨야 하는데, id 중복은 불가능이야. (PK는 유일하다는 원칙에 위배됨)
- atomic도 위반하면 안되고...

즉 2가지 원칙이 모순 되면서 이슈 발생

- 하나의 행에 여러 회원 정보를 담아야 함(여러 행에 담으면 안되니까) 근데 여러 정보를 담으면? 원자성 위반.

이걸 둘 다 만족시키면서 구현할 수 있는 방법은 이런 DB 원칙 하에서는 불가능 -> 다로 가 그냥!!

다 쪽에 두는건 선택의 문제가 아니라, 기본 제약을 만족시키는 **유일하고 올바른 방법**임..

-> 이것이 RDB에서 관계를 표현하는 근본적인 원리임.

# 일대다(1:N), 다대일(N:1) 관계 - 조인과 뻥튀기

어떤 테이블을 기준으로 조인하느냐에 따라 결과의 형태가 달라진다는 점 유의

뻥튀기 -> 조인했을 때 기준 테이블보다 행 수가 늘어나는 것.

이걸 이해하는게 적절한 SQL 쿼리 작성에 도움이 됨.(참고로 뻥튀기 부분은 기본편 참고 요망.)

## 다대일 조인 -> 뻥튀기가 안됨.

기준 테이블보다 더 늘어나지 않음

-> 예측 가능하고 안정적인 조인이다.

예를 들어서, member에 team을 조인하면? 최대 member의 수만큼만 row가 출력됨

이런 것도 고려를 해야될 이유가 있었구나...

지금까지 그냥 데이터만 나오면 장땡이지 생각했는데...

## 1:N 조인 -> 뻥튀기 가능성을 고려해야함.

개발팀/디자인팀이 있고,
개발팀 2명, 디자인팀 1명 있을 때,

team -> member를 조인하면?

team과 member 테이블에서 각각 name을 뽑아내기 위해서 team에 member를 조인하면?

team은 원래 행이 2개인데, 조인 결과물은 3개가 되겠지.

어라? 기준 테이블보다 데이터 수가 늘어났네?

근데 뻥튀기 되면 안돼? 아니 필요하면 하는거지.

다만 이런상황에서, GROUP BY나, COUNT같은 집계 함수를 사용할 때 이 뻥튀기를 고려하지 않으면 잘못된 결과를 얻을 수 있으니까 그걸 고려해야된다는 점!
