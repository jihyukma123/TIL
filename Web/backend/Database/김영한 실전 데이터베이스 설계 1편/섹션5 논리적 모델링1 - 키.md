# 다양한 종류의 키

개념적 모델링 -> 복잡한 현실 세계의 비즈니스 요구사항을 누구나 이해하기 쉬운 그림으로 단순화하는 것. 중요한 포인트는 누구나 이해할 수 있어야 한다는 점이다. 이 시점에서는 개발자의 관점이 아니라, 이 프로젝트를 함께 진행하는 모든 이해관계자가 공통으로 이해할 수 있는 설계도를 뽑아내는 것이 주요 목적임.

반면에 논리적 모델링은,

개념적 모델링에서 만든 설계도를 RDBMS 구조에 맞게 변환하는 과정임. (어떤 RDB 기술을 사용할지에 의존적이지 않음 아직은. 그냥 관계형 데이터베이스라는 개념에 맞춰서 구조를 설립하는 단계임). 즉 특정 RDB 기술에 종속되지 않는 순수한 데이터 구조의 설계임.

엔티티 -> 테이블, 속성 -> 컬럼, 기본키/외래키 정의 등...

참고로 이 과정에서 제일 중요하게 다뤄야 하는 것이 `키` 개념임.

키키키!!!!

이번에는 논리적 모델링을 공부해보자. 참고로 물리적 모델링은, 실제로 사용할 RDBMS(MySQL, Postgresql 등)에 맞춰서 최적화해서 구현하는 마지막 단계.

# 왜 키가 중요해?

키 -> 특정 데이터(Row)를 유일하게 식별할 수 있는 장치.

키의 용도

- 데이터 탐색
- 테이블 간 연결의 브릿지
- 데이터 중복/잘못 입력을 방지하는 무결성 제약 조건의 역할 수행

DB설계의 가장 근본적인 주춧돌이며, 데이터의 **신뢰성을 보장하는 핵심 장치**임.

## 키가 무결성 제약 조건의 역할을 수행한다는 것의 의미가 뭘까?

기본키는 Nullable=False이고, 중복이 불가함. 그렇기 떄문에 이미 존재하는 키값으로 insert시도 시 db가 거부한다. 그래서 동일한 키값으로 2개의 데이터가 생길 수 없음.

참조 무결성도 있는데, 이는 외래키가 참조하는 데이터가 실제로 존재하는지 DB가 검증하는거임.

또한 잘못 입력 방지는 이런 시나리오들이 있을 수 있음.

- 다른 테이블에서 참조중인 데이터 삭제 방지

## 무결성이란?

무결성은 무엇이다라는걸 잘 모르겠음. -> 무결 = 결함이 없다. 즉 데이터에 모순, 오류, 불일치가 없는 상태

integrity라고 하는데,

> 데이터가 정확하고, 일관되며, 유효한 상태를 유지하는 것.

데이터가 제대로 되어있냐 이거구나.

주요 종류

- 엔티티 무결성: 기본키는 Null/중복 불가
- 참조 무결성: 외래키는 실제로 존재하는 값만 참조
- 도메인 무결성: 컬럼에 허용된 값만 입력

DB는 제약조건들을 사용해서 무결성을 자동으로 보장해주는 장치임.(파일 시스템과의 차이점) 즉 DB는 무결성을 보장하는 데이터 관리 시스템.

그리고 DB가 무결성을 보장하기 위해서 사용하는 메커니즘 중 하나가 key이기도 해서, 중요한 개념이다.

# 데이터를 구별하는 열쇠임.

## 기본키 - primary key, PK

기본키는 다음 3가지 규칙을 **반드시** 지켜야 한다.

1. not NULL
2. UNIQUE
3. 값이 변하지 않아야 한다(불변성) -> 이론적으로 변경은 가능하지만, 변경하면 이 키 값을 참조하는 모든 외래키와 데이터 무결성에 문제가 생김. **실무에서는 never ever 변경하면 안됨.** 외래키를 같이 업데이트 시켜주지 않는다면?? disaster....

## 후보키 - candidate key

기본키가 될 수 있는 후보 선수들. 이 중에서 하나를 뽑아서 기본키로 설정함

유일성/최소성을 만족해야 한다.

- 유일성: 이를 활용해서 모든 행을 서로 구분가능함 (member_id뿐만 아니라, email에도 UNIQUE를 건다면 기본키가 될 수 있는거임. 이를 활용해서 해당 사용자를 유일하게 식별하는게 가능하니까)
- 최소성: 행을 유일하게 식별하는 데 꼭 필요한 최소한의 컬럼만 포함해야 한다.

## 대체키 - Alternate key

후보키 중에서 기본키로 선택되지 않은 나머지 친구들.

## 외래키 - Foreign Key, FK

**테이블 간의 관계를 연결하는 역할**

주문 테이블에서 어떤 사용자의 주문인지 알기 위해서 회원 테이블의 PK인 member_id를 하나의 컬럼으로 가지고 있으면, 주문 테이블의 member_id 컬럼이 FK임.

외래키 컬럼에 제약조건을 걸어주면, 존재하지 않는 회원이 주문하는것과 같은 데이터 불일치를 원천적으로, 즉 그런 잘못된 데이터가 생성되는 것 자체를 방지할 수 있음.
-> FK를 통해서 member_id값이 회원 테이블을 참조하도록 하면, orders테이블에 row 생성 시, 입력되는 member_id 값이 회원 테이블에 존재하는지 체크됨. 있으면 정상적으로 생성되겠지만 없으면 에러임.

## 최소성이란?

후보키 선정할 때, 유일성은 만족하더라도 불필요한 컬럼을 포함해서 최소성 위배되는 경우 후보키가 될 수 없음.

복합키 -> 여러 컬럼 묶어서 키 구성하는거임.

member_id, email, phone_number로 구성된 회원테이블에서 각 복합키 조합이 최소성 만족하는지 보자.

- {member_id, email} -> 유일성은 만족하지만, member_id만으로도 유일성이 성립하니까 최소성 위배됨 -> 후보키 불가
- {email, phone_number} -> 유일성 만족, email 만으로도 구분 가능하기 때문에 최소성 위배 -> 탈락
- email -> 유일성/최소성 만족 -> 후보키 선정

또 하나의 예시

row/col/앉아있는 학생으로 구성된 강의실 자리 테이블 생각해보자.

하나의 row를 유일하게 식별하려면

{row, col} 이 복합키가 최소성/유일성을 만족할까?

-> row/col 각각 만으로는 유일하게 식별이 안됨. (똑같은 값에 대해서 다른 데이터가 존재함.)

하지만 조합했을 때는 유일한 값이 된다.

# 자연 키 vs 대리 키1 - 자연키

하지만 이렇게 이론적으로 배웠던 키와, 실무에서 실제 키 선정 시 괴리가 존재하는 포인트가 있는데,

처음은 PK를 정할때임. 이론과, 현대 RDB에서 PK를 정할 때 괴리가 있다고 하는데 뭔지 알아보자.

PK를 선택하는 과정에서 우리는 `자연키`와 `대리키` 2가지 옵션을 고려해야된다고 하는데, 이는 단순히 키 정하는 것을 넘어서 시스템 전체의 유언성과 안정성을 결정하는 매우 중요한 설계 결정이라고 한다.

## 자연키란?

주민번호같이 자연스럽게 생성되는 값.

## 자연키의 치명적 약점: `변경` 이라는 시한 폭탄

실무에서 사용할 때, `변경 가능성`이라는 치명적인 약점을 가지고 있음.

현대 데이터베이스 설계의 가장 중요한 원칙 중 하나는,

**기본 키는 영원히 변하지 않아야한다**

기본키는 이 원칙을 지키기가 매우 어렵다.

근데 실무에서는 기본키의 값은 **절대 Never 절대 절대** 변경하면 안된다고 한다.

문제가 생길만한 시나리오를 생각해보자.

회원 테이블에 `email` 컬럼을 제약조건 걸어서 pk로 설정하고, 주문 테이블에서 `email`을 외래키로 참조하고 있는 경우(자연키 email을 pk로 사용)

-> 만약에 고객들이 email 변경하고 싶은 경우가 많아서 이를 반영하려고 하면 어떤 작업이 필요한지? (참고로 이러면 다 꼬이기 시작한다고...)

1. 회원 테이블의 pk를 직접 변경하는 UPDATE 쿼리를 실행해야함.

```sql
-- 실행하는 순간 재앙이 시작될 수 있는 쿼리
UPDATE member_n SET email = 'member1@new.com' WHERE email = 'member1@old.com';
```

기본키 값 변경하는 이 쿼리 실행하면 무슨 일이 벌어질까?
-> 시스템의 신뢰도와 안정성 자체를 파괴할 수 있는 문제들이 발생함.

**문제1: 참조 무결성 제약조건 위반**

UPDATE 쿼리가 일단 실행이 안될거임. 왜냐하면 DB 보호 메커니즘으로 외래키 제약조건이 있기 때문에.

주문 테이블 생성할 때, 외래키 제약조건이 설정되었음. -> 자식 테이블(order)에서 참조하는 부모 테이블(member)의 키 값은 변경할 수 없다.

시도하면 아래와 같은 에러가 발생함(외래키 제약조건 위배)

```
19:54:50	UPDATE member_n SET email = 'member1@new.com' WHERE email = 'member1@old.com'	Error Code: 1451. Cannot delete or update a parent row: a foreign key constraint fails (`my_shop3`.`orders_n`, CONSTRAINT `fk_orders_member_n` FOREIGN KEY (`member_email`) REFERENCES `member_n` (`email`))	0.0028 sec
```

이런 식으로 DB는 데이터의 정합성과 무결성을 지키도록 설계되었음. 만약에 저 쿼리가 실행됐으면? 주문 테이블의 기존 이메일을 FK 값으로 가지는 데이터 행은 고아 데이터가 되었을 것.

**문제2: 연쇄 업데이트와 시스템 부하**

'그러면 FK 제약조건을 잠시 끄고, 연관된 모든 테이블의 데이터 다 타고 들어가서 수정하면 되는거 아님?' 이라고 생각할 수 있음.

근데 해당 회원이 오랜 유저여서, 주문내역/댓글/평점/게시글 등이 엄청 많다면?? 값 하나 수정하기 위헤서 수 많은 레코들을 수정하는 연쇄 업데이트 발생하고, 이는 DB에 부하를 주게 됨.

**문제3: 데이터의 역사성 훼손**

이건 기술적인 문제는 아니고 비즈니스적인 문제로 이해됨. 그래서 더 심각한 문제임.

주문 내역이 분명히 `member1@old.com` 이메일을 사용하던 시점에 생성된 데이터인데, 이를 확인할 방법이 없어짐.

고객이 이메일 변경 전에 생성된 건인지 알고 싶다고 하면? 알아낼 방법이 없어진다....

**문제4: 외부 시스템과의 연동 문제**

현대 서비스는 혼자 동작하기 보다는 다른 여러 시스템과 연동해서 동작함.

주문같은 경우 배송 시스템, 마케팅 솔루션, 데이터 분석 플랫폼 등 해당 유저를 식별할 수 있는 email값을 활용해서 수많은 시스템과 연결되어 있을 수 있는데, 연결점인 email 값을 변경하면 이거 어떻게 되는거임?

다 바꿔주지 않는다면 연결이 틀어지고, 다 바꿔주려면 엄청난 리소스가 소요됨...(이런 동기화 로직을 개발하는건 되게 까다롭고 번거로운 일이라고 함.)

---

이처럼 엄청난 잠재적 문제들이 존재함. 그러면 이런 문제는 어떻게 방지할 수 있을까??

## 절대 변하지 않으리라는 착각.

그러면 아예 변경 가능성이 없는 값을 사용하면 되지 않을까? -> 사실상 변경 가능성이 제로인 값은 존재하지 않는다.

- 로그인 id -> 만약에 부적절한 값을 입력한걸 나중에 발견해서 변경하려고 한다고 생각해보자. (예를 들어서, 병신1 같은 욕설이 있는..) 그러면 변경해야되잖아.
- 주민등록번호 -> 정말 드문 케이스이지만 변경이 절대 안된다는 보장이 없음. 만약에 이 사람이 이민가면..?

자연키가 가지는 변경 가능성이라는 태생적 특성 때문에 자연키를 기본키로 사용하면 이런 문제에서 자유로울 수 없음.

그러면 어떻게 해야돼?? -> `대리키`를 사용해보자.

# 자연키 vs 대리 키2 - 대리 키(surrogate key)

대리키 혹은 인조키라고 하며, 자연키가 가지는 변경 가능성이라는 취약점을 보완하기 위해서 탄생한 개념임.

컨셉: 비즈니스 로직과 무관한, 오직 데이터를 식별하기 위해서만 사용되는 임의의 값을 기본키로 사용하는 것.

## 대리키란?

절대 변하지 않는다는 이유 단 한가지 때문에 존재함.

autoincrement 값이나(1,2,3) UUID를 사용함.

## 대리키는 자연 키의 문제점을 해결하나?

yes. how?

1. 영원히 변하지 않는 키

기본키는 불변해야된다는 DB 원칙에 부합

2. 손쉬운 자연키 변경

이메일, 전화번호 등 자연키값들을 데이터 무결성이나 정합성을 해칠 걱정 없이 편하게 수정할 수 있음.

이메일을 수정해도 연쇄 업데이트도 발생하지 않음.

비즈니스 로직 변경이 데이터 구조에 아무런 영향을 주지 않는, 완벽하게 **느슨하게 결합된(loose coupling)** 이상적인 구조가 완성된 것.

3. 비즈니스 로직의 유연성 확보

이메일은 변경할 수 없다 라는 경직된 로직에서, 이메일은 언제든지 사용자 희망에 따라 변경 가능하다로 유연하게 변경됨

**비즈니스 로직과 식별자를 분리한 것.**

### 느슨한 결합??

TBC

## 자연키의 올바른 사용법: UNIQUE 제약조건

PK를 대리키에게 넘겼을 뿐, 비즈니스적으로 고유해야되는 모든 컬럼에 UNIQUE 제약조건을 설정.

email 대신 member_id라는 대리키를 생성했더라도, 비즈니스적으로 유일해야되는 이메일에 UNIQUE 제약조건을 걸면 다음과 같은 이점이 있음.

- 조회성능 개선: UNIQUE 제약조건을 걸면 해당 컬럼에 자동으로 index가 생성되므로, email을 통한 조회 성능이 보장됨.

근데 이거 당연한 이야기 아닌가? 하는 생각이 들어서 ai한테 물어봤는데

- PK를 대리키로 변경했다고 해서 비즈니스 규칙(이메일 중복 불가)이 사라진 게 아님
- DB 레벨에서 UNIQUE 제약조건으로 이중 안전장치를 마련해야 함
- 애플리케이션 로직만으로는 불충분 (동시성 이슈, 버그 등)

이런 식으로, 필요한 경우에는 PK가 아니어도 unique로 제약조건을 걸어서 적절하게 활용하면 좋다는 소리인듯.

## 현대 데이터베이스 설계의 표준 패턴: PK는 대리키로, 자연키에는 UNIQUE

`관계 안정성`, `데이터 무결성`, `조회 성능` 3가지 모두 만족시키는 사실상의 표준

`역할의 분리`라는 프로그래밍의 원칙이 핵심임.

1. 기본 키는 대리키로 설정함으로써

연결고리 역할에 집중(의미없는 값으로 설정하고, 이 값은 불변이기 때문에 외래키로 참조했을 때 변경으로 인한 불안정성이 없음)

2. 자연키는 UNIQUE 제약조건 활용

데이터가 유니크해야되는 경우, 이를 적용 가능

DB가 제공하는 무결성 보장 기능을 활용할 수 있고, 인덱스 생성되어서 조회 성능 개선

관계의 대리키, 비즈니스 데이터의 고유성은 UNIQUE 제약조건으로.

---

각 키의 장단점을 활용해서 역할 분리를 명확하게 하는게 `현대적인` DB설계의 핵심이다.

# 자연키 vs 대리 키3 - 성능 tradeoff

그러면 자연키는 아예 장점이 없느냐?

모든 일에는 트레이드오프가 존재하는 법.

## 자연키 사용의 장점

성능 관점에서 장점이 존재함.

- 조회의 단순성: 비즈니스 요구사항 상, 자연키로 데이터를 조회하는 경우가 대부분인 경우, email을 주문테이블이 외래키로 가지고 있으면 굳이 회원 테이블에 JOIN을 걸어서 조회하지 않아도 됨 -> 성능 개선. (근데 이게 자연키 사용과 관계가 있어? 그냥 필요하면 별도로 값을 저장하면 되는건데 자연키를 PK로 해야될 필요성은 안되지 않나? 그리고 비즈니스 요구사항은 변경될 가능성이 크지 않나? 생각을 해볼 점이라고 해도 둘 중에 비교를 할만큼이 되어야 하는데 너무 압도적으로 차이나는 선택지 아닌가 싶은데...) 대리키를 쓰는 경우, 부모 테이블에 속하는 데이터에 연결되어 있는 자식 테이블 정보를 부모 테이블의 자연키를 가지고 검색하고 싶은 경우 무조건 조인을 해야된다는 점을 고려.

반면 자연키를 사용했을 때 성능 관점의 단점은..?

- 외래키가 길어진다. -> 1,2,3 같은 autoincrement 숫자나, uuid와 같이 고정된 크기의 문자열과 다르게 VARCHAR(50) 과 같은 긴 문자열이 되는 경우 외래키 참조하는 테이블마다 긴 값을 저장해야해서 성능 저하...
  - 어떤 성능 저하가 온다는거임??
    - 디스크 공간 더 많이 차지
    - 테이블/인덱스 크기가 커지면 메모리에 한 번에 올릴 수 있는 데이터 양 감소
    - 조인 연산 시 비교해야되는 데이터 크기가 커져서 메모리/CPU 사용량 증가. -> 전반적인 DB 성능 저하로 이어짐.
- 인덱스 단편화 및 쓰기 성능 저하.
  - 이메일은 DB 테이블에 저장될 때는 알파벳 순서가 전혀 고려되지 않음. 하지만 index 생성 시 알파벳 순서대로 데이터를 정렬해야되기 때문에 기존 자료구조 내 적절한 위치에 삽입하고 데이터 순서를 재정렬하는데 리소스가 소요됨.
    - 이 과정에서 인덱스 페이지를 나누는 페이지 분할이 자주 발생하는데 페이지 분할이 복잡하고 비용이 큰 작업이라고 함. -> 인덱스 안에 빈 공간이 많이 생기는 단편화가 심해지고 이는 쓰기 성능 저하로 이어짐.

### 페이지 분할

페이지 분할(Page Split)은 데이터베이스에서 데이터가 페이지(물리적 저장 단위)를 꽉 채워 더 이상 데이터를 담을 수 없을 때, 해당 페이지를 두 개로 나누고 데이터를 재분배하는 작업으로, 주로 B+ 트리 구조의 인덱스에서 발생하며 성능 저하의 주요 원인입니다. 이는 인덱스 성능 저하를 야기하며, 애플리케이션 레벨에서 사용되는 페이지네이션과는 다른 개념으로, 데이터가 삽입될 때 자동으로 발생하는 내부적인 현상입니다

### 단편화

"무작위로 들어오는 긴 문자열 PK는 인덱스 페이지를 수시로 쪼개고(페이지 분할), 이로 인해 생긴 빈 공간(단편화)이 메모리 효율을 망가뜨려 결국 시스템 전체의 쓰기 성능을 갉아먹는다."

## 🚀 자연 키(문자열) PK 사용 시 쓰기 성능 저하 원인

### 1. 인덱스 페이지 분할 (Page Split)

- **원인**: `email`, `login_id` 같은 자연 키는 입력 순서와 무관한 **무작위 값**입니다.
- **현상**: DB는 인덱스의 정렬 상태를 유지해야 하므로, 새로운 데이터를 이미 데이터가 꽉 찬 페이지들 **사이에 강제로 삽입**합니다.
- **결과**: 기존 페이지를 두 개로 쪼개고 데이터를 이동시키는 **'페이지 분할'** 작업이 빈번해지며, 이 과정에서 CPU와 디스크 I/O 리소스가 대량 소비됩니다.

### 2. 인덱스 단편화 (Fragmentation) 심화

- **원인**: 무작위 삽입으로 인해 발생한 페이지 분할은 페이지 내부에 **불필요한 빈 공간**을 남깁니다.
- **현상**: 순차적으로 채워지는 대리 키와 달리, 자연 키는 분할로 생긴 빈 공간이 다시 채워질 확률이 낮아 구멍 뚫린 채 방치됩니다.
- **결과**: 실제 데이터 양보다 인덱스 파일의 물리적 크기가 훨씬 비대해지는 **단편화** 현상이 발생합니다.

### 3. 메모리(Buffer Pool) 효율 저하

- **원인**: 데이터베이스는 성능을 위해 데이터를 페이지 단위로 메모리에 올립니다.
- **현상**: 단편화가 심하면 **'빈 공간이 절반인 페이지'**들까지 메모리를 점유하게 됩니다.
- **결과**: 메모리 효율이 급격히 떨어져, 정작 필요한 데이터를 읽을 때 메모리가 아닌 **느린 디스크에서 직접 읽어오는 상황(Disk I/O 폭증)**이 잦아집니다.

### 4. 인덱스 트리 깊이(Height) 증가

- **원인**: 단편화로 인해 페이지당 데이터 밀도가 낮아지면, 전체 페이지 수가 늘어납니다.
- **현상**: 데이터를 관리하는 B-Tree의 층수(Level)가 높아집니다.
- **결과**: 새로운 데이터를 넣을 적절한 위치를 찾기 위해 거쳐야 하는 노드 수가 많아져, 매 삽입 시마다 **탐색(Traverse) 시간**이 길어집니다.

### 5. 잠금(Lock) 경합 및 대기 시간 증가

- **원인**: 페이지 분할은 단순 저장보다 훨씬 복잡하고 무거운 내부 작업입니다.
- **현상**: 분할이 일어나는 동안 해당 페이지와 상위 노드에 **배타적 잠금(Exclusive Lock)**이 걸립니다.
- **결과**: 트래픽이 몰릴 경우, 페이지 분할 작업이 완료될 때까지 다른 `INSERT` 요청들이 줄을 서서 대기하게 되어 **전체적인 처리량(Throughput)이 급감**합니다.

---

**💡 핵심 요약**
자연 키 사용은 **'무작위 삽입' → '페이지 분할' → '단편화' → '디스크 I/O 증가'**로 이어지는 성능 악순환의 주범입니다. 데이터가 늘어날수록 시스템 전체의 쓰기 처리량이 기하급수적으로 떨어집니다.

## 대리 키 사용 시 장단점

장점

- 쓰기 성능이 뛰어남: AUTO_INCREMENT 하거나, SEQUENCE를 사용하면 중간에 삽입할 일이 없음.
  - 자연키가 인덱스 재정렬로 인해서 단편화/쓰기 성능 저하 등 이슈가 있었던 것과 다르게 대리키는 인덱스 생성 시에도 마지막에 데이터 하나 추가하는 정도만 하면 됨.
- 외래키 축소 -> 작은 값이라서 디스크 공간 절약하고 메모리 효율이 높아짐.

단점

- 추가 JOIN 가능성. 하지만 대부분의 경우, JOIN으로 인해서 발생하는 성능 저하보다 대리키가 제공하는 이점(유연성, 쓰기 성능, 데이터 크기)이 훨씬 크다고 함.
- 추가 인덱스 필요: email 컬럼이 여전히 로그인/회원 검색 등 기능이 수행되어야 하는데, 이 컬럼의 조회 성능을 보장하고 중복 방지하려고 UNIQUE 인덱스 생성이 강제됨. (RDB에서 특정 컬럼에 `UNIQUE` 제약조건 걸면 DB가 중복체크/성능보장을 위해서 내부적으로 자동으로 인덱스를 생성함 -> 저장 공간이 추가로 필요하고, 데이터 삽입될 때마다 별도의 기준으로 관리되어야 하는 인덱스가 늘어남. 즉 쓰기 성능 저하가 있다는 점.)

# 자연키 vs 대리 키 - 현대적인 설계

거의 대부분의 상황에서 **대리 키 사용이 강력하게 권장됨**

자연키는 비즈니스 로직과 데이터의 신원, 즉 데이터를 식별할 수 있는 값을 강하게 결합시킴.

그래서 비즈니스 로직이 변경되면, 데이터의 신원이 변경되어야 하는데 마치 주민등록번호 바꾸면 내 모든 인증 관련된 것들을 업데이트해야되는 것과 비슷한 느낌이지 않을까.

반대로 내 신원 정보를 별도로 그 용도, 즉 해당 데이터를 유일하게 구분짓기 위한 용도로만 사용하면 변경해도 기타 정보에 영향을 주지 않음.

여기서 이해하면 좋은 점은, 그러면 왜 대리키를 자연키보다 선호하는 방식으로 진화했는지?

## 과거: 데이터 중심의 시대와 자연 키

과거에는 데이터 그 자체의 독립성을 더 중시했음.

DB가 전체 시스템의 중심이 되고, 이 중심 DB에 여러 앱들이 연결해서 데이터를 사용하는 경우가 많았음.

즉 DB 위주의 사고를 했다는거고, 현실 세계의 데이터를 가장 논리적이고 자연스럽게 표현하는 것이 중요한 원칙이었음.

- 직관적이고, 과거에는 디스크 비용이 더 비싸서 별도의 ID 컬럼 추가 안해도 되어서 그런것도 있고...

그리고 과거에는 비즈니스 로직 변경 속도가 지금에 비해서 느렸음.

그래서 자연키 불변성이 좀 더 지켜지는 편이었음.

하지만 현대로 오면서 이런 점들이 바뀐거지.

## 현대: 애플리케이션 중심의 시대와 대리 키

애플리케이션이 많이 늘어나고, 복잡성이 증가함 -> DB보다 애플리케이션으로 중심이 이동함.

DB는 필요한 데이터를 잘 보관하고 관리하는 용도로 사용되고, 핵심 비즈니스 로직은 다 앱 내부로 이동함.

1. 요구사항 변화속도 엄청 빨라짐

스타트업과 애자일 개발 방식이 대세가 되면서, 비즈니스 로직이 언제든 바뀔 수 있게 되었음.

많이 바뀌어야 되는데 매번 DB를 자연키 사용으로 인해서 업데이트 하는건 빨리 움직이는데 방해요인임

과거에는 뭐가 많이 안바뀌었는데 요즘은 경쟁도 많고 빨리 바뀜

2. ORM 기술의 등장과 패러다임 전환

ORM -> 개발자가 직접 SQL 쓰지 않고 객체를 활용해서 DB 작업을 할 수 있게 해주는 기술.

백엔드 개발자는 보통 객체 지향으로 앱을 개발하는데, Spring Boot로 만든 객체가 다루는 데이터를 결국 DB에 저장은 해야될거 아니야. 그러면 구조에 맞춰서 SQL도 써야됨. 근데 객체를 만드는 언어와, SQL은 다르잖아. 그래서 왔다갔다 서로 조금씩 다른 애들을 맞춰서 작업하는데 cognitive load가 소요됨.

ORM이 나오기 전에는 개발자가 SQL을 다 직접 작성했어야 함.

JPA가 ORM임.

객체를 ORM에 넘겨주면 이제 ORM이 알아서 최적의 SQL 만들어서 DB와 통신함.

개발자가 개별 SQL을 매번 작성하지 않아도 되니까, 개발 생산성이 비약적으로 증가함.

ORM -> PK로 변화 추적 및 관리를 하는데, ORM이 원활하게 동작하려면, `절대 변하지 않는 고유 식별자`가 반드시 필요함.

다른 값이 변경되어도, 식별자를 가지고 어떤 데이터에 변경사항을 반영해야되는지 알 수 있음. (자연키를 쓰면, 자연키가 변경되면 ORM이 추적 대상 판별이 안됨. 아니 어디갔지 싶은거지.)

ORM이 개발자가 신경쓰지 않아도 알아서 내부적으로 객체의 변경을 그대로 데이터의 변경으로 반영할 수 있는 핵심 원리가 바로 `대리 키`임.

ORM은 백엔드 개발자가 SQL 작성이라는 번거로운 작업에서 벗어나게 해주는데, 이 ORM이 의도대로, 잘 동작하기 위해서는 대리 키의 존재가 필수임.

3. 분산 시스템과 MSA

MSA에서 각각 시스템이 별도의 DB를 가질 수 있음.

근데 email 같은 자연키를 여러 서비스에서 일관되게 사용/관리하는 것은 매우 좋지 않아.

하나의 서비스의 비즈니스 로직 변경에 전체 다른 여러 서비스들에게도 영향을 주기 때문임.

하나의 DB의 컬럼값 하나면 변경하면 될일을, 여러 서비스의 DB를 연쇄적으로 업데이트 해야된다면 리소스 낭비가 너무 심하다.

하지만 `절대 변하지 않는, 오로지 서로 연결시켜주기 위한 용도로 만들어진 식별자`인 대리키를 토대로 시스템끼리 결합하면, 각 시스템의 로직 변경이 다른 시스템에 영향을 줄 가능성이 현저히 떨어짐.

## 결론: 현대적 설계의 핵심은 `느슨한 결합`

현대 -> 비즈니스 변화의 유연성과 시스템의 안정성이 최우선 가치.

빠르게 자주 변화 가능하면서도, fail safe 해야한다.

이것만 기억하자

> 대리키-PK, 자연 키-UNIQUE

# 복합 키 설계

하나의 컬럼만으로는 행을 고유하게 식별하지 못하는 케이스가 존재한다고 함.

이럴 때는 여러 컬럼 조합해서 키로 설정하는 복합키가 사용됨. (Composite Key)

## 복합키는 왜 필요한가? - 식별자의 조합

단일 컬럼만으로는 유일성을 확보할 수 없는 케이스가 존재함.

예를 들어서, 영화 예매 시스템을 보자.

`영화`, `상영 정보`, `예매` 3가지 개념이 명확하게 구분되어야 함.

상영정보 -> 영화/날짜/시간이 특정되어야 함.

그래서 영화제목과, 상영 시간 이 필요함(둘 중 하나라도 없으면 특정이 안됨)

마찬가지로, 예매를 생각해보자.

영화만 있으면 예매 가능? NO -> 상영 시간이 필요함.

영화 + 상영시간만 있으면 예매 가능? NO -> 내가 어디 앉을지 좌석 정보도 필요함.

그래서

- 상영정보: {영화, 상영 시간}
- 예매: {영화, 상영 시간, 좌석 번호}

이렇게 정보를 조합해서 단일 행을 식별해야함.

그리고 이렇게 복합키를 PK로 사용하는 경우, DB가 똑같은 조합이 중복되어 삽입되는 것을 방지해준다고 함.

## 자연 키를 복합키로 사용하는 예시에서 발견되는 문제점.

- 변경 가능성으로 인한 불안정성: 자연키에서 겪었던 문제가 여기서도 그대로 적용됨.
- 외래 키 참조의 복잡성과 크기 증가: 다른 테이블에서 이 복합키를 외래 키로 참조할 때, 복합키에 사용된 컬럼을 2개든 3개든 모두 복제해서 가지고 있어야 함. -> 조인도 복잡해진다. 복합키에 사용된 모든 키를 다 비교해서 일치하는지 체크가 필요해짐.
- 조회와 관리의 어려움: 복합키는 직관적이지 않음. 단일키처럼 단순하게 `WHERE id = 1` 처럼 조회가 안됨 -> 쿼리가 길어지고 오류가 발생. ORM 사용 시에도 복합키 다루려면 별도의 식별자 클래스 만드는 등 개발 복잡도 증가
- 확장성 문제: 상영관이 늘어나서 상영관 번호 같은 값이 키에 추가된다면 기본키가 변경됨 -> 관련된 모든 테이블/쿼리에 영향을 미치는 대작업이 됨.

## 대안 - 대리 키!!!!!! 거의 무적이네 ㅎㅎ

대리키는, 비즈니스와 무관한 값을 사용하고, 간단하게 하나의 컬럼만 사용

어떻게 보면, '모르겠으면 일단 대리키' 전략으로 복잡성은 많이 감소했다고 생각할 수 있음.

영화 예매 시스템도 `reservation_id`라는 PK를 하나 만들면 됨.

그리고 dont forget! 하나의 조합에 대해서는 중복이 되면 안되니까 UNIQUE를 걸어준다는 점.

```sql
-- 예매 테이블 (대리 키 사용)
CREATE TABLE movie_reservation_s (
reservation_id BIGINT NOT NULL AUTO_INCREMENT, -- 대리 키 PK
movie_title VARCHAR(100) NOT NULL,
screening_dt DATETIME NOT NULL,
seat_number VARCHAR(10) NOT NULL,
reserver_name VARCHAR(50) NOT NULL,
PRIMARY KEY (reservation_id),
-- 자연 키 부분에 UNIQUE 제약으로 데이터 무결성 보장
UNIQUE KEY uq_movie_reservation (movie_title, screening_dt, seat_number)
);
```

UNIQUE KEY uq_movie_reservation (movie_title, screening_dt, seat_number) -> `UNIQUE KEY`가 뭐지? 물어봄 제미나이한테.

SQL에서 UNIQUE KEY는 단순한 제약 조건(Constraint)을 넘어 **인덱스(Index)**의 성격을 가짐.

- 식별자로서의 역할: 데이터베이스 엔진은 이 3가지 조합이 유일한지 매번 전수 조사할 수 없습니다. 따라서 이 조합을 빠르게 찾기 위한 '색인(Key)'을 내부적으로 생성합니다.
- 성능과 무결성의 결합: UNIQUE는 "중복을 허용하지 마라"는 규칙이고, KEY는 그 규칙을 빠르게 검사하기 위한 기술적 수단입니다. (대부분의 DB에서 UNIQUE INDEX와 동일하게 취급됩니다.)
- 이름(uq_movie_reservation)은 왜 붙이는지? -> 유지보수 때문임. 이름으로 에러 로그를 검색하거나, 제약조건을 변경/삭제 하는 것이 용이함.

이점

- 불변성
- 단순한 외래 키 참조(reservation_id 하나만 참조하면 됨) -> 참조가 단순해지니까 JOIN도 단순해지고, 일관된 숫자로 처리하니 인덱싱/조인연산 속도 향상 = 성능 향상
- 유연성 및 명확성 -> 비즈니스 로직 변경에 대해서는 유연하게 대처가능하면서도, 유일성도 UNIQUE KEY를 통해서 확보할 수 있음.

## 복합 키 정리

- 기본키는 대리키 사용
- 비즈니스 제약은 UNIQUE로 설정

데이터 무결성과 시스템의 유연성/확장성 확보 가능.

---

# 다대다 관계와 복합키

문제 상황: 다른 테이블의 대리 키(외래 키)들을 조합해서 복합키를 만드는 경우는 어떻게 되는거임?

다대다 관계 해결 시 자주 등장하는 상황이라고 함.

## 문제 상황: 다대다 관계 모델링

주문/상품 간 관계

- 하나의 주문에는 여러 상품 포함 가능.
- 하나의 상품은 여러 주문에 포함될 수 있음.

RDB -> 관계를 외래키로 표현함.

근데 앞서 공부했던 것처럼 다대다 관계는 테이블 2개만 가지고는 표현 불가임.
(연관 엔티티 이용해서 해결했던거 기억하지?)

왜 안되는지?

- 주문 테이블에 product_id를 포함시키면? 단일 주문 row에 대해서 product를 한개만 연결시킬 수 있음. 반대로도 마찬가지.

## 다대다 관계 해소를 위한 연결 테이블

주문항목 같은 테이블 만들어서 다대다 관계를 2개의 1:N 관계로 풀어내야함.

orders(1) - (N) order_item (N) - (1) product

order_item 테이블은 order_id/product_id를 외래키로 받아서 두 테이블의 관계를 맺어줌.

근데 그러면 order_item의 기본키는 뭐가 되어야함???

2가지 선택지가 있어.

- 방법1: {order_id, product_id} 복합키
- 방법2: order_item_id 라는 별도의 대리키 사용하고, {order_id, product_id}를 UNIQUE KEY로 묶기. (근데 하나의 주문에 대해서 특정 프로덕트를 여러 개 주문하는거는? 그거는 주문 수량 같은 컬럼을 따로 추가해서 처리하는 개념이겠지?)

### 방법1: {order_id, product_id} 복합키

이 조합이 가장 자연스러운 식별자(자연키)가 되는거임.

부모의 PK를 자신의 PK+FK로 활용하는 관계를 `식별 관계`라고 한다고 함.

주문, 상품, 주문항목이 있을 때,

주문항복은 자식인데 부모테이블의 PK(order_id, product_id)를 자신의 pk/fk로 활용하고 있음.

## 방법2: order_item_id 라는 별도의 대리키 사용하고, {order_id, product_id}를 UNIQUE KEY로 묶기.

장점

- 유연하고 일관된 참조: 다른 테이블이, 단일 컬럼만 참조하면 됨. JOIN도 마찬가지..
- 데이터 무결성도 유지
- order_item_id 라는 단순키가 있어서 ORM에서 다루기 쉬움(ORM에서 복합키 다루려면 별도 객체 필요하다는 점)

단점

- 약간의 overhead. -> index 별도로 생성되고, 관리되어함.
  -> 하지만 현대의 개발 환경에서는 하드웨어 성능이 비약적으로 상승한 덕분에 큰 문제가 되지 않음. 그래서 하드웨어 관점에서의 제약보다는 비즈니스의 역동성을 살릴 수 있는 쪽으로 더 무게를 두고 선택하는게 요즘에는 더 맞지 않나...

## 근데 방법1도 우리가 논의했던 변경 가능성으로부터는 자유로우니까 충분히 괜찮지 않나!?

맞음. 변화의 둘 다 이미 대리 키이기 때문에 조합도 비즈니스 변화로부터는 안정적이라고 볼 수 있음.

다만 ORM이 사실상 표준인 현대 개발에서는 개발 관점에서 번거로운게 있고,

또 비즈니스적으로도 문제가 될만한 상황이 있을수는 있음.

어떤 경우가 있느냐. -> 예를 들어서 상품을 구분할 때 이전에는 그냥 상품id만 가지고 식별했는데, 옵션이 추가될 수 있음. 키보드를 사는데 검은색 하나, 은색 2개라고 하면 색깔별로 product_id가 다른게 아니라면 옵션에 따라서 pk가 추가되어야 유일하게 식별이 가능해지겠찌? -> 그러면 {order_id, product_id}로 구성했던 PK를 뜯어내야함. 그러면 또 난리가 나는거지...ㅎㅎ

## 실무 기반 데이터베이스 키 선택 전략.

실무에서도 대리 키를 기본키로 쓰고, 복합키로 설정했을만한 컬럼들을 복합 유니크 제약 조건으로 설정하는 방식이 가장 실용적이고 현대적인 해결책임.

# 정리

- 논리적 모델링의 핵심은 `키 정의`

  - 키는 각 행을 유일하게 식별하고, 테이블 간의 관계를 맺으며, 데이터 무결성을 보장하는 핵심 장치

- 기본키/후보키/외래키의 개념 및 각 키의 핵심 역할과 특성 이해 필요
- 자연 키는 변경 가능성이라는 치명적인 약점이 있음. (현대 DB에서는 '기본키는 절대절대절대 변경되면 안된다'라는 원칙이 있는데 이에 위배됨)
- 그래서 대리키를 사용하면 이런 문제를 해결할 수 있음. 별도의 키로 인해서 DB 크기나, 인덱스가 추가로 필요하다는 하드웨어 관점에서 단점이 있지만 장점에 비해서 미미함.
- 대리 키를 사용하면 외래키를 활용해서 부모 테이블의 정보 조회 시 반드시 JOIN을 해야된다는 사소한 단점이 있지만, 외래 키 크기 고정으로 인해 사이즈가 크지 않기 때문에 메모리 낭비가 적고, 순차적으로 값이 증가하니까 쓰기 성능이 뛰어난 측면도 있음.(쓰기 성능에 대해서는 더 이해가 필요함.)
- 대리키는 느슨한 결합이라는 현대적 프로그래밍 best practice 에 부합한다.
- 대리 키를 PK로, 비즈니스 규칙은 자연 키에 UNIQUE 제약 조건 걸어서...이것만 기억하자.

## 키가 왜 데이터 무결성을 보장하는 핵심 장치이지?

데이터 무결성(Data Integrity)은 간단히 말해 데이터가 전체 수명 주기 동안 얼마나 정확하고, 완전하며, 일관되게 유지되는지를 의미합니다.

키 -> 데이터베이스 내에서 데이터의 질서와 주소를 정의하는 규칙임.

- 개체 무결성: PK는 개별 데이터를 식별하는 기능을 제공하고, 중복이나 데이터가 없는 것을 방지함. 데이터가 섞이거나 유실되지 않고, 모든 행이 유일함을 보장받을 수 있음.

- 참조 무결성: 존재하지 않는 대상을 가리키지 않음을 보장.(FK) 테이블 간 관계는 RDB에서 FK로 표시하는데, 부모 테이블에 없는 데이터는 자식 테이블에 당연히 넣을 수 없지만 이것이 보장되도록 해주는게 외래 키임. 자식 테이블이 가지고 있는 FK 값을 가지고 있는 부모 테이블의 데이터가 삭제될 때, 관계를 체크해서 삭제를 방지하거나, 함께 cascade 삭제처리하거나 해서 부모 테이블에는 없는 데이터가 자식 테이블의 행에서 fk로 참조하고 있는 상황을 방지함.(고아 데이터 생성 방지)

기본 키 -> 데이터의 고유성 확보
외래 키 -> 데이터 간 연결고리를 감시해 없는 데이터를 참조하는 등의 모순 방지
