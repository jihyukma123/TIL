# 데이터 독립성

1강의 내용 중에서 `Data independence`, 즉 데이터 독립성이라는 개념이 있는데 정확하게 이해가 되지 않아서 제미나이와 대화를 좀 해봄.

1강의 내용 중에서 이런 내용이 있음.

CODASYL에서 만든 DB개념에서 사용자가 데이터를 get하기 위해서는 절차적으로, how를 명시해서 코드를 작성했어야 함. 물리적 접근 경로를 하드코딩하는거임.-> 이는 사용자가 작성한 코드가 DB의 물리적인 구조와 강결합되어 있다는 측면에서 문제가 있었다.

어떤 문제가 있었다는걸까?? -> **변경에 극도로 취약한 시스템을 만든다는 점**이 가장 큰 문제
(신기하게 최근에 김영한 선생님 강의에서 공부한 내용과 통하는 부분이 있음. PK로 자연키를 사용하면, 변경 가능성에 영향을 많이 받는게 최악의 단점이라서 이를 보완하기 위해 PK로 대리키를 사용하는게 현대 DB 설계의 거의 표준이라는 점. 컨텍스트에 연결되는 내용은, 과거의 DB 중심 시대에서 최근의 application 시대로 넘어오면서 비즈니스 로직이 많이 변경되고, 빠르게 변경사항을 반영하는 것이 목적 달성에 매우 크리티컬함 -> 그래서 현대 DB 설계 시 반드시 고려해야되는 점은 변경 가능성과 확장성임.)

- 강결합 시, DB 물리적 구조가 변경되면 코드가 다 깨짐
- 요구사항 변화에 대응이 거의 불가능(비즈니스 요구사항이 DB로 인한 제약을 같이 적용받음)
- 개발자가 DB 내부 구조를 '너무 많이 알아야' 함.
- 재사용성이 매우 떨어짐(dependency가 많아서 그 specific한 케이스에만 들어맞는 코드가 됨)

이런 IMS/CODASYL 시스템의 한계를 비판하면서 Codd가 관계형 모델을 제시할 때, 데이터 독립성이 핵심 아이디어 중 하나였음.

이런 관점에서 데이터 독립성 개념이 등장했다는 점을 알고 있으면 이해하는데 도움이 되는 듯.

데이터 독립성은 더 나아가서,

사용자/앱과 low-level data representation을 분리. 이런 개념으로 발전한 것 같음.

최종적으로 연결되어야 하는 주체는 2가지임.

`application`과, `DB에 저장된 데이터`

여기서 `application`이 바라보는 데이터의 구조와, 실제 디스크에 저장된 모습을 분리하고 싶은거야.

`what`만 명시하고 `how`를 모르고 데이터를 가져오려면, 결국 프로그램이 보는 추상적인 데이터 구조와 실제 디스크에 저장된 구조를 분리하는게 필요함.

Application
External Schema
---App level
Logical Schema
Physical Schema
Database Storage

이런 구조에서, 몇 가지 독립성으로 분리되는 포인트들이 존재함.

1. Physical Data Independence

Physical Schema와 Logical Schema 간 독립성

내부 스키마가 변경되어도, 개념 스키마에 영향을 주지 않는 성질

- DB 성능 향상을 위해서 인덱스 추가/삭제하거나, 파일 저장 구조를 B-Tree에서 Hash로 변경하거나, HDD에서 SSD로 저장 장치를 교체하는 등 물리적 변경사항이 논리적 구조에 영향을 주지 않도록 함.
- 사용자는 물리적 저장 구조를 몰라도 논리적 쿼리만 알면 데이터 조작 가능

2. Logical Data Independence

Logical Schema와 External Schema 간 독립성

개념 스키마가 변경되어도, 외부 스키마에 영향을 주지 않는 성질

---

이렇게 위계 구조(물리 DB - 물리적 스키마 - 논리적 스키마 - 개념적 스키마) 같은 구조로 애플리케이션과 실제 데이터의 사이 공간을 구성하는 것은 `책임의 분리`라고도 볼 수 있음.

- 물리적 레이어 -> 디스크 어디에, 어떤 정렬로 저장할 것인가? -> DBMS의 책임
- 논리적 레이어 -> 어떤 테이블들이 있고, 서로 어떤 관계인가? -> DB 설계자의 책임
- 외부 레이어 -> 개별 앱은 전체 데이터 중 어떤 데이터를 보고 싶어하는가? -> 앱 개발자의 책임

---

SQL과 ORM이 가능한 근본적인 이유는 DB 설계가 사용자 관점과 물리적 저장 방식을 분리하는 3계층 구조를 채택했고,그 결과 애플리케이션은 “무엇을” 조회할지만 기술하면 “어떻게” 저장되고 조회되는지는 DBMS가 책임지게 되었기 때문이다.

---

- External Schema: 사용자 / 애플리케이션 관점
- Conceptual Schema: DB의 논리적 구조
- Internal Schema: 실제 저장 방식 (파일, 인덱스, 페이지 등)

이 구조 덕분에:

물리 독립성
→ 인덱스, 파일 구조, 저장 방식 바뀌어도
→ SQL / 애플리케이션 코드는 그대로

논리 독립성
→ 테이블 구조 일부 변경돼도
→ 외부 뷰나 앱 영향 최소화
