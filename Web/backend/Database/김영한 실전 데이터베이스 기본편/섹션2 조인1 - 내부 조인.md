# 섹션2. 조인1 - 내부 조인

쇼핑몰을 만들거임

기본적인 비즈니스 규칙들이 있음.

1. 고객 가입: 모든 고객은 고유한 이메일 주소를 가져야 한다. 이름과 이메일은 필수 정보다.
2. 주문 생성: 주문은 반드시 특정 고객(user_id)과 특정 상품(product_id)에 연결되어야 한다.

- 하나의 주문에 한 종류의 상품만 선택할 수 있고, 상품의 수량은 선택 가능

3. 주문 상태 관리: 주문이 생성되면 기본 상태는 'PENDING'이며, 이후 'COMPLETED', 'SHIPPED', 'CANCELLED'로 변경될 수 있다. (펜딩 - 대기, 쉽드 - 배송, 컴플릿 - 완료, 캔슬드 - 취소)

4. 재고관리: 주문이 발생하면 products테이블의 stock_quantity(재고)는 주문 quantity(수량)만큼 차감되어야 한다.

- 이 로직은 DB가 아니라 애플리케이션에서 구현되어야 함.

5. 직원 관리 구조: 직원은 매니저를 가질 수 있으며, 매니저 또한 직원이다. 매니저가 없는 최상위 직원이 존재할 수 있음.

# ERD

## 고객 주문 상품의 관계

- 고객은 여러 개의 주문을 생성할 수 있음.
- 상품은 여러 주문에 포함될 수 있음.
- 하나의 주문은 한 명의 고객과 하나의 상품에 연결됨(비즈니스 규칙에 한 주문에는 한 종류의 상품만 선택 가능하다고 제약걸었음)

## 나머지 관계

- 직원은 다른 직원을 관리하는 계층 구조(SELF JOIN)을 가진다.
  - manager_id를 통해 상사를 알 수 있다.
- 사이즈와 색상 테이블은 상품의 모든 옵션 조합을 생성하기 위해 사용됨

# IF EXISTS/IF NOT EXISTS

테이블을 삭제하는 케이스를 생각해보자.

DROP TABLE A; 라고 하면 -> A가 없으면 오류 발생함.

마찬가지로 생성도 이미 있는데 생성하려고 하면 오류 발생함

그래서 safe하게 if exists/if not exists 로 존재여부를 확인해서 실행하는게 더 fail safe한 방법임.

# INT형의 제약..?

강사님이 products테이블의 id 값인 product_id 컬럼 타입을 INT가 아니라 BIGINT로 설정했는데, 이유를 큰 서비스에서는 간혹 INT형이 담을

INT -> 거의 대부분 환경/언어에서 4byte임. 4byte, 즉 32bit인데, 보통 별다른 말이 없으면 signed값으로 생각한다고 함. 즉 -2^32 ~ 2^32의 범위를 가짐. 근데 id는 보통 양의 정수를 사용하니까, 1~2^32 범위의 숫자를 표현할 수 있음. 약 21억개인데, 정말 큰 서비스 같은 경우는 id값이 상상 이상으로 커지는 경우가 있을 수 있어 INT가지고 표현할 수 없는 숫자가 생길 수도 있다고 함 그래서 BIGINT

# 조인이 필요한 이유

`최근 주문 현황을 고객 이름과 상품명을 포함해서 보고서로 만들어줘` 라는 요청을 처리해보자.

orders -> 주문 테이블이니까 orders테이블을 사용하면 되지 않을까?

근데 orders에서 최근 주문 현황 데이터를 뽑으려니까, 고객 이름이랑 상품명 값을 알수가 없네..?

이름과 상품명이 아니라 orders테이블은 외래 키인 user_id/product_id만 가지고있어 -> 그러면 orders테이블을 기준으로 알아낼 수 있는 방법은??

orders 테이블에서 최근 주문 현황 정보별로, row별로 user_id로 user테이블에서 사용자 식별해서 이름 가져오고, product_id로 product테이블에서 식별해서 가져오고 하면 됨.

사실 여기까지는 직관적으로 이해가 잘 되기도 하고, 이미 실전에서 사용해봤던 부분들이라 다를게 없는데 내가 필요한건,

`왜 JOIN하는 구조로 DB가 설계가 되었는지?` 이 문제를 이해해야됨

JOIN해서 가져오는거 알겠오 오케이. 근데 애초에 왜 JOIN을 하게 만들었어?

그냥 orders테이블에, user_id, product_id같은 키값이 아니라 필요한 값, user_name이랑 product_name 다 때려박아서 만들면 편하잖아?

근데 내가 왜 JOIN을 하는지 이유를 알아서 어디다 써먹는데?
-> 그냥 개발자니까 알아야한다 이런거 말고....이유가 있어야 알아야 할 것 아니야

JOIN -> 말그대로 '연결'임. JOIN이 테이블이 있고 생긴게 아니겠지?

TABLE들이 나뉘어져 있는데, 한 테이블에서 다른 테이블의 정보를 타고 가져오려면 연결해서 가져오는 수밖에 없음.

그러면 왜 그렇게 설계를 했냐? -> 테이블을 분리하지 않으면 데이터 무결성이나, 성능 관점에서 문제가 발생할 소지가 많음. 현실적인 상황에서는 DB table도 많아지고 데이터도 많아지면서 관계도 복잡해지는데, 최대한 관계원칙을 일관되게 유지해야하기도 하고...

그래서 나눴고, 나눴기 때문에 필요한 데이터를 조회하려면 JOIN이 필요하게 된것.

JOIN을 해야되는 이유는, 나눴기 때문이고, 나눈 이유는, 나누지 않으면 데이터 무결성 보장이 매우 어렵기 때문.

DB가 목숨을 걸고 지켜야 하는 것은 데이터 무결성.

JOIN이 필요한 이유를 이해한다는 것은, Data 무결성이 지키는 설계를 이해하는 것과 동일하다.
