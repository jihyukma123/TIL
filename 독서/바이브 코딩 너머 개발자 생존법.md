시스템을 설계하고, 사용자에게 공감하며, 소프트웨어를 현실에 맞게 조정하는 판단 능력을 길러야 그 다음 단계로 나아갈 수 있습니다.

# 책을 읽기에 앞서..

내가 하고 있는 고민들에 대한 실마리를 제공할 책인지 궁금하다.

- AI-assisted coding 으로 인해서 개발자의 '구현 역량'의 가치가 거의 소멸한다고 많이 말하는데, 진짜 맞나? '구현 역량'이 뒷받침 되어야 한다가 더 맞는 표현 아닌가? 구현 역량이 떨어지는 사람이 어떻게 AI가 만들어준 코드가 본인의 의도한 바를, 예상 가능한 범위 내의 변수를 커버하면서 동작하는지 어떻게 알지?
  - 그렇다면 역설적으로, 아직 구현 역량이 일정 수준(정의 필요)에 오르지 못한 사람은, AI를 활용하는 방법을 배우면서도 어떤 코드가 좋은 코드인지, 특정 기능을 구현할 때 무엇을 고려해야되는지 등에 대해서 배워야 하는 것이 아닌지?
- AI 시대에 개발자의 역할이 달라질 뿐이라고 말하는 사람들은, 이제 더 코드 작성 보다는 설계자, 지휘자 같은 역할을 더 많이 수행해야된다고 말하는데... 아키텍처를 보는 역량이 도대체 뭘 말하는건지 구체적으로..? 해본적이 없으니 와닿지가 않음.
- 기존에 개발자가 하던 작업을 많이 대체하기도 했는데, 오히려 일은 더 늘어난 느낌이기도 하다 이상하게....그리고 제대로 일을 하기 위해서 요구되는 수준도 높아진 느낌?
- 바이브코딩을 잘 하려면 역설적으로 코딩 자체를 원래 잘하는 사람이어야 한다는 역설 -> 이게 깨지지 않으면 사실상 비개발자가 바이브코딩으로 지속발전 가능한 프로덕트를 만든다는게 가능한 이야기인가? 즉 AI가 진짜 모든걸 신경쓰지 않아도 되는 수준으로 올라와야한다는 뜻인데, 그 breakpoint는 언제 혹은 어떤 기준을 충족했을 때 그게 되는건지?
- 시간이 부족한데, 어떻게 이 갭을 메꾸지..? 기본기 부족을 채우고, 좋은 코드를 보는 눈을 기르고, 테스트 역량을 기르면서도, Andrej Karpathy가 최근 (트위터 글)[https://x.com/karpathy/status/2004607146781278521?s=20]에서 `a new programmable layer of abstraction to master` 이라고 표현했던, 새로운 시대의 프로그래밍 기술인 AI-assisted coding과 AI-integrated/AI-native system을 만드는 방법 등을 언제 메꾸냐고......'이미 존재하던 layer'들에 추가되었을 뿐, 기존에 존재하던 layer를 몰라도 되는게 아니잖아 ㅋㅋㅋ 재밌네 그치

# 시니어와 주니어의 차이점

AI가 코딩에 대한 장벽을 낮춰줄 것 같지만, 실상은 시니어가 AI를 더 잘씀

시니어 -> 일을 더 빠르게 처리하기 위해서 AI 사용
주니어 -> AI 활용해서 일하는 방법을 배우려고 함(어...이거 난데..?ㅋㅋㅋ)

# 바이브 코딩 vs AI-assited engineering

2가지는 완전히 다른 방식이라고 함.

## 바이브 코딩

바이브코딩으로 인해서 발생할 수 있는 문제점

- 코드 안정성 떨어질 수 있음(일회성 프로덕트 완성은 가능해도, 지속적인 변화/확장에 취약한 코드이거나, 보안 측면에서 취약한 코드이거나 등등...서비스되는 프로덕트의 코드베이스를 작성할 때 고려해야되는 확장성/안정성/보안 등 요소는 인간이 반드시 체크해야한다는 점.
- 계획 단계가 너무 가볍게 여겨질 수 있음.(이거 해줘 하면 바로 해주니까, 그리고 AI모델의 성능이 올라갈수록 어느정도 수준의 웹사이트 정도는 개떡같이 써도 찰떡같이 만드는 것처럼 보이니까..) 하지만 청사진의 중요성은 아무리 강조해도 지나치지 않다.

`규율이 없이 속도만 높이면 취약한 소프트웨어가 만들어질 위험이 커진다.`

-> 그러면 새로운 시대에 개발자의 중요한 역할 중 하나는, AI가 제공하는 엄청난 수준의 코드 생산성 증가에 어떻게 고삐를 채워서, 어디로 튈지 모르는 폭주기관차가 아니라 KTX로 만들것인지? 이런 것이겠네... 나의 고민은 여기에 있어야 하겠다는 생각이 들었따.

소프트웨어 엔지니어링이 아이디어를 소프트웨어로 만들고 개선하는 일련의 과정 일체를 일컫는 것이라고 하면, 일련의 과정 속 각 단계별로 AI가 이미 다 사용되고 있음. 각 단계별로 AI를 어떻게 활용해서 안정적으로 속도와 효율을 높일 것인지? 이게 포인트임.
(SDLC 소프트웨어 개발 생명주기 - 기획 -> 설계 -> 구현/개발 -> 테스트 -> 배포 -> 유지보수 - 전반에 걸쳐서 AI가 다 이미 들어가있는데, 나는 굉장히 작은 부분에서 쓰고 있지 않나 하는 생각이 들었다. 구현 정도..? 회사에서 주어진 역할과 무관하게, 작은 시스템이라도 만들어서 굴리는 연습을 해봐야하지 않나 하는 생각이 들었음.)

## AI-assisted engineering

계획을 잘 세우자. 제약조건/수용기준 등을 명시해서, AI가 속도와 창의력을 발휘할 공간 자체를 제한하는게 매우 중요함. 방향을 잘 제시해주고...

갑자기 이런 생각이 들었다. AI-assisted coding과, 바이브 코딩의 차이는 그냥 얼마나 더 지시가 구체적이냐 차이이지 않을까?

바이브코딩 -> 선언적 프로그래밍
AI-assisted engineering -> (the modern) 절차적 프로그래밍

이런 느낌이 들었음. 모순적인데, 인류 역사상 가장 선언적인 코딩 방법인데, 가장 선언적인 프로그래밍을 잘 하려면 반대로 절차적 사고와 프롬프트 작성이 필요한 단계에 있구나. (그러면 역사는 반복된다고 쳤을 때, 이 또한 점차적으로 선언적인 프롬프트 작성으로 진화해가려나? (the new) 선언적 프로그래밍은 무엇이 될 것인가?)

어쨌든 각 단계별로 아주 열정넘치고 손은 빠른데 생각이 깊지 않은 주니어 개발자가 있다고 생각하는게 맞는 것 같음. 그래서 이 친구는 잘못될 가능성이 있는 부분, 신경써야 되는 부분, 해야되는 역할 범위를 명확하게 해서 작업을 할당할수록 능력치가 올라감. 일의 완성도가 높아지고 '빠르게 잘' 완성함.

그러면 AI-assisted engineering 관점에서는 AI가 코드를 생성하는게 '와우 미쳤는데?'라는 느낌이라기 보다는, '시킨대로 잘 했네' 같은 느낌이 되는 것.

AI-assited engineering의 BP는, 상세하게 작성된 사양서를 바탕으로 AI가 하나의 미니 애플리케이션이나 기능 전체를 생성하는 방식.
-> 시간을 코드 작성하기 위해서 쏟는게 아니라, 이제는 무엇을, 어떻게, 어떤 제약조건과 컨텍스트를 고려해서 만들지를 잘 정리해서 작성하는 것에 집중해야하는 시대임. 생각구조화, 문서 작성, 이런 것들이 중요해지는 시대.

## 두 방식간의 비교

바이브코딩의 강점은 즉흥적이고, 다양한 아이디어를 쉽게쉽게 테스트해보고 결과를 빠르게 뽑아볼 수 있다는 것.
바이브코딩의 목표 -> 속도와 다양성

AAE의 장점은 체계적이고 반복적이라는 점. 즉 기존 체계를 무너뜨리지 않으면서 생산성 향상을 꾀하는 방법이라는 점.
AAE의 목표 -> 지속 가능한 속도와 신뢰성(지속가능한!!!! 내 생각의 방향성이 틀리지는 않은 부분이 있구나.)

그러면 KIRO가 가려는 방향성이, AAE의 방향성을 많이 고려한 것이 아닌가 싶네. KIRO의 SDD(Spec driven development) 철학이야 말고, Plan first code next 같은 느낌이잖아.

두 방식이 뭐가 더 낫다 이런 것보다는, 상황에 맞는 방법이 있다로 생각하는게 맞음.

- 이런 저런 생각을 정리하거나, 아이디어를 뽑아내거나, 최적의 해결책을 탐색하는 과정에서는 바이브코딩을,
- 개발을 실제로 진행할 때는 AAE를.

나도 자연스럽게 이렇게 하고 있었던 것 같기는한데, 다만 개발할 때도 약간 바이브코딩을 하고 있지 않았나 하는 부분도 있다...

그리고 두 방식은 점차 서로 닮아가면서 결국 하나로 통합되지 않을까..?ㅎㅎ

# 의도 중심 프로그래밍

개발자의 근본 역할의 변화가 일어났음...

원래는 큰 범위에서, '의도'를 '컴퓨터가 이해할 수 있는 코드'로 변환하는 것에서 벗어나지 않았는데,

이 의도 -> 코드 부분을 AI가 하게 되어버려서... 이제 개발자가 할일은 사실 상 의도 -> 코드 그 사이 어딘가에서 또 역할을 찾아야 하는거지..

# AI를 활용한 개발로 인해 새롭게 등장한 어려움

이걸 어떻게 해결할지도 하나의 중요한 축임

- 신뢰와 정확성: AI가 만든 코드 그대로 믿고 쓸 수 있음?
- 저수준 기술의 망각: Python Forloop 작성법 까먹을수도...코드 작성 능력이나 디버깅 능력 등 기본기 하락
- 변화하는 취업 시장...: '구현'이라는 능력에 대한 수요가 줄어들고, 다른 능력을 검증하려고 할 것임. 시스템 설계, 컴포넌트 통합, 정확성 검증 같은 능력을 가진 엔지니어에 대한 수요가 늘어날 가능성이 높음.

하나하나 내가 근래에 생각하는 내용들을 쿡쿡 찌르넹...그러면 생각하는 바를 이런 조언들을 참고해서 해나가면 된다는 소리로 이해되기도? 고민보다는 action이 필요하지 않나 하는...ㅎㅎ 사실 고민이야 맨날 하지머.

# AAE의 단점

장점이야 뭐 좋은건데, 단점을 잘 인지하고 보완하는게 인간의 역할이기도 하겠지?

- 과도한 의존에 따른 기술 퇴화 (때때로는 AI없이 코딩 연습하며 기본적인 기술을 유지하는 것도 중요함)
- 프라이버시와 보안 문제
- AI 자체의 편향 위험: 생각을 못했는데 그렇네. 학습 데이터의 bias를 인간이 캐치하기가 쉽지 않음. 내가 사용하는 기술이 어떤 innate한 한계점이나 위험을 내포하고 있는지에 대한 이해가 필요한 이유. LLM이 동작하는 방식이 있을거고, 그로 인해서 필연적으로 발생하는 이슈(대표적으로 할루시네이션)이 존재할 것임.

# context, context, context

책을 읽다가, AI를 활용해서 문제를 해결하는건 결국 context programming이라는 생각이 들었음.(재키님이 올려주신 자료들 다시 한 번 봐야겠네.)

얼마나 AI한테 충분한 컨텍스트를 잘 구조화해서 전달하는가 이게 핵심

프롬프트 엔지니어링도 다 context engineering인 것으로 이해된다.

# 본질적 복잡성

`본질적 복잡성`이라는 용어 되게 좋은 용어다.

일할 때 사고흐름 프레임에 추가하면 좋을 것 같은 용어네..

이 상황에서 `본질적 복잡성`과 그렇지 않은 복잡성이 무엇일까? 에 대해서 생각해보는 습관을 기르면, 중요한 것과 그렇지 않은 것을 잘, 빠르게 파악하는 능력이 길러질 것 같음.

그렇다면 what is `본질적 복잡성`?

> 문제 자체가 가진 복잡성을 파악하고 관리하는 것. AI는 부수적인 어려움은 잘 해결하지만, 본질적인 난관은 해결하지 못함.

반대되는 표현을 `우발적 복잡성`이라고 표현함. (알아보니 이 사람이 처음 사용한 표현이 아니라, 브룩스의 1986년 논문 No Silver Bullet에 나온 개념이라고 함...대단하넹.)

- 본질적 복잡성 -> 문제 자체가 가지고 있는 피할 수 없는 복잡성. 제거할 수 없음. (Essential Complexity)
- 우발적 복잡성 -> 문제 해결하는 방법이나, 도구 때문에 생긴 불필요한 복잡성. 본질과 상관없이 인간이 덧붙인 복잡성이기 때문에 해결할 수 있음. (우발적이라는 표현이 참 어색하긴한데....Accidental Complexity)
  - 필요 이상으로 복잡한 코드 같은 문제지.
  - 아하 그래서 이런 우발적 복잡성은 AI가 해결할 수 있다고 하는구낭.

AI는 동작 원리 자체가 확률적 텍스트 출력기이기 때문에, 문제를 이해한게 아님 -> 그냥 그럴듯한 답변을 출력하는 것 뿐. 그래서 문제의 본질적 해결을 위해서 필요한 요소들 놓칠 가능성이 존재하고, 이 갭을 메꿀 수 있는 능력이 있느냐 없느냐가 중요한 요소가 됨.

갭을 메꿀 수 있는 능력이 있는 사람이 되려면 뭘 해야될까? 일단 어떤 갭이 존재하는지 인지하는게 시작일거고, 인지는 크게 2가지 방법으로 할 수 있을 것 같음.

- SDLC 전반에 걸쳐서 많이 써본다. 최대한 많은 문제들을 AI를 활용해서 해결해보는 경험을 해야지 뭘 AI가 할 수 있고 뭘 못하고를 알 수 있음
- 관련해서 사람들의 의견을 많이 읽어본다.
- 즉 직/간접 경험을 단시간에 많이 축적하는게 답.

모르겠으면? 일단 뭐라도 해봐라. 그러면 그게 다음 행동의 실마리가 된다.

# AI 시스템이 초기 구현부터 테스트, 배포까지 개발 과정 전체를 혼자서 처리하게 되면 개발자의 실력이 떨어질 위험은 없을까요?

왜 없겠어요 제가 산 증인입니다..

어떡하죠 오스마니 선생님..?

-> 단순히 기계를 다루는 사람이 아니라, 시스템을 설계하는 사람으로 남기 위해 전문성을 지켜야 한다.
-> 소프트웨어의 본질을 깊이 이해해야만 AI 툴을 정말 유용한 방향으로 사용할 수 있다.

# Last Touch

소프트웨어를 완성시키는 것은 나머지 30%이고, 그걸 Last Touch 라고 부를 수 있을 듯.

AI가 10분만에 만들어준 70%의 그럴듯해 보이는 외형을, 세심하게 깎아서 사용자가 쓰기 좋게 만드는 과정이 반드시 필요함.

갑자기 예를 들어서 이런 생각이 드네. 마치 나무로 책상 모양을 다 깎아주는거지. 근데 마감을 치는 것 까지는 못하는거야. (할 수 있는데 사람이 세세하게 어디를 어떻게 마감해야지 사람이 날카로운 면에 긁히거나 하는 일이 발생하지 않는다고 알려줘야 하는거여). 그치 보통 책상 마감이나 이런게 last touch 이지만 UX를 결정짓는 중요한 요소지

소프트웨어도, 세심한 마무리가 애용되는 소프트웨어와 짜증나는 경험을 제공하는 소프트웨어를 구분지으며, 이런 마무리를 짓는 능력은 공감/풍부한 경험/장인 정신에서 기인한다.

- 공감
- 풍부한 경험
- 장인정신
  - 장인 정신을 뭐라고 정의해야될까.

# 많이 쓰다보면 본질적으로 비슷하게 사용하게 되는걸까?

책에서 제안하는 방법들 중에서 내가 이미 AI를 활용한 개발 시 자연스럽게 사용하고 있는 경우도 많은데, AI 도구를 매일 쓰다보면 자연스럽게 귀결되는건가..?

# 바이브코딩 핵심 원칙

제안된 원칙들 중에서 공감되는 원칙들 정리

- AI를 주니어 개발자처럼 감독한다. 피드백을 제공해서 반복적 개선 필요. 빠따 쳐야된다 이거지...
- AI에게 생각을 맡기지 않는다. 자신의 능력을 확장하는데 사용한다 -> 근래에 조금씩 시도하고 있는 중인데 잘 하고 있는 것 같음. 무턱대고 모르는걸 물어보기보다, 한 번 생각해보고 물어보는거지. '말하기 전에 생각하셨나요..?'
- 코드 쓰기 전에 규칙부터 정한다. 팀 내부 컨벤션이나, 공통 프롬프트, 코드 기대치 및 관행 등..
- 형상관리 과정에서 AI 활용한 변경사항을 식별가능한 형태로 커밋하는 등 작업을 통해 검토/롤백/추적에 소요되는 리소스 최소화
- 이해하지 못하는 코드는 커밋하지 않는다. -> 이게 참 어려운데, '코드를 이해했다'라는 건 정확히 무엇인지에 대한 나름의 기준/ 혹은 팀단위 기준이 필요한 영역인 것 같음.
  - 이해라는게 너무 주관적인 영역임.
- 적절한 문서화를 통해서 일관성과 컨텍스트 유효성 유지
- 효과적인 프롬프트 공유하기
- 지속적 개선: 경험을 지속적으로 공유하고, 성찰해서 전체적인 수준과 경험의 깊이가 같이 올라가도록 한다.
  - 미래위에서 이런걸 해보면 어떨까 싶기도 하고..? AI활용에 대한 정답 질의 Agent가 되면 어떨지..? AI 프로젝트 경험이 쌓인 KB같은걸 기반해서 물어보는거지

# 프로그래밍 방식의 변화는 있어도, 숙련된 개발자가 필요한 이유는 변하지 않았다.

현재 상황은 '프로그래밍의 종말'이 아니라, '우리가 알고있던' 프로그래밍의 종말임.

다양한 방식의 변화는 있겠지만, 숙련된 개발자가 필요한 본질적 이유는 그대로임.

방식의 변화에 적응해서, 기존의 본질적 역할을 계속 수행하는 것이 목표일테고,

그렇다면 지금 개발자들이 당면한 challenge는 70%를 나보다 훨씬, 내가 엄청 노력해도 도달하기 힘든 수준으로 수행하는 AI라는 도구를 잘 활용하면서 나머지 30%에 필요한 핵심 역량과 통찰력을 더 키우는 것.

그렇다면 30%의 가치를 극대화 어떻게 함?

알아보자.

## 시스템 통합과 경계 관리

> 구성요소의 경계를 이해하고 관리하는 것이 매우 중요하다.

오호오호 엄청 좋은....배울만한 내용이 많이 담겨있는 문장이네...

그치 네트워크, 운영체제, 서버/클라이언트 구조, MCP, 이런 것들은 하나의 시스템이 다른 시스템과 맞물려서 함께 동작하는 구조에 대한 내용을 포함하고 있는 지식들이네..

컴퓨터 과학 기초 지식이 더욱 중요함

- 자료구조 알고리즘
- 분산 시스템 원칙
- 데이터베이스 내부 및 쿼리 최적화
- 네트워크 프로토콜과 보안

너무 복잡하게 생각한거같아 지금까지. 생각해보면 그냥 내가 만들고자 하는 제품이 동작하는 환경에 대한 이해였을 뿐인데....

지금은 조금 더 이해고 되고 해서 왜 뭘 공부해야되는지 납득이 된다는게 다행이기도 하네.

그리고 추가로 경험적으로 알게 되는, 기능 구현에 있어서 고려해야되는 사항들에 대한 이해도 필요함

- 엣지케이스
  - 만약 이렇게 되면 어떻게 되지? 저렇게 되면? 문제가 안생기나? 같은 질문을 할 줄 알아야 함.
- 모호한 부분
- 실패지점들을 예상하고 관리하기
  - 네트워크 장애, 비정상적인 사용자 행동, 다른 시스템과의 통합 문제 등이 있음.

이와 가능해서 지속가능한 기술, 즉 어디에나 통용되는 기술은 `비판적 사고`와 `통찰력`

또한 도메인 전문성이 필요(나는 상대적으로 도메인 전문성을 쌓기 쉽지 않은 회사에 있는 것 같은데, 이런 단점을 어떻게 보완할지에 대해서 생각이 필요해보임. 일단 내가 지금 생각하는건, 기술적 도메인에 대한 전문지식을 더 깊게 쌓는 것에서 답을 찾으려고 함. 그리고 특정 분야에 대한 '도메인 지식'이라는 것이 왜 필요한지에 대해서 생각을 많이 해보면 도움이 되지 않을까 싶음. 결국 하는 일은 죄다 '문제 해결'이라고 하면, 문제 해결 과정에서 고려해야되는 환경/제약사항들에 대한 이해가 도메인 지식이지 않을까. 의료 시스템은 문제 해결 과정에서 개인정보나, 법적인 이슈를 고려해야되는 것처럼.)

성능 최적화/데브옵스

- LLM이 만들어준 시스템을 요구사항에 따라 최적화 하는 작업
- 성능 문제 식별에는 데이터베이스 쿼리 패턴부터 FE 렌더링까지 전체 stack에 대한 깊은 이해가 필요함
  - 그치그치, API호출했을 때 데이터가 늦게 나타나는 원인을 해결하고 싶어. 그러면 어디에서 문제가 발생하는지 알 수 있어야겠찌? 그러면 모니터링 같은 기술이 필요할거고, 모니터링을 했을 때, FE 렌더링 문제인지, 네트워크 문제인지, API 설계 문제인지, BE 서버 컴퓨팅 자원 제약 문제인지, DB 쿼리 문제인지....
- 모니터링 및 가시성(Observability)
- 성능 프로파일링 및 최적화
  - 수치화를 해야지 최적화를 하지
- 보안 관행 및 준수(컴플라이언스가 이쪽 문제인가)
- 비용 관리 및 최적화

AI가 코드를 폭발적으로 많이 생성한다 -> 생성된 코드를 테스트하는 구조를 만드는게 더욱 중요하다.

- Testing testing testing!
- test는 단순히 코드가 동작하는 걸 넘어서, 비즈니스 로직을 이해하고 강제하는 기술임.
  - 테스트를 할 때 추천하는 방식은, 모든게 동작하지 않을 수 있다고 가정하고 테스트하는 거임.

적응력을 키우고 학습을 지속적으로 하기

- 기초를 깊이 배우고,
- 동시에 새로운 기법에 대한 호기심을 유지하는 데 시간을 투자해라.

둘 다 해야된다는 소리네 ㅋㅋㅋㅋ 아오 요즘 진짜 빡세.

- 그래도 분류하는 기준은 되겠네. 오랜 시간 동안 변하지 않는 것(기본)과, 시대의 흐름에 따라 배워야 하는 것(the new)
- 무엇이 어디에 속하는지 아는것도 필요하겠지.
- AI Detox?

교차 커뮤니케이션 능력

- 요구사항 수집 및 분석
- 기술 문서 작성 및 문서화
- 프로젝트 계획 및 추정
- 팀 리더십 및 멘토링

# 시스템 설계와 아키텍처

도대체 이게 뭔데? 다들 아키텍트가 되어야 한다, 설계가 이제 개발자의 new big thing이다 하는데 도대체 그게 뭔데? 싶었는데 마침 언급이 되길래 따로 하나 항목을 팠다.

시스템 설계를 위해서는

- 분산 시스템 원리
- DB 내부 구조
- cloud infrastructure

에 대한 이해 필요

실제 문제를 대규모로 해결하는 시스템을 설계하는 연습. -> 이는 비즈니스 요구사항과 엔지니어링 트레이드오프에 대한 이해와 일치함.

전체 설계 = 구성 요소 간 상호작용, 데이터 흐름, 확장성과 신뢰성을 보장하는 방법 등

기타

- 로드밸런싱과 캐싱 전략
- 데이터 파티셔닝 및 복제
- 고장 모드 및 복구 절차
  - 대규모 시스템 설계 및 아키텍처 관점에서 시스템이 실패하는 다양한 시나리오를 예측하고, 그 상황에서 어떻게 정상 상태로 되돌릴 것인지에 대한 계획을 의미.
- 비용 최적화 및 자원 관리

> 패턴과 원칙(관심사 분리, 모듈화) 기준으로 사고해야 한다.

경험적인게 엄청 많이 좌지우지 한다는거네.. code reading 이건 code writing이건.

# 여러 분야에서 다재다능하고 똑똑하며 효과적이어야 훌륭한 소프트웨어를 창조합니다.

기술적 장벽이 낮아졌다? 그렇다고 해서 바로 프로덕트가 나오나?

70퍼센트를 ai가 만들었을 때 인간이 채워야 하는 남은 30%에는 비단 설계/확장성 같은 기술적 요소 뿐만 아니라,

UX, 디자인, 사용자 중심 사고 등 프로덕트 관점에서의 완성도도 포함됨.

'사람들이 쓰고 싶은 프로덕트인지?'

이런건 확실히, 1인 개발자가 되려면 단순히 프로덕트를 개발뚝딱 해서 내놓는게 답이 아님

사람들이 해결이 필요한 문제인지 확인하는 것부터가 시작임.

# 주니어 개발자는 뭐해야되는데!

주니어가 원래 하던 일 - 명세를 기반으로 반복작업에 해당되는 코드 작성하는 것 -에 있어서는, 하루 걸렸을 작업을 AI쓰면 한시간이면 함

그러면 이제 필요없다?!? 아니지아니지

이제 그러면 자신의 역할 범위를 확장시켜야지.

- 기존 시스템 아키텍처에 대한 이해에 시간을 할애
  - 이를 활용해 기존 패턴과 일관성 있는 구현 보장
- 보안 문제/엣지케이스 등 단순 기능 구현을 넘어선, 완성도 영역에 기여
- 테스트 작성

이런 것들은 튜토리얼 단위에서 할 수가 없음.

- 운영 시스템에서의 실무 경험과 시니어 개발자의 멘토링이 필요한 영역임....히히...어떡하지..? 어렵지만 방법을 찾아야지뭐.

# 30%에서의 갭을 메꾸려면?

## 왜 라는 질문을 건너뛰지마라

AI를 튜터로 활용해서 원리를 이해해려고 노력해라, 그래야지 확장성이 있음.

- 데이터구조, 알고리즘, 메모리 관리, 동시성 같은 개념을 이해하는데 노력
- 작은 프로그램을 처음부터 작성
- 핵심 지식 확고히 하는데 시간 투자

기본 원칙들은 툴이 변화해도 동일하게 적용 가능하다.

## No AI Coding day를 해볼 것 주기적으로

자신의 기술만으로 문제를 해결해보기.

## 테스트와 검증

자신이 작성한 코드에 대해서 테스트를 작성하는 습관을 기르세요.

**어떤 항목을 테스트해야되는지는 직접 정의해야 한다.** (테스트를 AI가 쓸수는 있지만, 어떤 테스트를 쓸지는 너가 결정해라.)

## 유지보수를 고려한 설계

코드의 가독성, 유지보수 용이성, 깔끔함 이런 요소들을 어떻게 구현해내는지에 대해서 내재화 하려고 노력해라.

What is good code 라는 점이 항상 내재화 되어 있어야 한다.

AI가 생성한 코드를, 동료가 작성한 코드라고 생각하고 리뷰를 계속 해보자.

# 시니어, 중급자, 주니어

시니어 -> 기술 강화를 통해 리더십 발휘하고 혁신 지속
중니어 -> 전문성 심화
주니어 -> 숙련도 빠르게 강화

# AI가 생성한 코드에서 일반적으로 발생하는 보안 취약점에 대한 이해

지금 우리가 사용하는 AI는 패턴매칭임

학습한 데이터에 좋은 코드 뿐만 아니라 나쁜 코드도 포함되어 있을 수 있기 때문에 제대로 프롬프트로 막거나, 검증하지 않으면 안티패턴 코드를 작성했을 가능성이 있음.

개발자는

- AI가 코드를 생성할 때 범할 수 있는 일반적인 보안 관점에서의 취약점들을 알고 수정할 수 있어야 하며,
- 수동 or 자동화 수단을 사용해서 잠재적인 보안 문제를 탐지할 수 있어야 함

## 일반적인 보안 문제들

모든 사항에 적용되는 규칙: 문제 발생 원인을 이해하고, 미리 문제를 방지하는 프롬프트를 넣으면 두번 일할거 한 번 하면 된다.

- 하드코딩된 API KEY: 소스코드에 포함되어서는 안된다.
- SQL 인젝션 취약점: 쿼리나 ORM 코드 생성 시 사용자 입력을 활용해서 쿼리 생성하면 안됨.(쿼리 매개변수화 하도록 지시사항을 포함시키는게 좋겠지.)
- (웹 앱인 경우) XSS: HTML에 사용자 입력을 바로 삽입하는 템플릿이 작성되지 않도록 주의 -> Sanitization 과정이 필요함.(이게 뭔지?ㅎㅎ 공부하자..)
- 부적절한 인증 및 권한 부여: 인증 및 권한 관련 코드 생성시에는 면밀히 체크하는게 좋음. 개발자 본인이 이해를 기반으로 명확하게 프롬프트 짜서 가이드를 잘 해야함.
- 안전하지 않은 기본값 또는 설정: HTTPS 대신 HTTP 사용, SSL 인증서 유효성 검사 안함, CORS를 광범위하게 활성화(모든 origin/method에 대해서), 구식 암호화 사용
- 민감 정보 드러내는 오류 처리: client 로 전송되거나 표시되는 오류에 민감한 내부 정보가 표시되어서는 안됨.
- 의존성 관리와 업데이트: (이거 좀 중요함. 라이브러리 버전 명시 등 필요할 수 있음) 의존성을 추가하는 경우 신뢰할 수 있는 소스에서 온 것인지 확인 필요. 과거 인기가 많아서 학습 데이터가 많으면 지금은 obsolete 하거나 문제가 있는 라이브러리/혹은 특정 버전을 사용할 수 있음.
