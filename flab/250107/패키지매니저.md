# 패키지매니저

패키지매니저는 말 그대로 package를 관리하는 도구인데, 여기서 package가 무엇인지에서 공부를 시작하고자 한다.

## package란

패키지 매니저에서 말하는 패키지란, dependency라고 한다.

dependency, 즉 의존성은 써드파티 소프트웨어로, 어떤 문제를 위해서 프로젝트에 추가하는 다른 사람이 작성한 소프트웨어를 의미한다.

하나의 웹 프로젝트는 여러 개의 의존성을 가지고 있을 수 있으며, 각 의존성은 하위 의존성들을 가질 수 있다.

모던 빌드 도구들이 없이는 이런 의존성을 프로젝트에 script 태그를 사용해서 추가할 수도 있겠지만, 제대로 동작하지 않을수도 있으며 내가 작성한 코드와 의존성을 웹에 배포하기 위해 번들링을 하는 도구가 필요할 가능성이 높음.(번들 - 내 웹앱에 필요한 모든 JavaScript코드를 담고 있는 웹서버에 저장되어 있는 하나의 파일. 일반적으로 사용자 브라우저에서 해당 파일을 다운받아서 로드하는데 걸리는 시간을 최소화하기 위해서 최대한으로 압축되어 있음.)

또한 기존 의존성을 업데이트하거나 교체하고자하면 문제가 복잡해질 가능성이 높음. 의존성이 많아질수록 이를 관리하는게 일이 된다.

이렇게 수동으로 의존성들을 설치하고 관리하는 작업이 복잡하고 어려운 문제를 해결하기 위해서 이를 처리하는 도구가 바로 npm과 같은 패키지 매니저이다.

## 패키지 매니저란.

패키지매니저란, 프로젝트의 의존성들을 관리하는 시스템으로 다음과 같은 역할을 수행한다.

- 새로운 의존성 설치 방법 제공
- 파일 시스템에 패키지가 저장된 위치 관리
- 내 패키지 배포할 수 있는 방법 제공
- 중복되는 의존성 관리 (프론트엔드 개발에서 중요한 부분이라고 함.)

쉽게 말하면, 모던 프로젝트들을 통상적으로 많은 외부 라이브러리나 프레임워크에 의존하는데(ex. React, Lodash) 패키지 매니저는 이런 외부 모듈들을 설치/업데이트/관리하는 것을 쉽게 해주는 도구.

또한 패키지간 호환성도 관리해서 프로젝트가 전체적으로 잘 돌아갈 수 있도록 해주는 역할도 함.

## 패키지 매니저가 동작하는 3 단계

Resolution - Fetch - Link 세 단계로 동작한다.

**Resolution 단계**

`package.json`파일에 명시된 버전 범위를 기반으로 설치할 정확한 패키지 버전을 결정한다. 한 가지 버전이 명시되어 있는 것이 아니라 `^`문자를 사용된 경우 패키지 매니저는 범위 내의 가장 최신버전을 사용하려고 함.

그리고 설치한 패키지가 사용하는 다른 패키지가 존재하는지 확인한다. 그리고 sub-package의 버전도 똑같이 고정하는 작업이 처리됨.

`package.json`에 명시된 버전을 기준으로 해당 패키지와 그 패키지가 의존하는 다른 패키지들의 버전을 각각 하나의 버전으로 고정하고, 결과물을 `package-lock.json` 파일에 저장한다. 이를 통해서 모든 기기에서 고정된 버전을 사용할 수 있어서 버전 차이에 따른 동작의 차이로 인한 문제를 줄일 수 있음.

**Fetch 단계**

Resolution단계에서 lock 파일에 명시된 버전의 패키지를 다운받는 과정으로, 거의 대부분 [npm registry](https://www.npmjs.com/)에서 가져온다.

**Link 단계**

Resolve된 버전으로 Fetch된 패키지를 소스코드에서 사용될 수 있도록 처리하는 과정.

[1] npm Linker

`package.json`파일에서 명시된 모든 의존성을 그냥 `node_modules` 디렉토리 밑에 하나씩 쓰는게 npm Linker의 역할.

이런 방식은 단점이 좀 있음.

- 패키지를 찾으려면 node_modules를 계속 타고 가면서 파일을 여러번 봐야하기 때문에, import나 require의 속도가 느려진다.
- 파일 시스템에 디렉토리와 파일을 하나하나 만들고 쓰기 때문에 디렉토리 크기가 너무 커진다.

[2] pnpm Linker

퍼포먼스가 향상된 버전의 npm이라고 볼 수 있음. npm에서 `node_modules`에 하나씩 쓰는 것으로 인해 느리고 용량이 커지는 문제를 어떻게 해결했을까??

`node_modules`디렉토리는 그대로 사용하되, Hard link방식을 사용해서 디스크 사용 효율을 개선함. Hard link 방식은 간단하게 표현하면 alias를 거는 것이다. npm처럼 매번 복붙하는게 아니라 alias에 바로 접근하는 방식을 사용해서 디스크에는 필요한 의존성이 하나만 설치된다.

그로 인해서 `node_modules` 디렉토리 크기가 훨씬 작다.

하지만 여전히 `node_modules`에 파일을 쓰는 형태는 동일하기 때문에 require나 import 시 파일 읽기가 많이 발생해서 중간중간 멈추기도 한다.

[3] PnP Linker

`node_modules` 없이 의존성을 처리하는 방법.

PnP는 패키지를 불러올 때,

- 어떤 파일에서 import하는지
- 무엇을 import하는지

2가지에만 집중한다. 이 문제를 해결할 수 있다면 굳이 `node_modules`를 순회하는 과정이 필요없다는 접근 방법임.

그래서 이를 **JavaScript 객체**로 처리한다.

JavaScript map을 메모리에 올려서 이를 활용해서 import를 처리한다고 함(이 부분이 잘 이해가 되지 않아서 더 공부해야 함.)

## npm, yarn, pnpm의 차이점.

**npm**

패키지매니저의 선구자. npm이전에는 다 수동으로 다운로드해서 관리했다고 한다.

package.json과 같은 메타데이터 파일 개념, 그리고 의존성을 저장해서 관리하는 폴더인 `node_modules`와 같은 개념을 도입하고 커스텀 스크립트 등 관련해서 지금까지도 널리 사용되는 개념들을 도입했음.

**yarn**

yarn classic -> yarn version 1이다.

yarn classic은 npm의 문제점 중 하나로 지적되었던 설체 프로세스의 속도를 개선하기 위해서 설치 작업을 병렬화하였음. 쉽게 말해서 Yarn은 여러 패키지들을 동시에 설치할 수 있기 때문에 속도 면에서 향상되었음. (근데 npm도 이런 부분을 많이 개선해서 최근에는 그다지 속도 차이가 나지 않는다고 한다. npm 버전 5에서 속도가 개선되었고, npm 7부터는 일부 병렬 설치 기능도 도입되었다고 함. 하지만 기본적으로는 순차적으로 패키지를 설치한다.)

yarn은 보다 나은 개발자 경험을 제공하며, 다음과 같은 개념을 패키지 매니저에 도입했음.

- native 모노레포 지원 (npm은 7버전부터 workspace 기능을 도입하여 모노레포를 지원한다.)
- cache-aware 설치
- 오프라인 캐싱 (설치된 패키지를 로컬 디스크에 캐싱해서 동일한 패키지 재설치 시 네트워크 요청 없이 빠르게 설치할 수 있음.)
- lock files (yarn.lock 파일을 통해서 패키지 버전을 고정해서 모든 환경에서 동일한 의존성 버전을 보장함. npm의 경우 버전 5부터 package-lock.json파일을 도입해서 패키지 버전을 고정한다.)

yarn classic은 2020년에 유지보수모드로 전환되었음.

**pnpm**

pnpm은 npm의 drop-in replacement로 만들어졌음.

pnpm 제작자들이 생각한 npm/yarn의 가장 큰 문제점은 프로젝트 간 사용되는 의존성의 중복 문제였다.

실제로 사용해본 결과, 노트북의 /Library/pnpm/store/v3 라는 디렉토리 안에 여러 패키지들이 설치되어 있는 것을 확인했다.

**yarn berry**

node_modules를 생성하는 대신, .pnp.cjs라 불리는 의존성 lookup 파일이 생성되는데, 이는 중첩된 폴더 구조 대신 단일 파일 이기 때문에 더 효율적으로 처리할 수 있다. 또한 모든 패키지는 .yarn/cache 폴더 내부에 zip 파일로 저장되므로, node_modules 폴더보다 더 디스크 공간을 적게 차지한다.

## npm 문제 1 - 유령 의존성

프로젝트 코드에서 package.json 파일에 명시되지 않은 의존성을 직접 참조해서 사용하는 경우 생기는 문제.

npm이나, yarn classic의 경우 package.json에 명시되어 있지는 않지만, 명시되어 있는 패키지가 참조하는 의존성이 flat하게 설치되어서 프로젝트에서 바로 해당 의존성을 참조해서 사용할 수 있음.

이는 버그로 이어질 가능성이 높음 왜냐하면 해당 의존성을 포함하는 패키지를 삭제하는 경우, 없는 의존성을 참조하려고 하기 때문에.

말로만 들어서는 호이스팅이나, 유령 의존성, flat 설치 등 개념이 와닿지 않아서 실제로 코드를 작성해봤음.

테스트용으로는 GPT한테 물어서 axios를 npm으로 설치해보았다. 분명히 axios만 설치했는데, node_modules 디렉토리에는 `asynckit`, `follow-redirects` 등 다른 패키지들이 최상위 디렉토리에 설치되어 있다. (yarn classic으로 설치를 진행했을 때도 동일한 이슈가 존재함.)

package.json에는 axios만 명시되어 있지만, node_modules 디렉토리 최상단에 존재하는 패키지는 프로젝트 코드 상에서 바로 참조가 가능한 것을 확인했다.

```javascript
// follow-redirects라는 패키지를 직접 설치한적이 없지만, 아래 코드가 정상적으로 동작한다.
const { http } = require("follow-redirects");

http.get("http://example.com", (res) => {
  console.log(`Status Code: ${res.statusCode}`);
});
```

조금 더 찾아보니, npm의 경우 원래 sub-package가 호이스팅 되는 것이 아니라 해당 패키지에 의존하는 패키지의 디렉토리 내에 일일이 설치되었다고 한다.

a라는 패키지에 의존하는 패키지 b, c를 내가 직접 설치했을 때, node_modules에는 b,c라는 디렉토리에 각각 a가 한 번씩 설치되어서 중복으로 설치된다.

이 방법은 모듈간 절대적으로 분리가 이루어지기 때문에 일관성 유지가 되면서 모듈간 충돌 가능성이 적어지는 장점이 있었지만, 용량이 너무 커지고 탐색시간이 증가하는 문제가 있었음.

이 문제를 해결하기 위해서 hoisting이라는 개념을 통해서, 중복되는 패키지는 최상위 디렉토리에 flat하게 설치하도록 npm3에 적용되었다고 한다. 모든 의존성을 검토해서 공유할 수 있는 버전의 패키지는 최상위 node_modules에 설치해서 공유하는 구조.

하지만 이 구조 때문에 결국 유령 의존성 문제가 생김.

## npm 문제 2 - 거대한 용량과 검증의 어려움

node_modules의 크기가 비대해지는것과 package.json에 명시된 의존성들이 제대로 설치되어서 관리되고 있는 것인지 검증하기가 굉장히 까다로움. 이 어려움은 패키지 수에 비례해서 기하급수적으로 커진다.

## 패키지 매니저 간의 차이점에 대해서 이번에 알게 되었음.

멘토님 피드백

궁극적으로는 패키지 매니저를 이 사람은 좀 제대로 활용하고 있구나 하는 부분을 어떤 것들을 보는게 좋을까?

Docker를 하면 알겠지만, 이미지를 build하는데 시간이 오래걸림 -> 멀티스테이지 빌드와 같이 방법들을 활용해서 시간을 단축하려고 한다. 이처럼 빌드 속도나 어플리케이션의 크기와 연관이 되어 있다. 어떤 프로젝트는 빌드 속도가 너무 느리다던지, 번들 파일이 너무 크다던지, 특정 chunk파일이 너무 느리게 불러와진다던지..

패키지 매니저와 관련해서 현 상황에서 개선이 필요한 부분이 보일 것이다. 버전관리라던지 이런 것도중요함(^을 쓰면 버전이 업데이트 되어버린다.)

package.json 같은 경우도 이제 monorepo에서는 더 다양하게 config할 수 있음. node version도 engine이라는 키워드를 통해서 필요한 버전을 명시할 수 있음.

어플리케이션을 점검하는 관점에서 봤을 때, 의존성이 잘 관리되고 있는지 파악할 수 있는가? -> 패키지 매니저는 이런 관점에서 보면 된다.
