# [Advanced Context Engineering](https://www.youtube.com/watch?v=IS_y40zY-hc) 을 보고

Context를 sub-agent로 관리하는걸 넘어서, 일부러 컴팩트를 여러 번 진행한다고 함

그리고 research -> plan -> implement 3단계를 거쳐서 기능을 구현한다고 함.

## 인상깊었던 부분

1. Leverage가 높은 활동에 시간을 많이 투자해라.

research -> plan -> implement 로 구성된 프로세스로 작업을 한다고 하면,

2. 앞단의 작은 잘못이 뒷단에서 크게 잘못된다.

research단계에서 뭔가 꼬이면, 그게 앞단에서는 작더라도 plan -> implement 과정으로 가면서 점차 문제가 커진다고 함.

앞단을 똑바로 하는게 더 중요해진 세상이랄까.

## 문서 및 프롬프트 링크

- the document -> https://github.com/humanlayer/advanced-context-engineering-for-coding-agents/blob/main/ace-fca.md
- research prompt -> https://github.com/humanlayer/humanlayer/blob/main/.claude/commands/research_codebase.md
- plan prompt -> https://github.com/humanlayer/humanlayer/blob/main/.claude/commands/create_plan.md
- implement prompt -> https://github.com/humanlayer/humanlayer/blob/main/.claude/commands/implement_plan.md

## 나라면 어떻게 할까?

목표

- LLM에게 일 시켜서 프로덕트 만들기(내가 최대한 코딩을 하지 않는 것이 목표임)
- Context 관리 구조를 명시적으로 이해하기
- 시켜야되는 작업의 성격을 명확하게 분리(Plan -> Implement를 한 번의 Turn에 하지 않는다.)
- 적절한 HITL Point 탐색.
- 표준화된 방법 도출(여러 단계를 걸쳐서 human이 link가 되어서 넘긴다면, 나눠지는 단계별로 어떤 output/input 스키마를 가져야할지?)
- fully-controlled, fully-human-aware AI SDLC가 되어야 한다.

나에게 주어진 도구는

- cli 기반 AI-Assisted Coding Agent

### 흠흠

일단 보면, 가장 먼저 생각해서 테스트 했던 방법은 Main Agent와 여러 Sub Agent를 활용해서

예를 들면

Main Agent -> add-feature-workflow 라고 한다면, 그 아래에, spec-agent/implement-agent/review-agent 등등을 두고,

sequential하게 작업을 하도록 지시하였음.

이 단계를 좀 많이 써본 다음에 다른 단계에 대해서 논의를 할 수 있을 것 같은데...

이 방식하고,

방식 B 하고 어떤게 더 완성도 있는 결과물로 이어지는지에 대해서 생각을 해봐야하나?

둘 다 만들어보되 최대한 구조화를 해보자.

어떤 결과물을 원하는지?

그리고 궁금한건 내가 얼마나 기획 부분에 에너지를 쏟아야 하는지?

예를 들어서 Spec Agent가 반환해야되는 결과물은 무엇인지?

본질적인 부분이 뭐지?

-> 내 코드에 LLM이 접근할 수 있는 환경에서,
-> 모델에게 지시를 내려서,
-> 원하는 작업을 수행하도록 한다.

이건데...

Context Engineering -> 지시를 할 때 최대한 필요한 정보, 중요한 정보만 제공을 하자 왜? LLM은 순수함수라서 오로지 input에 의해서 output이 결정됨. input에 유관정보만 입력해야지 output에도 유관정보가 입력된다.

무엇이 각 단계별로 '유관'정보인지 알려면, 먼저 사람이 프로그래밍을 할 때 어떤 과정으로 문제를 해석하고 처리하는지 깊게 생각해보는 과정을 통해서 재구축해보는게 필요할 것 같음.

## 사람은 문제를 풀 때 어떤 과정을 거치는지?

과거에 내가 코드를 만들었던 과정을 생각해보자.

버닛 시절을 생각해보면...

뭔가 생각이 잘 나지는 않지만 항상 이런 방식이었던 것 같음

`요구사항 확정` -> `기존 코드베이스 분석` -> `새로운 코드 구현` -> `QA` -> `버그 수정`

요구사항 확정은 뭘까?

어떤 '아이디어'를 실제로 구현 가능한 '실체'로 만드는 과정이라고 해야할까?

근데 이런 부분에 대해서 생각이 좀 어려워서 Gemini와 함께 한 번 생각해보자.

1. 요구사항 확정

인간 개발자의 역할?
-> 아이디어 -> 실체화 하는 과정에서 기술적인 제약사항을 고려해서 아이디어를 선택한 형태로 만들어내는 것이 역할임.

아이디어 -> 이거는 프로덕트를 제대로 만드는 과정에서, 적어도 구현 단계에서는 AI한테 자유도가 주어지면 안되는 영역인 것 같음.

기획을 세우고 구체화 하는 과정에서 ai를 쓰면 안된다는건 절대 아니고,

적어도 AI한테 '이렇게 지금 기능을 이러이러한 비즈니스 목표 달성을 위해서 이런 제반사항을 고려해서 구현해줘' 라고 넘길 때는 애매한 부분이 없어야 한다는 점임.

왜 애매한 점이 없어야 할까? -> LLM 비결정적임. 최대한 원하는 결과를 나오게 하려면 input 부터 여지가 많이 없어야 한다.

LLM은 확률에 기반해서 텍스트 생성하기 때문에, 창의력이 발휘될 room 자체를 최대한 좁히는게 필요한 작업임 coding은. 창의력은 정해진 범위 내에서만 발현되도록...

개발자는 LLM을 '마법'처럼 대하면 안된다는 생각이 들었음. 만들어줘 -> 바로 프로덕트 이렇게 건너뛰면 '아직은' 안되는 단계임.

예를 들면, console.log('hello')라는 코드를 작성하면서, console에 hello라는 텍스트값이 출력되는 것 말고 다른 일이 발생하지 않으리라는 확신을 가지고 코딩을 하잖아.

근데 자연어로 코드를 생성하면서 그 과정에서 생성된 코드가 어떤 코드일지를 모르는게 좀 문제임.

내 생각에는 만약에, LLM이 만들어준 코드를 이해하기가 어려우면...애초에 만드는 과정이 잘못된 것 아닐까 싶음. 내가 의도한 코드와, 내가 예상한 코드와 다른게 만들어졌다는 의미가 아닐지....내가 예상한 범위 내의 작업이 실행되어서 예측 범위내의 코드가 만들어지면 AI가 코드를 많이 생성했다고 해서 그게 테스트하기 버겁거나 하지 않아야하는 게 맞는 것 같음.

즉, 이 프로세스가 생성하는 코드, 변경사항, 발생하는 제약 사항이 예측 범위 내에 있어야 함. 만약에 그게 예측 범위에 없다? 안좋은 LLM 프로세스임. 그냥 블랙박스가 되면 안돼.

그리고 이런 생각도 드네. LLM이 발전한 시대에는, 성능 등 외적인 요인 보다는 내가 빠르게 이해하고 구조를 깊게 이해하고 있는 코드가 제일 좋은 기술이다 라는 생각이 들기도 하네 오히려 더...

생각해보면 사용되는 기술이나 언어를 잘 알고 있을수록 implementation 단계에서의 제약을 잘 설정하고,이것이 잘 지켜졌는지 검증도 할 수 있을 것 같음.

무튼 생각이 사이드로 좀 샜는데, 요약하자면 기획은 인간이 해야된다...기획이나 목표가 모호한 상태에서 '해줘' 는 적어도 프로덕션 레벨에서는 아직 '지양'해야되는 방법론인 것 같음.

기획은 인간이 정확하게 의도를 반영해서 최대한 만들어야 한다.

그리고 생각해보면, 기획이 정확하게 나왔을 때 구현 자체는 속도가 오래 걸리지 않을 가능성이 높음. 그러면 기획에 시간을 더 오래 쏟아도 되지 않을까..? 개발에서 아낀 시간을, 기획에 더 많이 투자하는 식으로 해서 돈을 더 잘 벌 수 있는 구조가 된 것 같음. 더 어려워진 느낌...? 개발이 병목이 아니라서 기획을 잘하는데 개발을 못했던 사람들하고 같이 경쟁해야될 수도 있음

그리고 다음 2가지 중에서는 무엇이 더 맞는 방향성일까?

- 기획을 빨리하고 iteration을 하더라도 AI를 몇 번 더 돌리는것?
- 아니면 기획을 최대한 많이 해서 AI를 활용한 iteration을 줄이는 것? 근데 이렇게 iteration을 여러 번 하면 비용이 단순히 AI 토큰 활용으로 인한 비용만 발생하나? 잘 모르겠네 이런 부분에 대해서도 종합적으로는 이해가 있으면 좋지 않을까 싶기도 하고 약간 지금 우리가 AWS 비용 관리하는 것처럼.. LLM cost도 관리의 영역이잖아.

뭐가 비싼 비용일까 시간? LLM 지출? 잘 모르겠네 이런건 어떻게 비교해야되는지? 왜냐하면 세상에서 제일 완벽한 프로덕트를 만들어도 비용이 감당이 안되면 현실적인 어려움이 생겨버리잖아

무튼 또 생각이 산으로 갔넹 ㅋㅋㅋㅋ

다음다음..

2. 구현 전 과정. 분석설계

크게 봤을 땐, 기획 -> 구현으로 이어지는 것 같음.

기획을 철저하게 하고, 개발자한테 기획을 전달하고 개발해달라고 하는거지.

기획사항을 전달받은 개발자는, 일단 뭐부터 하지?

일단 기획을 파악해야지 그치.

기획을 이해하는 과정에서, 개발자가 이해가 안되거나 의아한 부분이 있으면 설명을 요구하거나 상의해서 기획을 수정하고, 최종 결정된 기획안을 기반으로 구현에 들어가잖아.

일단 이 최종 기획 단계까지는 개발자가 해야되는 것 같음. 그리고 기획을 이해한 상태에서, research를 시작하기 위한 프롬프트를 입력해야 한다.

어쨌든 개발자가 일단 구현을 하려면,

대략적으로 뭐가 필요한지 생각을 하잖아.

- 일단 기존 코드베이스를 이해하는 과정이 있고, 새로운 코드를 어떻게 구현할지에 대한 부분이 있음.

근데 이 부분에 대해서 막 생각이 정리가 잘 안돼서 뭐라고 써야할지 잘 모르겠다는 느낌이 드는데, 이유를 생각해보면 코드베이스를 이해하는 것과, 새로운 코드를 어떻게 구현해야될지 생각하는 부분이 분리된 사고흐름이 아닌 것 같음.

뭘 만들어야할지 대충 감을 가지고 있는 상태에서 어디를 어떻게 수정해야될지, 내가 만들고 싶은걸 만들려면 뭘 알아야 되는지 등에 대해서 생각하는 느낌..?

무튼 인간이 아이디어를 코드로, 기존의 codebase에 변형을 가해서 구현하는 과정은 Linear하지 않다. 분석 -> 구현 이게 이니라, 분석하면서 구현설계하고, 또 설계하면서 필요한 부분을 또 분석하고 이런 식으로 재귀적인 루프라고 해야되나?

근데 LLM에게 그러면 어떻게, 분석과 동시에 또 필요한 부분을 파악해서 더 분석하고 이런 loop적인 사고를 할 수 있도록 할까?(아니면 애초에 필요한가??)

무튼 이런 과정이 필요하다는 점. 캐치를 하고 가자.

아 근데 LLM은 어떻게 음...아 모르겠다 어렵다 이부분.

이걸 합쳐서 research 라고 하는건가..?

research = 기존코드 분석 + 새로운 미래 tobe 설계 이게 함께 되어야 하는걸까?

아니면 그냥 이와 관련해서 필요하다고 판단되는 부분을 분석해..?아오 어려워

제약을 잘 가해보자 그래도

3. 구현단계

여기서는 내 생각에, what을 만드는 것 자체는 LLM이 아마 인간보다 제일 잘하는, 인간이 어쩌면 다시는 기계를 이길 수 없는 영역이 되어버린 것 같음. (안그런 언어/기술들도 있긴한데, 굳이 그런 기술을 쓰지는 않을테니까..)

그러면 코드를 마구마구 잘 찍어내는, 이 손가락이 엄청 빠르고 정형화된 코드를 잘 작성하는 우리 주니어 개발자에게는 뭐가 중요하지?

적절한, 정해진 규칙을 따르는 코드를 작성하도록 하는데 있어서 가장 신경을 많이써야함.

사실 개발을 하면 똑같은 기능을 만드는 방법은 여러가지가 있음.

그러면 그냥 기능만 돌아가면 되지 왜 특정한 제약조건을 줘야하나?

이거는 오로지 이유가 인간한테 있을까?(처음에는 그렇다고 생각했는데, AI가 코드를 이해하고 작성하는 근간 원리를 생각해보면 현재 LLM기반으로 돌아가는 시스템에서는 ) 솔직히 뭐가 더 좋은 코드다 아니다 이런건 약간 좀 애매하고 주관적인 영역이잖아.

근데 그러면 코딩 컨벤션, 우리가 선택한 코딩 스타일 이런게 왜 필요하지?

결국 alignment 때문이라고 생각함. 팀으로 함께 동일한 코드베이스에 작업을 할 수 있어야 하고, 뿐만 아니라 과거의 나, 현재의 나 그리고 미래의 내가 협업하기 위해서 필요한거임.

서로 어느정도 예상되는 부분이 있으니까, 상호 이해를 기반으로 코드를 이해하고 읽을 수 있어야 함.

그래서 이런 상호이해가 반영되도록 하는게 매우 중요함.

그때그때 필요한 기술적인 제약사항들이 있지만, 무튼..ㅎㅎ

## 그렇구나 조금 정리가 된다.

1. 레버리지 발생 포인트의 양극화가 더욱 심해졌다.

예전에는 그래도 아이디어만 가지고는 뭘 하기가 어려웠음. 코드를 짤 줄 알아야 IT제품이 나왔으니까.

그래서 기술자들이 필요했고, 기술자들 중에서 기술력이 뛰어난 사람들은 확실히 레버리지를 발생시킬 수 있었음.(근데 그마저도 AI가 나오기 전 한 2021~2022년? 이쯤에도 개발이 중요한게 아니다. 뭘 만드는지 비즈니스를 이해해야된다 이런 얘기들을 종종 봤었던 것 같기는 하다.)

근데 지금은? 코딩(적어도 뭔가 결과물이 짜잔 나오는 수준의 코드를 작성하는 작업)은 더이상 병목이 아님. 코드 작성에서 나오는 가치가 거의 0에 수렴했음 이미.

이거는 뭐 논란의 여지가 없다. 나도 약간 회의적이긴 한데 그거랑 별개로 코드 작성에서 오는 병목은 진짜 없다고 봐도 무방하다.

그래서 아이디어, 기획, specification. 무엇을 어떤 느낌으로, 어떤 방식으로 만들 것인지 이게 진짜 레버리지가 발생하는 사실상 유일한 포인트인 것 같음. 그래서 레버리지가 그래도 코딩쪽에 조금 있었다면 이제는 완전히 product영역으로 넘어간느낌. product management 쪽으로..

2. 그래서 플래닝이 중요하다

플래닝이, 레버리지가 가장 큰 작업인데, 심지어 이게 잘못되면 뒷단이 다 의미가 없거나 더 크게 꼬여버림.

그러니까 이 플래닝에 정말 집중해서 잘 해야하고, 또 이 부분을 공부해야되는 세상이 된 것 같음.

기획과 더불어 이제는 사람의 마음을 건드리는 부분을 이해해야되는 영역이라서, UX 공부를 같이 해야되는 세상이 아닐까..

이제는 개발자라는 타이틀도 떼고, 그냥 프로덕트 매니저 이런 식으로 가야하는 것 아닌가 모르겠다.

product lifecycle 전반적으로 필요한 일들을 루프 돌릴 줄 아는 사람

개발 -> 배포 -> (사용자)피드백 -> 수정 이 루프 전반을 이해하고 처리하는게 필요하려나..ㅎㅎ

3. 생산성이라는 착각에 주의해야되는 시점인 것 같음.

나한테 하는 이야기다. 코드 엄청 찍어내고, 예전과 다르게 그냥 깃허브에 잔디 미친듯이 심을 수 있고 심지어 모든 커밋이 엄청난 양의 코드 생성 및 변경일 수 있음.

그래서 내가 지금 생산성이 엄청 올라갔다라고 착각하기 엄청 쉬운 상태임. (사실 좀 공허하기도 하고.... 뭔가 과거에 비해서 더 토이프로젝트가 가치가 없는 느낌이 들기도 한다.)

근데 생산성을 이제 코드 생성에서 보면 안되는 세상인 것 같음. 뭘 만들었는지는 모르겠찌만 일단 만들었따 -> 이거는 그냥... 틀렸지만...하지만 빨랐죠? 이런 느낌임.

생산성은 이제 기획 쪽에 있어야 하는 것 같음. 얼마나 내가 생각을 잘 구조화해서, 잘 정리해서 코드를 짜는 놈한테 잘 던져줄 것인가 여기에 생산성이 있어야 함.

AI를 쓰건, 머리가 좋건, 뭘 하더라도 이 잘 던지는 과정 여기까지 가는게 생산성이지, 코드를 만들어내는 것 자체는 생산성이 아니다.

(그래도 코드를 잘 만들고 동작하는지 검증을 잘 하는 것은 또 생산성인 것 같기도 하고. 무튼 '코드 생성' 자체는 생산성이라고 하기 애매한 영역으로 가버렸음.)

오히려 그래서 더 프로덕트를 세상에 내놓고, 하나라도 피드백을 받던지 해야되는 세상이 아닐까 싶다.

그래야지 진정한 의미가 있지 않을까. 모르겠따 솔직히 어렵다 ㅋㅋㅋㅋ

## 잡생각

근데 이런 생각도 드네 너무 LLM가지고 코드를 많이 생성하니까 새로운 기술 접근법들이 오히려 덜 나오지 않을까? 아닌가 더 나오려나...모르겠네

React는, Web 개발이 as good as it gets일까..? 아니었을수도 있을텐데 분명히, LLM의 등장이 경쟁자 등장 가능성을 많이 죽였을지도....

## 재밌다.

아직까지는 힘드냐 재밌냐라고 했을 때 재밌다라는 생각이 더 강하게 드는 것 같음.

재밌다 새로운 기술들이 나오는거 써보고 이해하고 하는게.
