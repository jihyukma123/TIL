# react-native-webview 관련 에러

## 문제 상황

`react-native-webview`를 활용하는 라이브러리를 사용하려고 했다.

Android의 `hardwareAccelerated`를 false로 설정해야된다고 해서 그렇게 했더니 앱이 전체적으로 버벅이는 현상이 발생하였음.

유저 사용성에 매우 크리티컬하다고 판단해서 다른 방식이 필요했다.

왜 저 설정이 필요한지 찾아보니 Android 특정 버전(11) 이상부터 `react-native-webview`로 웹뷰를 띄울 때 해당 웹뷰의 height값이 window보다 큰 경우 앱이 강제종료되는 버그가 있어서 이를 방지하기 위해서 필요한 설정이었다.

버그가 재현되는지 확인하기 위해서 ScrollView안에 height가 2000 인 WebView를 렌더링하려고 하니 바로 앱이 강제종료되는 것을 확인하였다.

`react-native-webview`라이브러리 깃허브 이슈들을 쭉 읽어보니 관련해서 어떤 사람이 contribute한 해결책이 머지된 업데이트 버전이 있는 것을 확인하였다.

업데이트 이후에 같은 조건으로 테스트 했을 때 문제없이 렌더링 되는 것으로 확인하였다.

다만 원인을 명확하게 모르는 것이 찝찝하다...

어디서 어떻게 잘못되었는지 모르고있어서 특정 유저들에게 강제종료 현상이 발생하지 않을까 걱정이 된다.

다만 해당 이슈 댓글에 몇몇 사용자들이 이 해결책을 적용한 이후에 관련해서 발생하던 crash report들이 더이상 발생하지 않는다고 했다는 점을 감안해서 적용해봐도 될 듯 하다.

추적이 계속 필요한 이슈일 것으로 보인다.

## 문제를 해결하면서 느낀점

우선 `앱 버벅임 -> 원인 분석 -> 왜 해당 설정이 필요한지 파악 -> 해당 설정이 필요한 근본 원인을 해결하는 방법 모색` 으로 이어진 추적 흐름 자체는 괜찮았던 것 같다.

다만 조금 더 컴팩트하고 빠르게 정보를 검색하고, 필요한 부분을 잘 정리해서 공유를 했더라면 더 빠른 의사결정이 가능하지 않았을까 싶다.

어떤 부분이 부족했을까?

**원인 분석에서 어느 정도 결이 비슷한 문제였는데 원인을 빠르게 파악하지 못했음**

최근에 push notification도 그렇고, 과거에 애플워치 picker관련 이슈도 그렇고 내가 작성한 코드와는 별개로 앱이 돌아가는 환경에 관련된 이슈였는데, 이에 대해서 추론하는 것이 너무 오래걸렸다고 느꼈다.

아직도 문제가 생기면 일단 코드부터 뜯어보면서 머리를 박는 습관이 있는데, 앞으로는 조금 더 앞단에서 이슈의 성격에 따라서 가능성이 있는 원인이 무엇일지 고민하는 단계를 넣어야겠다.

This would for sure save your time and effort.

**이슈를 추적하는 과정에서 알아낸 사실들을 머릿속으로만 기억하고 기록하지 않았음**

간단한 이슈도 아니었고, 문제 상황을 팀에 공유한 상황에서 이에 대해서 조사를 할때는 나중에 결과를 공유할 것 까지 고려해서 조금 기록을 했으면 더 좋았지 않았을까 생각한다.

이슈 자체를 해결하는데 너무 몰입을 해서 단서를 하나하나 찾아가면서 계속 검색하고 찾고 읽고 하면서 원인을 파악했더니, 나중에 팀에 공유를 할 때 설명이 체계적이지도 않았고 관련 자료나 웹페이지를 바로바로 보여주지도 못했다. 말도 중구난방으로 두루뭉실하게 되기도 하였다.

돌이켜 생각해보니 이슈를 추적하는 과정을 기록하고, 그 중에서 필요한 정보를 따로 빼서 정리하고 참고자료도 기록하면서 정리했더라면 더 체계적이고 명료한 공유가 가능했음을 깨달았다.

앞으로는 팀에 공유해야되는 내용을 조사할 때는 정리를 같이 꼭 하자. 그리고 잘 정리할 수 있는 방법에 대해서도 끊임없이 고민하면서 개선해나가자.

**원인에 대해서 기술한 글을 읽으면서도 잘 이해하지 못했음**

이는 아쉬운 점이다.

문제의 원인에 대해서 추적한 flow에 대해 기록한 글을 읽으면서 대부분의 내용을 이해하지 못했다. 사실 오늘 이 글을 쓸 때도 더 구체적으로 작성하고 싶었는데 아는게 이것 뿐이라서 더 쓰지 못했다.

이걸 모르는 것이 앱 개발자로서 감안이 가능한 부분인지, 아니면 내가 알아야 하는 내용인데 모르는지도 모르겠다.

다만 알 수 있는 것은 배워야할것은 참 많고, 또 배웠을 때 분명히 그 지식을 통해서 문제를 해결하고 해결한 문제들이 가치를 창출할 것이라는 점이다.

주어진 작업을 하는걸 넘어서 가치를 더하고 만들어내는 개발자가 되기 위해서 계속 의식적인 노력을 더해가자.

# async await error handling in JavaScript

이번에 PG 관련된 개발을 하면서, 안정성이 무엇보다 중요한 작업이기 때문에 다른 것보다도 flow에서 예외상황이 발생할 케이스에 대해서 고민하는데 시간을 많이 쓰고 있다. (작업 들어가기 전에 전체적인 작업 흐름에 대해서 예상해보고, 어떤 부분이 중요한지 파악한 후 그에 따라 시간을 분배하기로했던 액션 플랜을 따르고 있다 하하하하하)

그러다보니 필연적으로 error handling을 잘 하는 것이 중요한데, 사실 여전히 error handling에 대해서 잘 모르는 느낌이다.

모르면 배워야지.

## Promise랑 async-await에 대해서 먼저 제대로 알고 시작하자.

근간이 되는 지식부터 습득해보자.

### Promise

_Promise_ 란 JavaScript 객체.

어디에 써먹는 객체냐? represents the eventual completion(or failure) of an asynchronous operation.

Promise는 세 개의 상태를 가진다.

- pending: 최초 상태, fulfilled or rejected가 아닌 상태
- fulfilled: 비동기 operation이 성공적으로 처리되었음을 의미
- rejected: 비동기 operation이 실패했다는 의미

Promise의 최종 상태는 `fulfilled with a result` or `rejected with a reason`이 된다.

Promise 객체는 `then()`메서드를 통해서 promise가 fulfilled 되었을 때 실행될 콜백을 처리하거나, 아니면 `catch()`메서드를 통해서 promise가 rejected되었을 때 실행될 콜백을 처리할 수 있다.
