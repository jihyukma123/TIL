# 개인프로젝트 개발

## 오늘의 개발일지

어제는 축구보고 바로 잠들어서 캘린더에 빈 날짜를 0으로 채우는 작업까지 밖에 완료하지 못했다.

오늘은 해당 숫자들을 실제 데이터(해당되는 날짜)로 채워보자.

### 목표

캘린더에서, 특정 달을 선택했을 때 첫 번째 날짜가 해당되는 요일이 일요일이 아닌 경우 및 마지막 날짜가 토요일이 아닌 경우 각각 필요한 만큼 비는 날짜를 이전달/다음달의 날짜로 채워지도록 처리한다.

- 캘린더는 일요일을 한 주의 시작으로 한다는 가정하에 구현

### 구현 계획

**첫 번째 아이디어**

캘런더 앞 뒤로 비는 날짜들의 수를 구하고, 각 해당되는 개수만큼 이전달/이후달의 마지막 날짜/첫 번째 날짜에서 날짜를 계산해서 해당되는 달의 날짜배열 앞 뒤에 추가.
-> 그런데 이전달 데이터를 어떻게 구할지 생각하다가 마지막 날짜를 기준으로 필요한 개수만큼 for문 돌면서 필요한 배열을 생성하는 형태를 생각하였음. 근데 굳이 또 for문을 돌아야한다는 점이 뭔가 복잡하게 느껴짐.

**두 번째 아이디어**

해당되는 달의 이전달/다음달에 대해서 각각 날짜배열을 구한다. 그리고 필요한 만큼 각 배열을 뒤/앞에서부터 잘라서 해당되는 달의 배열의 앞/뒤에 붙인다.

이 방법대로 우선 구현해보려고 한다.

내가 생각하는 이 방법의 장점

- date-fns 를 이용해서 특정 월의 날짜 배열을 쉽게 구할 수 있으므로, 코드가 깔끔해질 가능성이 클 것이라고 판단함. 주어진 달의 이전/다음달 날짜배열 구해서 자르기만 하면 된다.

단점?

- 배열을 자를 때 뒤를 잘라내는 것은 괜찮은데 앞에서 자르는 것은 잘리는 배열의 인덱스를 다시 계산하는 과정이 포함되므로 약간의 비효율이 있을 수 있다는 점. 다만 배열의 길이가 최대 31로 짧으므로 큰 비효율이 아닐 것으로 추측됨 (차후 개선 포인트 - 차후 개선인 이유는 일단 적당한 범위 내에서 프로젝트를 완성하는 것을 1차 목표로 삼았음.)

### 실제 구현 관련

**이전달/다음달을 일관되게 구하는 방법**

이전달 및 다음달의 날짜 수를 구하려면 해당 월의 데이터를 구해야한다. 처음에 든 생각은 1씩 빼버리되 해당 달이 12월이거나 1월인 경우를 케이스 처리를 따로하는 방법이었다.

위 방법대로 처리해도 더이상 처리하는 케이스가 생기지는 않을 듯 했으므로 상관은 없었겠지만, 불필요한 조건처리를 더 줄이고 싶어서 찾아본 결과 date-fns의 `subMonths`와 `addmonths`라는 API를 활용해서 처리하였다.

**순수함수 여부 고려**

함수형 프로그래밍과 관련해서 공부했던대로, 예측가능한 코드를 작성하기 위해서 캘린더 날짜를 계산하는 함수를 최대한 순수함수로 작성하고자 노력하였다. 동일한 input에 대해서는 하나의 output만 매칭되고, 외부 세계의 어떤 것에도 영향을 주지 않는 형태로.

**날짜를 구분해서 컬러를 부여하기**

구현하고보니, 단순히 날짜배열로 구현해서는 해결하기 힘든 문제를 하나 발견함. 이번 달이 아닌 날짜를 다른 색상으로 표시해주기 위해서 날짜를 구분짓기가 어렵다는 이슈가 있었다. 대부분의 캘린더들을 보면 해당 달의 날짜가 아닌 경우 옅은 색상으로 이를 표시한다.

우선 `daysToShow` 배열의 데이터 형식을 number[] 에서 [{month: number, day: number}] 로 변경하고, 해당 달과 month값이 다른 경우 다른 색상을 부여하는 형태로 처리하였음.

데이터 형식을 이렇게 하면 충분한가 하는 생각이 들었는데, 기획이 아직 완벽하지 않은 상태에서 구현을 하다보니 빠진 부분이 있다는 생각이 든다. 조금이라도 기획적인 부분을 더 고려한 후에 코딩을 해야되겠다.

## 오늘 프로젝트 진행하면서 고민되었던 부분

**달력에 표시될 날짜 배열의 데이터를 typing하기 위한 TypeScript 툴 선택**

```javascript
// 아래형태로 데이터를 처리하였음.
dayOfMonth: {month: number, day: number}
```

위 데이터를 TypeScript 의 `type alias`으로 typing할지 아니면 `interface`로 typing할지에 대해서 고민이 되었음.

공식문서를 읽어보니, 이런 문장이 있다.

> If you would like a heuristic, use interface until you need to use features from type.

즉, type관련 기능이 필요할 때까지는 interface를 쓰라고 권장한다.

각 방법이 제공하는 기능에 대해서 알아보자.

**type**

> a name for a type

특정한 형식의 데이터에 대한 이름이다. '별칭'이라고도 볼 수 있겠다.

말 그대로 특정 type에 대한 별칭이므로, type alias를 이용해서 해당 타입에 대한 다른 버전을 만들 수는 없다.

```javascript
type SomeValue = string;

const val: SomeValue = "hello";

// 위 선언은
const val: string = "hello";

// 랑 동일하다. 즉 말 그대로 string, number같은 type에 대해서 부여되는 이름이라고 생각하면 됨. aha!
```

**interface**

인터페이스는 특정 객체의 구조를 정의해둔 형태라고 볼 수 있을 듯 하다.

회사에서 Swift를 활용해서 개발을 한 경험이 있는데, Swift 개발에서 데이터에 대해서 처리하고자 하는 데이터의 Model을 선언하고 해당 Model의 인스턴스를 활용해서 데이터를 처리하는 구조와 interface가 똑 닮아있는 느낌이다.

> 이 객체는 이런 property들로 이루어져야만 해. 필수 property는 무조건 있어야하고, 정의되지 않은 property는 가질 수 없어.

공식문서에서도 interface로 타이핑된 객체에 대해서 TypeScript가 신경쓰는 것은 한 가지 뿐이라고 한다.

> it(TypeScript) only cares that it(the object typed of an interface) has the expected properties.

이런 기능을 제공하기 때문에 TypeScript를 `structurally typed type system`이라고 하는 것.

**interface vs type**

핵심적인 차이는, _type은 새로운 프로퍼티를 추가하기 위해서 확장이 불가능하지만, interface는 언제나 확장이 가능함._
