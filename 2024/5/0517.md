# FlatList 페이지네이션 구현 과정에서 배운 점

회사 프로젝트에서 FlatList에서 데이터를 paginate된 형태로 쿼리하기 위해서 useRef로 선언한 page 변수와 FlatList의 `onEndReached` prop을 이용해서 기능을 구현하는 과정에서 배운 것을 정리한다.

## 페이지네이션이란?

`페이지네이션을 구현한다`라고 표현하는게 맞나? 하는 생각이 들어서 페이지네이션이 뭔지 먼저 공부하였음.

> Pagination is a technique for breaking up large datasets into smaller, more manageable chunks.

간단하게 표현하자면 `페이지네이션`이란 많은 데이터를 부분적으로 불러오는 기술을 의미한다.(`페이지네이션`을 구현한다 라는 것은 맞는 표현이겠다.)

유저에게 표시할 데이터가 100개 저장되어 있는 상황에서, 한 화면에 표시되는 데이터의 개수가 5개인 상황을 생각해보자.

최초 요청 시 한 번에 100개의 데이터를 다 불러오면 구현 자체는 간편하지만, 이 방법에는 몇 가지 문제가 있다.

1. 유저가 보지 않을 가능성이 있는 데이터를 불러오기 위해서 자원이 추가로 소모됨(비용, 하드웨어 리소스 등)

2. 데이터를 불러오는데 소요되는 시간이 더 오래걸릴 가능성이 큼.

즉 UX적인 측면에서도, 효율성 측면에서도 단점이 명확하다.

이를 해결할 수 있는 방법이 바로 100개의 데이터를 나눠서 불러오는 방식이다.

### 페이지네이션의 종류

페이지네이션에는 크게 `페이지 기반 페이지네이션`과 `커서 기반 페이지네이션`이 있다.

**`페이지 기반 페이지네이션`**

말 그대로 페이지를 기반으로 데이터를 잘라서 요청하는 방식이다.

요청할 때, 원하는 데이터의 수와 몇 번째 페이지에서 해당 데이터를 가져올지를 포함해서 데이터를 요청한다.

흔히 보이는, 목록이 있고 하단에 번호가 나열되어 있어 특정 번호를 누르면 해당되는 페이지의 데이터가 표시되는 것이 가장 기본적인 구조이다.

장점

- 구현이 직관적이고 쉽다.
- 현재 어디서 데이터를 가져오는지 명확한 위치를 알 수 있는 값이 존재한다.

단점

- 페이지네이션이 실행되는 도중 데이터가 추가되거나 삭제되는 경우, 데이터가 누락되거나 중복될 가능성이 존재한다.
  - 예를 들어, 데이터를 3개씩 잘라서 가져온다고 생각해보자. 첫 번째 페이지를 가져온 뒤에, 두 번째 페이지를 가져오기 전에 첫 번째 페이지의 2번째 데이터와 3번째 데이터 사이에 새로운 데이터가 삽입되는 경우, 두 번째 페이지를 그 이후에 쿼리하면 기존의 4번째 데이터 위치에 3번째 데이터가 위치해있어 데이터를 중복해서 쿼리하게 된다. 비슷하게, 데이터가 삭제되는 경우 데이터가 누락될 수 있다.

**`커서 기반 페이지네이션`**

가장 최근에 가져온 데이터를 식별할 수 있는 정보를 기억해서 해당 정보를 기준으로 다음 데이터를 가져오는 방식이다.

데이터를 식별할 수 있는 정보를 `커서`라고 해서 `커서 기반 페이지네이션`이다.

데이터 호출 시 가장 마지막으로 가져온 데이터의 id와 함께 가져올 데이터의 갯수를 명시한다.

페이지 형태로 처리된 UI가 아닌, 무한 스크롤 형태의 리스트에서 많이 사용된다.

장점

- 최근 데이터를 식별할 수 있는 값을 기준으로 데이터를 쿼리하기 때문에, 데이터가 변경되어도 그에 따라 맞춰서 처리가 되어 데이터가 중복되거나 누락될 가능성이 낮아진다.
- 페이지를 선택해서 다음 데이터를 보는 UX에 비해서, 끊김없는 경험을 사용자에게 제공할 수 있다.
- 식별자를 기준으로 데이터를 가져오므로 가져올 데이터를 페이지 기반 페이지네이션에 비해서 빠르게 가져올 수 있다.

단점

- 구현이 더 복잡하다.
- 커서가 유일하고 안정적으로 값이 유지되도록 신경써야 한다.

실시간으로 새롭게 데이터가 fetch되고, 데이터가 자주 삽입/제거되는 환경에서 사용하기에 적합하다.

단적인 예가 인스타그램 피드.

### 아하

일단 내가 기능을 구현한 방식은 `페이지 기반 페이지네이션`의 데이터 쿼리 방식으로 했다는 것을 알게 되었다.

기능이 구현되는 플랫폼은 스크롤 되는 리스트이지만, 이번에 구현한 기능의 경우 유저가 해당 화면을 보는 중에는 데이터가 삽입되거나 누락될 가능성이 없는 화면이라는 측면에서는 `페이지 기반 페이지네이션` 기법으로 데이터를 쿼리해도 문제가 없다는 것도 알게 되었음.

그러면 또 고려해야되는 사항은 `성능`일텐데, 이 성능을 어떻게 측정해야되는지에 대해서는 다시 알아봐야 한다.

## 리스트 초기화 시 고려해야 되는 점

상황 - 검색한 키워드에 대한 결과를 보여주는 화면에 페이지네이션이 적용된 상태.

새로운 검색어를 입력 시, 해당 페이지가 새로운 검색어에 대한 결과 불러와지도록 구현해야 했다.

이 때 가장 기본적인 형태로 페이지네이션을 구현해둔 상태에서 2가지 문제점이 발생하였음.

1. 다른 검색어로 검색 시, 페이지가 아래로 Scroll되어 있는 상태였다면 그 상태가 유지된다. 그래서 새로운 검색결과가 중간부터 표시되는 이슈가 있었음

2. 새로운 검색결과를 불러온 상태에서, 페이지를 내려서 다음 데이터를 불러오는 로직이 실행되었을 때 쿼리 함수는 실행되는데 원하는 데이터가 반환되지 않음 (정확히는 빈 배열이 계속 반환되었다.)

1번 문제는 검색 시 FlatList가 최상단으로 Scroll되도록 처리해서 해결하였고,

2번 문제는 알고보니 page값을 초기화하지 않아서 발생하는 이슈였다.(검색어 재입력해서 다시 검색했을 때, page.current값을 다시 0으로 초기화하는 처리가 필요했음.)

일단 구현은 완료했는데, 더 고려해야되는 점들이 있을 것 같다.

- 다른 검색어로 검색 시, FlatList를 최상단으로 Scroll시키는 것이 좋은 UX일까? 다른 앱들은 이런 케이스를 어떻게 처리하는지 참고해봐야겠다.(일반적인 사용성, 유저들이 불편함이나 이상함, 특이함을 불필요하게 느끼지 않을만한 UX가 무엇인지?). 애초에 Scroll시키는 처리가 없이 페이지 자체를 초기화 하는 방식이 낫다면 해당 방식으로 변경이 필요하다.

- page.current를 사용자가 입력해서 실제 검색을 한 가장 마지막 검색어를 저장하는 변수가 변경될 때 초기화되도록 useEffect에 해당 변수를 dependency로 해서 처리하였는데, 이게 최선인지 잘 모르겠다. 근래에 useEffect를 웬만하면 사용하지 말라는 글을 하도 많이 봐서 그런가 왜 이런 느낌이 드는걸까? 내가 작성한 코드의 단점이 있다면 무엇이고, 단점을 어떻게 해결할 수 있을지에 대해서 고민이 필요하다.
