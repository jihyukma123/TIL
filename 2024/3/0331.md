# 제약조건이 주어진 연속 부분배열 구하기.

최근 릿코드 daily 문제들이 연속으로 특정 제약 조건이 주어진 연속 부분배열을 구하는 문제들이었는데, 풀지 못해서 기본 컨셉을 공부해서 못풀었던 문제들을 풀어보고 싶다.

이유는? 그냥 못푸니까 풀어보고 싶어짐.

원리를 이해해보자.

## 연속 부분배열을 구하는 방법.

연속 부분배열 구하기라는 문제를 푸는 방법을 구글링하기 전에 혼자서 문제를 분할정복으로 접근해보자.

`주어진 JavaScript 베열의 모든 연속 부분배열을 구해라` 라는 문제를 어떻게 풀어낼 것인가?

분할정복을 해보자.

배열의 연속 부분배열을 구한다는 것의 결과값이 어떻게 되는가?

배열 -> 프로세스 -> 연속 부분배열 목록

[1,2,3,4,5] 배열의 연속 부분배열들은?
-> [1], [2], [3], ..., [1,2], [1,2,3], [1,2,3,4], ..., [2,3],..., [1,2,3,4,5]

이런 결과값을 도출해야 된다.

어떻게 모든 경우의 수(모든 부분배열)을 순회할 수 있을까?

연속이니까, 첫 번째 요소부터 시작해서 요소를 늘려가면서 다 구하고,
두 번째 요소부터 시작해서 다 구하고,
세 번째 요소부터 시작해서 다 구하고.
...

마지막 요소부터 시작하는 부분배열 다 구하면

이게 전체 부분배열이 된다.

즉 분할한다면, 각 요소를 시작점으로 하는 부분 배열들을 다 구하면 된다.

틀리지 않았나?

작은 배열로 검증해보자.

[1,2,3]

1로 시작하는 부분배열 -> [1] [1,2] [1,2,3]
2로 시작하는 부분배열 -> [2] [2,3]
3으로 시작하는 부분배열 -> [3]

코드로 어떻게 구현해야 되나?

부분 배열을 다 구하는 문제 자체는 이중 for문을 사용하면 될 듯 하다.

```javascript
function getAllSubArrays(arr) {
  const result = [];

  for (let i = 0; i < arr.length; i++) {
    // 이번 요소로 시작하는 부분배열 저장할 배열
    const tempSubArray = [];

    for (let j = i; j < arr.length; j++) {
      // 부분배열에 요소 추가
      tempSubArray.push(arr[j]);

      // 해당 시점 부분배열 저장
      result.push([...tempSubArray]);
    }
  }

  return result;
}
```

그리고 제약사항을 체크하는 경우 모든 부분배열에 대해서 조건을 체크해서 해당되는 경우 result에 push하면 될 것이다.

## 최선인가?

시간 복잡도가 어떻게 되지?

n개의 요소로 이루어진 배열에 대해서

첫 번째 요소에 대해서 n번 순회
두 번째 요소에 대해서 n-1번 순회
세 번째 요소에 대해서 n-2번 순회.
n-1번째 요소에 대해서 1번 순회

즉 n + (n-1) + (n-2) + .... + 1 => n(n+1)/2

n이 짝수인 경우 => 합이 n+1이 되는 쌍이 n/2개
홀수인 경우 -> 합이 n+1이 되는 쌍이 (n+1)/2개

즉 합이 x가 되는 쌍이 y개 있으면 x\* y이니까, n(n+1)/2 가 되어서,

O(n^2)의 시간복잡도가 된다.

최선인 것 같다. 다 구하려면 다 도는 수 밖에 없으니까.

## 이런 식으로 모든 문제를 풀어낼 수 있을까?

못 풀었던 문제들을 풀어보자.

### 713. SubArray product less than K

**첫 번째 시도**

```javascript
var numSubarrayProductLessThanK = function (nums, k) {
  // 이중 for문을 이용한 풀이 시도
  let answer = 0;

  for (let i = 0; i < nums.length; i++) {
    let product = 1; // 곱을 구하는 문제

    for (let j = i; j < nums.length; j++) {
      product = nums[j] * product;
      if (product < k) {
        answer++;
      } else {
        break;
      }
    }
  }

  return answer;
};
```

문제 푸는 것 자체는 성공했다.

하지만 실행 시간이 하위 88프로 정도로 계산되는 것을 보니, 뭔가 내가 놓친 부분이 있다는 생각이 든다.

**개선해보기**

나름대로 더 이상 안되는 경우를 break를 걸어서 처리했음에도 시간이 너무 오래 걸렸음.

어떻게 개선할 수 있을까?

탐색 연산 수를 줄여야 한다.

예전에 요소의 총 합이 특정 숫자보다 작은 부분배열의 수를 구할 때 투포인터를 사용해서 구현했던 것 같은데, 문제의 성질이 비슷하다고 판단되어서 사용해보려고 한다.

left포인터를 이동시키면, 다시 right 포인터를 기준으로 비교해서 right 포인터를 이동시키는 형태로 구현했었다.

그런데 그 때는 총 합이 x이상인 경우인데, 이번에는 총곱이 k미만인 경우이다. 즉, 작아질때까지 구해야 해서, 늘려나가는 형태로 구현하는 것이 적절치 않은 것이 문제네..

아니지. 왼쪽을 이동시켜서 비교해보고, 안되면 오른쪽을 감소시키면서 값을 나누는 형태로 가면 된다.

실행 조건들을 명확하게 명시해보자. (헷갈려서 찾아보니 sliding window기법으로 이해해야되는 문제였다.)
아하 나는 while문을 한 뎁스로만 해결하려고 해서 까다로웠구나. 이중 while문으로 해서 k를 넘어버리는 경우 해당될 때 까지 left를 줄이는 형태로 하면 된다.

- right가 nums.length보다 작을 때
  - expand the window. product \* nums[right]
  - (if necessary) shrink the window
    - while product >= k, product/nums[left] and left++
  - 1 + (right - left)를 정답에 더한다. -> 여기가 바로 이해가 안되는 부분이다.
    - (right-left)가 현재 window내의 subarray의 개수이다.
    - 어떻게 이렇게 되는거지?
  - right++

한 번 해보자 그냥

[10,5,2,6], k = 100

case: left - 0, right - 0, product - 1, count - 0;

- product \* right // product - 10
- product < 100이므로 left관련 처리 필요 없음
- 1 + (right - left)를 count에 더한다.
  - 1은 [10]
  - right-left 는 현재 윈도우의 연속 부분배열의 수
  - right-left = 0;
- right++

case: left - 0; right - 1; product - 10, count - 1

- product \* right // product - 50
- product < 100이므로 left관련 처리 필요 없음
- 1 + (right - left)를 count에 더한다.
  - 1은 [5]
  - right-left 는 현재 윈도우([10,5])의 연속 부분배열의 수
  - right-left = 1 - 0 = 1; [10,5] 를 더해주는 효과
- right++

case: left - 0; right - 2; product - 10, count - 3

- product \* right // product - 100
- product = 100이므로 left 처리 필요(shrink window)
  - product /= left // product - 10, left++
  - k보다 작으므로, while end
- 1 + (right - left)를 count에 더한다.
  - 1은 [2]
  - right-left 는 현재 윈도우([2,5])의 연속 부분배열의 수
  - right-left = 2 - 1 = 1; [2,5] 를 더해주는 효과
- right++

[1,2,3,4,5,6] k = 24 라고 생각해보자.

[1] 1이 더해진다.

[1,2] [2] 2가 더해진다.

[1,2,3] , [1,2,3] - 2-0 = 2, [3] -1 = 3이 더해진다. [2,3] 까지 고련된건가 흠.

[1,2,3,4] -> [2,3,4] -> [3,4] [4], right-left는 값이 하나 추가됨에 따라 추가되는 부분배열의 수(자기 자신을 제외한)

[1]

[1,2] -> [2] [1,2]

[1,2,3] -> [1,2,3], [2,3], [3]

[1,2,3,4] -> [1,2,3,4] [2,3,4] [3,4] [4]

왜 right-left만큼을 추가해주면 되는거지?

이걸 일반화해서 이해하는게 오늘의 과제이다.

이게 이해를 해야되는 포인트이고 문제를 풀어내는 핵심인데 일반화가 잘 안됨

right가 하나 늘어날 때 마다, right-left만큼의 부분배열이 추가된다는 의미인데,

0,1 -> 1개 추가

0,2 -> 2개 추가

0,3 -> 3개 추가

아하 right가 추가되기 전까지 가능한 모든 부분배열은 이미 계산되어 있음

이 문제의 특성은 전체 배열의 곱이 k보다 작으면 모든 부분배열이 작다는 의미이다. 즉 해당 시점에 right가 추가되면서 생성된 모든 부분배열은 조건에 부합한다면 계산해야 하는 부분배열이다.

이 전 시점까지는 모든 부분배열이 처리되었으므로, 추가된 요소를 고려한 배열만 추가해주면 된다.

으아아아아악.. 아니다. 이해를 못했다. 핵심 포인트가 이해가 안된다 왜지?

뭘 놓치고 있어서 이해가 안되는 걸까?

다양한 자료를 통해서 이해하기 위해서 노력해보자.

**[유튭 강의](https://www.youtube.com/watch?v=Oh7yemnCLPk&t=43s)**

twopointers를 사용

풀이 컨셉

예시: [10,5,2,6], k = 100

- left pointer를 fix, right pointer를 움직이면서, 값이 k보다 크거나 같아지는 요소를 찾는다.

10에서 시작,(left right 모두 0)
-> 5로 right를 이동 (2개의 부분배열이 추가된다. [5], [10,5]) 여전히 k보다 작으므로 이동
-> 2로 right를 이동. 100이 된다.
-> left 포인터를 1만큼 증가, [5,2]

-> subarray갯수를 구하는
-> 3개의 요소가 있는 배열이 이번 분기라면, 3-1 + 1 = 3 (새롭게 추가된 )

설명은 이상한데(설명 너무 못하네 자기도 알고 말하는 건지 모르겠음)
-> 결국 이미 처리된 연속부분배열들 중, 유효한 부분배열들에 대해서 새롭게 추가된 요소를 추가하고, 새롭게 추가된 요소만 존재하는 케이스를 +1해주는 것이다.
-> 아하 문제를 알겠음

이전까지 처리된 연속부분배열들 중 제거된 요소가 있는 부분배열들을 제외한 모든 부분배열에 새롭게 추가된 요소를 더해주면 그게 새롭게 생성된 유효한 유효배열의 목록이다.

아 이거 진짜 분하네.

안되겠다 자고 일어나서 이거 마무리 하자.

# 내가 내 필요에 의해 쓰는 시간을 잘 써야, 다른 시간들도 잘 집중해서 쓸 수 있다.

내가 내 필요에 의해 쓰는 시간(요즘은 개발공부를 하는 시간)을 집중해서, 온전히 써야지만 다른 시간들에도 온전히 집중할 수 있지 않은가 하는 생각이 든다.

올해를 돌이켜보니 마음은 급하고, 해야될건 많다고 느끼는데 내가 혼자서 보내는 시간들을 집중도있게 보내지 못하니까 다른 시간들에도 영향이 가는 것 같다.

다른 시간들이 나의 집중력 부족과 목표의 부정확함으로 인해 오염되는 현상을 막을 수 있도록 하는게 시간을 잘 보내기 위해서 필수이다.
