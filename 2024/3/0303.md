# Stack

사전에 정의된 크기를 가지는 자료구조.

한 번에 하나의 데이터 operation이 이루어진다.

- pop: 스택에 가장 위에 위치한 요소를 제거
- push: 스택의 가장 위에 새로운 요소를 추가

스택을 활용하는 과정에서 크게 두 가지 종류의 에러가 발생할 수 있음.

- underflow: 빈 스택에 pop을 하는 경우.
- overflow: 꽉찬 스택에 push를 하는 경우.

JavaScript는 Stack을 구현하기 위해서 배열을 사용하는데, JS 배열은 빈 배열에서 pop()을 해도 프로그램이 종료되지 않고, 애초에 배열의 크기를 지정해서 생성하지 않기 때문에 push를 해서 overflow가 발생하지도 않겠네. 하지만 미리 크기를 할당해서 사용하는 언어에서는 이러한 에러가 발생한다.

## Stack을 활용해서 풀 수 있는 문제들.

**백트래킹**

스택은 계산이 다시 특정 포인트로 돌아가서 다른 조건으로 실행되거나 하는 상황에서 특히 유용하다. 미로에서 갈림길을 만났을 때, 특정 지점을 탐색하면서 나머지 선택지들을 Stack에 밀어둔다고 생각해보자. 선택한 지점이 길이 아니라는 것을 알았을 때, Stack에 밀어둔 다음 선택지를 pop()해서 이어서 탐색하면 된다.

**프로그램 실행 기록**

JavaScript의 Call Stack이 이와 관련이 있겠다. 이건 따로 더 공부가 필요함.

**단어 뒤집기**

단어를 순서대로 Stack에 push하고 pop()하면 뒤집을 수도 있겠지?

**컴파일러에서 수식 계산**

컴파일러는 `2+ 4/5 * (7 - 9)` 와 같은 계산식을 전위식 혹은 후위식으로 변환해서 Stack을 이용해서 평가한다.

**undo & redo**

A - B - C 의 순서대로 작업이 이루어졌을 때, 순서대로 Stack에 push 해서 저장해두면 undo명령어가 실행되었을 때 데이터 상태를 C를 pop하고 B로 만들어주면 됨.

REDO 기능도 필요하므로 두 개의 스택을 가지고 필요에 따라서 넣었다 뺐다 하면서 구현해볼 수 있다.

**재귀**

자기 자신을 호출하는 재귀 함수 구조에서 이전 상태를 기록하기 위해서 컴파일러는 stack을 활용해서 이전 함수 실행 기록을 저장한다.

## Write Code!!

말로만 들어서는 이해가 되는 듯 해도 코드를 직접 써보면서 머슬 메모리도 필요할 것 같다.

몇 가지 주제에 대해서 코드를 써보자.

### Backtracking

`Rat in a Maze`문제를 풀면서 Stack을 활용해보자.

백트래킹: 해를 찾는 도중 해가 아니어서 막히면 특정 포인트로 되돌아가서 다시 해를 찾아가는 기법.

# 컴포넌트 내 선언된 함수에서 컴포넌트 영역에 선언된 변수를 직접 참조하는 형태의 코드에 대해..

`쏙쏙 들어오는 함수형 코딩`이라는 책에 `전역변수를 참조하는 것도 액션이다`라는 내용이 있었다. 이는 코드가 예측 가능한 형태로 수행될 가능성을 떨어트릴 수 있다고 한다.

그렇다면 하나의 컴포넌트 내에서 해당 컴포넌트에 선언된 변수에 컴포넌트 내에서 선언된 함수가 인자로 받아서 접근하는 것이 아니라 바로 접근하고 조작하는 형태의 코드는 괜찮은가? 어떤 위험이 존재할 수 있을까?하는 점이 궁금했었는데 이에 대해서 그 당시에 정리하는 것을 까먹었었다. 그래서 오늘 찾아보고 정리하고 생각해보았음.

## 어떤 단점이 있을까?

**함수가 본인이 포함된 컴포넌트와 강하게 결합됨 - Tight coupling**

컴포넌트 함수 내에 선언된 변수를 그 안에서 정의된 함수에서 바로 참조하면, 해당 함수는 해당 컴포넌트와 강하게 결합된 형태이다. 왜냐하면 해당 함수가 컴포넌트 밖에서 사용될 수 없는 형태로 만들어졌기 때문에.

그러면 이게 항상 나쁜가? 만약에 특정 함수가 정말 그 컴포넌트 내에서만 사용되고 다른데서 사용될 여지가 없는 함수라고 하면 결합도가 높다는 사실 자체는 문제가 되지 않으리라 생각한다.

**코드 가독성 - Readability**

Tight Coupling이 문제가 되지 않는 상황이라 할지라도, readability는 문제가 될수 있다.

꽤 복합한 컴포넌트라서 코드가 길어지는 경우, 해당 함수 내에서 직접 참조한 변수가 어디에서 선언되었고 어디서 어떻게 처리되고 있는지 보기가 어려울 가능성이 높아짐. 즉 코드 가독성 측면에서는 좋지 않은 선택이 될 가능성이 꽤 있음.

**테스트 용이성 - Testing**

이게 조금 문제가 되는 부분이기는 하다. 만약에 해당 함수의 기능이 원활하게 수행되는지 테스트하고 싶은데 외부 변수가 특정 상태임을 보장한 상태에서 테스트를 하거나 하는 상황이 필요할 수 있으므로 테스트의 복잡도가 올라갈 가능성이 크다.

**의도치 않게 변수가 변경될 가능성**

parameter로 전달받은 값은 재할당을 해도 원본값이 변하지 않는다.(arguments are passed by value이기 때문에, 하지만 객체와 배열은 passed by reference 인 점 주의). 그렇기 때문에 함수 내에서 실수로 해당 값을 재할당해도 함수 외부 세계에 그 영향이 가지 않는다.

하지만 바로 외부 변수를 참조하는 경우 실수로 해당 값을 원하지 않는대로 처리하면 고스란히 외부 세계(컴포넌트 영역에 선언된 원본)에 영향이 갈 수 있다.

더 error prone한 코드가 될 수 있다는 점.

## 그래서 결론은?

테스트 용이성이야 아직 내가 겪지 못한 영역이기 때문에 이렇다 말다 하기가 힘들다.

결합도 이슈는 경우에 따라서 괜찮을 가능성들이 분명히 존재한다.

하지만 코드 가독성 + 의도치 않게 컴포넌트 영역에 영향을 줄 수 있음 이 두 가지 문제는 크리티컬하게 여겨짐.

생각해보면 실제로 함수에서 참조하는 값을 찾느라 헤맨 경험도 있고, 분명히 내 생각과 다르게 동작하는 코드의 원인이 내가 의도하지 않은 값처리인 경우도 있었다.

이 두 가지 사항들이 꽤 크리티컬하다고 느끼기 때문에 지금으로써는 특수한 상황이 아니면 인자를 받는 형태로 함수를 선언할 것 같다.

정말 정말 필요하고 어쩔 수 없는 경우에만 외부 변수를 참조하자.
