# Stack

사전에 정의된 크기를 가지는 자료구조.

한 번에 하나의 데이터 operation이 이루어진다.

- pop: 스택에 가장 위에 위치한 요소를 제거
- push: 스택의 가장 위에 새로운 요소를 추가

스택을 활용하는 과정에서 크게 두 가지 종류의 에러가 발생할 수 있음.

- underflow: 빈 스택에 pop을 하는 경우.
- overflow: 꽉찬 스택에 push를 하는 경우.

JavaScript는 Stack을 구현하기 위해서 배열을 사용하는데, JS 배열은 빈 배열에서 pop()을 해도 프로그램이 종료되지 않고, 애초에 배열의 크기를 지정해서 생성하지 않기 때문에 push를 해서 overflow가 발생하지도 않겠네. 하지만 미리 크기를 할당해서 사용하는 언어에서는 이러한 에러가 발생한다.

## Stack을 활용해서 풀 수 있는 문제들.

**백트래킹**

스택은 계산이 다시 특정 포인트로 돌아가서 다른 조건으로 실행되거나 하는 상황에서 특히 유용하다. 미로에서 갈림길을 만났을 때, 특정 지점을 탐색하면서 나머지 선택지들을 Stack에 밀어둔다고 생각해보자. 선택한 지점이 길이 아니라는 것을 알았을 때, Stack에 밀어둔 다음 선택지를 pop()해서 이어서 탐색하면 된다.

**프로그램 실행 기록**

JavaScript의 Call Stack이 이와 관련이 있겠다. 이건 따로 더 공부가 필요함.

**단어 뒤집기**

단어를 순서대로 Stack에 push하고 pop()하면 뒤집을 수도 있겠지?

**컴파일러에서 수식 계산**

컴파일러는 `2+ 4/5 * (7 - 9)` 와 같은 계산식을 전위식 혹은 후위식으로 변환해서 Stack을 이용해서 평가한다.

**undo & redo**

A - B - C 의 순서대로 작업이 이루어졌을 때, 순서대로 Stack에 push 해서 저장해두면 undo명령어가 실행되었을 때 데이터 상태를 C를 pop하고 B로 만들어주면 됨.

REDO 기능도 필요하므로 두 개의 스택을 가지고 필요에 따라서 넣었다 뺐다 하면서 구현해볼 수 있다.

**재귀**

자기 자신을 호출하는 재귀 함수 구조에서 이전 상태를 기록하기 위해서 컴파일러는 stack을 활용해서 이전 함수 실행 기록을 저장한다.

## Write Code!!

말로만 들어서는 이해가 되는 듯 해도 코드를 직접 써보면서 머슬 메모리도 필요할 것 같다.

몇 가지 주제에 대해서 코드를 써보자.

### Backtracking

`Rat in a Maze`문제를 풀면서 Stack을 활용해보자.

백트래킹: 해를 찾는 도중 해가 아니어서 막히면 특정 포인트로 되돌아가서 다시 해를 찾아가는 기법.

# 컴포넌트 내 선언된 함수에서 컴포넌트 영역에 선언된 변수를 직접 참조하는 형태의 코드에 대해..

`쏙쏙 들어오는 함수형 코딩`이라는 책에 `전역변수를 참조하는 것도 액션이다`라는 내용이 있었다. 이는 코드가 예측 가능한 형태로 수행될 가능성을 떨어트릴 수 있다고 한다.

그렇다면 하나의 컴포넌트 내에서 해당 컴포넌트에 선언된 변수에 컴포넌트 내에서 선언된 함수가 인자로 받아서 접근하는 것이 아니라 바로 접근하고 조작하는 형태의 코드는 괜찮은가? 어떤 위험이 존재할 수 있을까?하는 점이 궁금했었는데 이에 대해서 그 당시에 정리하는 것을 까먹었었다. 그래서 오늘 찾아보고 정리하고 생각해보았음.

## 어떤 단점이 있을까?

**함수가 본인이 포함된 컴포넌트와 강하게 결합됨 - Tight coupling**

컴포넌트 함수 내에 선언된 변수를 그 안에서 정의된 함수에서 바로 참조하면, 해당 함수는 해당 컴포넌트와 강하게 결합된 형태이다. 왜냐하면 해당 함수가 컴포넌트 밖에서 사용될 수 없는 형태로 만들어졌기 때문에.

그러면 이게 항상 나쁜가? 만약에 특정 함수가 정말 그 컴포넌트 내에서만 사용되고 다른데서 사용될 여지가 없는 함수라고 하면 결합도가 높다는 사실 자체는 문제가 되지 않으리라 생각한다.

**코드 가독성 - Readability**

Tight Coupling이 문제가 되지 않는 상황이라 할지라도, readability는 문제가 될수 있다.

꽤 복합한 컴포넌트라서 코드가 길어지는 경우, 해당 함수 내에서 직접 참조한 변수가 어디에서 선언되었고 어디서 어떻게 처리되고 있는지 보기가 어려울 가능성이 높아짐. 즉 코드 가독성 측면에서는 좋지 않은 선택이 될 가능성이 꽤 있음.

**테스트 용이성 - Testing**

이게 조금 문제가 되는 부분이기는 하다. 만약에 해당 함수의 기능이 원활하게 수행되는지 테스트하고 싶은데 외부 변수가 특정 상태임을 보장한 상태에서 테스트를 하거나 하는 상황이 필요할 수 있으므로 테스트의 복잡도가 올라갈 가능성이 크다.

**의도치 않게 변수가 변경될 가능성**

parameter로 전달받은 값은 재할당을 해도 원본값이 변하지 않는다.(arguments are passed by value이기 때문에, 하지만 객체와 배열은 passed by reference 인 점 주의). 그렇기 때문에 함수 내에서 실수로 해당 값을 재할당해도 함수 외부 세계에 그 영향이 가지 않는다.

하지만 바로 외부 변수를 참조하는 경우 실수로 해당 값을 원하지 않는대로 처리하면 고스란히 외부 세계(컴포넌트 영역에 선언된 원본)에 영향이 갈 수 있다.

더 error prone한 코드가 될 수 있다는 점.

## 그래서 결론은?

테스트 용이성이야 아직 내가 겪지 못한 영역이기 때문에 이렇다 말다 하기가 힘들다.

결합도 이슈는 경우에 따라서 괜찮을 가능성들이 분명히 존재한다.

하지만 코드 가독성 + 의도치 않게 컴포넌트 영역에 영향을 줄 수 있음 이 두 가지 문제는 크리티컬하게 여겨짐.

생각해보면 실제로 함수에서 참조하는 값을 찾느라 헤맨 경험도 있고, 분명히 내 생각과 다르게 동작하는 코드의 원인이 내가 의도하지 않은 값처리인 경우도 있었다.

이 두 가지 사항들이 꽤 크리티컬하다고 느끼기 때문에 지금으로써는 특수한 상황이 아니면 인자를 받는 형태로 함수를 선언할 것 같다.

정말 정말 필요하고 어쩔 수 없는 경우에만 외부 변수를 참조하자.

# How principled coders outperform the competition

[How principled coders outperform the competition](https://www.youtube.com/watch?v=q1qKv5TBaOA)

위 영상을 보면서 정리한 내용. 좋은 컨텐츠라고 댓글에 많이 언급되어 있어서 보았다.

## 7가지 프로그래밍 죄악

### Not using programming standards.

코드베이스를 일관되게 구성해서 가독성을 늘리고, 구성원 간 정보 공유를 쉽게 하기 위해서 코딩 컨벤션 등 기준을 세우는 것이 중요하다.

### not learning programming design principles

프로그래밍 원칙은 더 좋은 프로그래머가 되기 위한 가이드와 같다.

예를 들어, 정말 중요한 `SOLID`가 있다.

**Single Responsibility**

Break down code to modules with one responsibility each.

```javascript
// 아래와 같은 큰 클래스가 있을 때, 이것을 더 작은 코드로 나누는 것이다.
class UserUtil {}

// 나눈 구조

class UserValidator {}
class UserRepository {}
class UserPasswordGenerator {}
```

코드의 양은 많아졌지만, 아래의 장점이 생겼다.

- 이름만 보고 클래스의 역할을 유추할 수 있음(하나의 역할, 하나의 책임)
- 해당 부분만 테스트하는 것이 더 용이함
- 다른 곳에서 재사용할 수 있음.

**Open/Closed**

미래에 모듈에 새로운 기능을 추가할 때 해당 모듈 자체를 변화시키는 것이 아니라 해당 모듈을 확장해서 기능을 추가할 수 있도록 구현해야 함

하나의 모듈이 완성되어서 사용되는 상태에서는 더 이상 변경되지 않도록 함으로써 새로운 코드가 오류를 일으킬 가능성을 줄인다.

**Liskov Substitution**

정말 성격이 같은 경우의 기능을 추가하는 경우에만 모듈을 extend 해야한다는 원칙

**Interface segregation**

한 모듈은 사용하지 않는 기능에 대해서 알 필요가 없다는 원칙.

모듈을 보다 작은 추상화 단위인 인터페이스로 분리해야 한다. 그리고 해당 인터페이스를 특정 모듈이 필요로 하는 기능들로만 구성한다.

이런 형태로 구성하면 특히 테스트하기가 좋다. 특정 모듈을 테스트하기 위해서는 해당 인터페이스가 제공하는 기능만 mock하면 됨.

**Dependency Inversion**

코드베이스의 여러 모듈들은 서로 소통하기 보다는 매개체, 즉 인터페이스를 통해서 소통해야 한다.

이는 모듈간 직접 연결을 다 파괴해서 각 모듈을 다른 모듈로부터 고립시킨다. 말 그대로 `모듈`이 되어서 필요에 따라서 쉽게 갈아끼울 수 있게 되는 것이다.

인터페이스로 소통하기 때문에 input/output만 신경쓰고 실제 implementation에 대해서는 신경쓰지 않아도 된다.

---

결국 SOLID 원칙을 기반으로 코드를 구성하다 보면 모듈들이 서로 `Decoupling`된 상태가 된다. 그래서..

- 유지보수하기 더 쉽고
- 확장에 열려있고
- 재사용하기 쉽고
- 테스트하기 쉽다.

### 프로그래밍 디자인 패턴을 신경쓰지 않는 것

Creational Patterns

Structural Patterns

Behavioral Patterns

### 나쁜 네이밍

좋은 네임을 붙이기 위해서 피해야할 몇 가지

```javascript
// Avoid Encodings
const numbersArray = [1, 2, 3]; // 이미 배열인게 명확한데 굳이 Array라고 붙이지 않아도 된다.
const numbers = [1, 2, 3];

// Expand Abbreviations
const p = { name: "james" }; // 축약어는 사람에 따라서 알아보기 힘들 가능성이 있다.
const person = {};

// Use clear distinctions
// 코드가 나타내는 바를 명확하게 컨텍스트를 고려해서 드러내는 이름을 써라.
const data = ""; // 무슨 데이터? 컨텍스트에 따라서 애매할 수 있다.
const userData = ""; // 무슨 데이터인지 알 수 있다.

// no magic values
const somevalue = 42 * undefined; // 42가 뭔데? 알수가 없음

const AGE = 42;
const someValue = AGE * undefined; // 아 나이구나 알 수 있음
```

이 부분에서 내가 생각치 못한 내용 중 하나는 string도 마찬가지로 magic value에 해당할 수 있다는 점이다.

```javascript
// 아래 함수에서 딱 봤을 때 뭐가 문제냐라고 했었을텐데, 이제는 'AAAA'가 뭔데? 라는 생각이 든다.

const isValid = (data) => {
  if(data === 'AAAA') {
    return true;
  }

  return false;
}

const VALID_STATE = 'AAA';

function isValid(data) {
 if(data === VALID_STATE) // 이런 형태로 쓰면 보다 정확한 의미전달이 가능하다.
}
```

그리고.. 추가로 더 가능하면 변수가 최대한 기능이나 상태를 설명하는 형태로 쓰면 더 좋겠다.

물론 너무 과하면 불필요하게 길어지겠지만..

```javascript

const getBodyPartNames // not bad
const getMostExecutedBodypartNames // 조금 더 descriptive한 이름이다.
```

### Not testing your code

많은 사람들이 자신의 코드를 테스트하지 않는다.

테스트의 다양한 종류

- 엔드유저 테스팅
- 유닛 테스트
  - 고립된 각 모듈의 기능성 테스트
- 통합 테스트
  - 각 모듈간 상호작용을 테스트

지금 당장 코드가 테스트하기 어려운 형태라면, 먼저 코드를 SOLID패턴에 따라서 모듈화 해봐라. 그러면 테스팅이 놀라울정도로 쉬워질지도? ㅎㅎ

### Time management and estimation

The rule of thumb is, to double or triple the original estimation. (!!! 나도 아직 너무 타이트하게 잡는구나.)

It is better to overestimate and deliver ahead of schedule than miss the deadline

### Rushing to complete

급하게 프로젝트를 진행하면 오히려 돌아갈 가능성이 크다. 왜냐하면 미리 고려했으면 쉽게 해결됐을 문제들을 어렵게 해결하면서 나아가야 하기 때문이다.

오히려 천천히 그때그때 단계에서 충분한 고민을 하고 문제를 풀어나갈 때 결국에는 더 짧은 시간 안에 더 완성도 있는 결과물을 도출할 가능성이 있다.

`Good programmers write code that humans can understand.` - Martin Fowler
