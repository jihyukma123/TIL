# Promise.race

Leetcode 의 `30 days of JavaScript`의 문제 중 하나인 `2637. Promise Time Limit`을 풀었다.

이 문제에 대해서 다른 사람들의 풀이를 보던 중 `Promise.race()`를 활용한 풀이가 있었는데 이 API에 대해서 알지 못해서 공부해보았다.

> The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.

예제 코드

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, "one");
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, "two");
});

Promise.race([promise1, promise2]).then((value) => {
  console.log(value);
  // Both resolve, but promise2 is faster
});
// Expected output: "two"
```

**parameter**

`An iterable (such as an Array) of promises.`

**return value**

뭘 반환하는가? `A Promise`

어떤 Promise를 반환하는가?

- one that `asynchronously settles` with the eventual state of the first promise in the iterable` to settle. 아하! 전달된 Promise중에서 첫 번째 Promise가 결과적으로 처리되는 값으로 처리된다.
- `ALWAYS` never settles synchronously.

비어있는 `iterable`을 parameter로 전달하면 반환된 Promise는 영구적으로 `pending`상태로 남음.

pending된 promise가 없는 배열을 전달하면 반환되어도 return 된 promise는 비동기적으로 settle 된다.

`iterable`에 non-promise값이나, 이미 settle된 promise를 포함하는 경우 이 중 첫 번째 값으로 settle

**언제 쓰면 좋은가?**

> It's useful when you want the first async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).

# Promise Concurrency
