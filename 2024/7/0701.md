# Expo가 많이 올라왔구나!

근래에 트위터로 몇몇 개발자들을 구독해두고 보면서 뭔가 `Expo`에 대한 언급이나, 완성도 자체에 대한 평가가 많이 좋아졌다는걸 느끼고 있었는데 오늘 React Native 공식문서를 읽다가 깜짝 놀랐다.

언제부터였는지는 모르겠지만, 공식문서에도 이제 Expo를 약간 더 권장하는 듯한 뉘앙스로 `Get Started With React Native` 부분이 작성되어 있다.

흠.. 신기하네. RN팀에서도 Expo가 완성도가 많이 올라왔고, 새롭게 RN을 시작하는 사람들에게 추천할만하다고 판단한 듯 하다.

나도 조만간 Expo로도 앱을 하나 만들어볼까. 하하하..

# React Native 공부를 이어서 해보자.

내가 React Native에 대해서 모르는게 뭘까?

아니면 아는게 뭘까?

## 모르는 것들에 대해서..

여전히 안드로이드/iOS에서 어떻게 React Native가 Wrapping되어 있는지 모르겠다.

안드/iOS 각각의 컴포넌트들을 JavaScript 단에서 호출할 수 있는 그 어떤 구조가 있다는 것도 알겠고, JavaScript로 코드를 작성하면 어떻게 컴파일 되어서 Native코드로 변경되는 것도 알긴하는데, 이건 거의 뭐 모른다고 봐야지. 컴파일? 컴파일이 맞긴 한걸까.

요즘 일하면서 답답할 때가 있는데 생각해보니 이런 부분이 마음에 안드는 것 같다.

안드/iOS에서 어떻게 RN이 wrapping되어서 같이 동작하는지? 그 메커니즘을 정확히 모른다.

### React Native앱을 켰을 때 각 플랫폼에서 어떻게 동작하는거야?

그리고 Native코드를 JavaScript 코드하고 같이 사용할 수 있어?

## React Native 앱 = JavaScript part + Native part

구 아키텍처에서는 RN은 `JavaScriptCore`라는 JavaScript엔진을 사용함. 이게 JavaScript VM(가상머신)임.

- iOS의 경우 `JavaScriptCore`가 내장되어 있어서 이를 사용함
- 안드로이드의 경우 어플리케이션 코드와 함께 엔진이 같이 번들링되어서 사용됨(그래서 안드로이드는 가장 간단한 앱도 사이즈가 좀 있음. 엔진이 같이 번들링되어 있어서)

그러면 두 영역이 서로 어떻게 소통하는가? 여기서 바로 `Bridge`의 개념이 등장. 이 `React Native Bridge`를 통해서 Native <-> JavaScript간 소통을 한다.

빌드를 하면 어떤 일이 일어나는가? `npx react-native run-ios` 혹은 `npx react-native run-android`와 같은 명령어를 실행했을 때 어떤 일이 일어나는지 보자.

1. React Native CLI(React Native 프로젝트 관리도구라고 볼 수 있음)가 node 패키징/번들링 도구(대부분의 경우 metro이다.)를 활성화시키고 metro를 통해서 JavaScript 코드를 `main.bundle.js` 파일로 번들링한다.
2. CLI가 Native코드의 엔트리 포인트(앱의 시작점)을 로딩함.
3. Native 스레드가 JavaScript 스레들을 활성화한다.
4. RN브릿지를 통해서 Native스레드가 JavaScript앱을 활성화한다.
5. JavaScript스레드가 브릿지를 통해서 Native스레드에 요청을 보내기 시작함.(JavaScript앱에 있는 코드를 기반으로겠지?) 어떤 View를 로드할지, 하드웨어에서 어떤 정보를 가져올지 등등
6. Native스레드는 이 명령들을 수행한 후 JavaScript스레드에 응답을 보낸다.

### 스레딩 모델

메인 스레드

- 어플리케이션이 실행되면 바로 새로운 스레드가 생성된다.
- 생성된 스레드는 바로 앱을 로딩하고 JS스레드를 생성해서 JavaScript코드를 실행한다.
- JavaScript코드가 로딩된 후에는 렌더링에 필요한 정보를 브릿지를 통해서 전송한다. 이 정보는 레이아웃 계산을 담당하는 shadow node 스레드에 전달되고, 처리된 계산이 합쳐져서 최종적으로 메인 스레드로 전달되어서 View가 렌더링 됨.

JS 스레드

- 번들링된 JS코드를 실행하는 스레드이다. 비즈니스 로직 실행을 담당함.

커스텀 네이티브 모듈

- 성능개선을 위해서 별도의 스레드를 생성해서 어떤 작업을 처리할 수도 있음. 예를 들어 JS스레드의 부하를 경감하기 위해서 애니메이션을 처리하는 별도의 스레드가 사용된다.

### 음 이해를 했을까?

간단하게 생각하면, React Native앱이 동작하는 방식은 이렇다는 거네.

각 플랫폼별로 빌드된 파일을 실행하면

- 네이티브 코드 실행됨(앱 진입점부터 생각해보자)

  - android의 경우 MainActivity.java 파일의 onCreate 함수일 것이고,
  - iOS의 경우 아마 main이라고 네이밍된 파일의 main함수가 아닐까 싶다.

- 실행되면 네이티브 스레드가 JS스레드 생성함 -> JS스레드가 생성되면 JavaScript파일을 로딩함(이 파일이 Metro번들러가 생성한 단일 파일이겠지?)
- JavaScript파일이 로딩되면, JavaScript코드를 실행해서 어떤 UI가 렌더링되어야하는지에 대한 정보를 네이티브 스레드로 전송하기 시작함.
- 이 정보는 별도의 shadow스레드에 의해서 레이아웃 계산이 처리되어서 네이티브스레드는 이 정보를 기반으로 실제 뷰를 렌더링 한다.

이런 느낌으로 처리가 된다는거구나.

## 근데 그러면 네이티브 코드는 어디서 정보를 불러오게 되는거야?

최초에 네이티브 코드가 실행되어야 하는데, 이 정보는 어디서 불러오는거임?

네이티브 코드는 `컴파일`되어서 이 또한 번들링 된다.

- Android App bundle -> 앱의 컴파일된 코드와 리소스를 포함하고 있는 파일

빌드를 하게 되면, JavaScript코드는 하나의 `main.bundle.js`파일로 번들링되고(by metro) 각 플랫폼별 네이티브 코드는 각각 컴파일 되어서 .apk/.ipa 파일로 생성된다.

이 파일을 실행하며 네이티브 코드 -> 자바스크립트 스레드 실행 -> 스레드에서 자바스크립트 코드 실행 -> 네이티브 스레드에서 UI 렌더링 순으로 처리되게 된다.
