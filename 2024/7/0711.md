# RN앱에서 글로벌하게 사용될 fontFamily값을 설정하는 과정에서 했던 고민들, 그리고 관련해서 배운 점.

RN앱이 실행되면, 다음 단계를 거친다.

Bootsplash 표시(네이티브 단에서 구현된다. 왜냐하면 이게 JavaScript단에서 이루어지지 않기 때문이다.)

JavaScript 스레드를 활성화하려면, 결국 Native스레드가 먼저 실행되어야 하는데 이 Native Thread -> JavaScript 스레드로 이동하는 시점에서 빈 화면이 보이기 때문에 Native 단에서 표시될 이미지를 설정하고, 이를 비활성화(hide)할 수 있는 API를 JavaScript 단에 노출시켜서 앱이 로딩되는데 필요한 코드 실행이 완료된 시점에 hide를 해서 가리는 방법으로 사용된다.

Bootsplash가 가려지는 시점 전에 사실 앱 렌더링은 이미 이루어져있다.

조건은 아래와 같음.

- 앱을 실행한 후에 DB를 확인해서 설정된 언어값이 있다면 해당 언어값을 기준으로 처리하고, 아니면 시스템 언어를 기준으로 처리해야함
- CustomFont 컴포넌트에서 언어를 기준으로 설정된 static한 fontFamily라는 값을 참조해서 fontFamily를 렌더링해야함
- fontFamily값 조건
  - 글로벌하게 참조가능해야 한다.
  - 한 번 설정되면 앱 lifecycle동안 바뀔 일이 없는 값이다.
  - 하나의 컴포넌트에서만 사용된다.(커스텀 폰트 컴포넌트.)

이렇게 처리하기 위해서 어떻게 해야될까?

별도 폰트 관련을 기능을 모아둔 모듈이 필요할까?

fontFamily라는 static한 값은 어떻게 처리되어야 할까?

등등 의문들을 하나씩 처리하였음.

## 시도1. 가장 먼저 떠오른 방법을 시도

가장 간단한 방법은 특정 값을 설정해두고, getFontFamily등 함수가 실행된 값을 할당하는 것이다.

예를 들면

```javascript
// fontFamily라는 값을 어딘가에 선언하고,
let fontFamily = "";

// 앱 시작 시 fontFamily를 set한다. 언어에 따라서.
function setFontFamily(language) {
  fontFamily = "someFont";
}

// 그리고 이 값을 참조할 수 있는 함수를 만들어서 이를 style의 fontFamily값에 할당한다.

export function getFontFamily() {
  return fontFamily;
}

// 함수를 import해서 커스텀 폰트 컴포넌트에서 사용
style = {
  fontFamily: getFontFamily(),
};
```

가장 간단하고 직관적인 방법이라고 생각했다.

다만 이 방법에서 내가 마음에 안드는 부분이 있었는데, 컴포넌트 안에서 getFontFamily()라는 함수를 호출해서 값을 할당하는 형태로 구현하면, fontFamily라는 값이 호출되는 시점이나 컨텍스트와 무관하게 동일하는 값을 반환하는 함수인데 계속 호출되는 것이 문제라고 판단하였다.

이것은 2가지 점에서 문제라고 인식했는데,

1. 폰트 컴포넌트는 정말 여러 군데서 사용되는데 매번 같은 값을 얻기 위해서 함수를 호출한다는게 불필요한 동작으로 느껴짐.
2. 함수를 호출하는 형태로 fontFamily를 할당하다보니까 fontFamily가 해당 함수가 실행되는 조건이 변경되면 다른 값으로 할당되어야 해서 이렇게 구현했나? 하는 생각이 들 것 같았음.
3. 다른 어떤 방법들이 있을지 딱 떠오르지 않음. 즉 방법별로 장단을 인지한 상태에서 적절한 해답을 선택하는게 아니라 습관적으로 작성하던 코드임.

그래서 이 문제를 개선하려고 다음 생각의 흐름단계로 넘어가게 되었음.

### 어떻게 함수가 불필요하게 여러 번 호출되는 것을 방지할 수 있을까?

가장 먼저 떠오른 방법은 컴포넌트 밖으로 함수 호출을 빼서, 컴포넌트 글로벌 scope에 선언한 변수에 할당하고 해당 변수를 사용하는 것이었다.

시도해본 결과, 당연히 함수 호출 자체는 한 번만 되지만 문제는 함수 호출 타이밍이 내가 원하는 타이밍이 아니었다는 점이다.

내가 생각했을 때 내가 원하는 흐름은 다음과 같다.

앱이 실행됨 -> useEffect의 init이 실행 -> useEffect안에서 처리된 language값을 활용해서 글로벌 폰트 값 set
-> 컴포넌트 글로벌 font 참조함수 실행 -> 값 할당 -> 할당된 값을 컴포넌트에서 참조

이런 순서로 실행되는게 필요했는데, 정작 호출되는 방식은 다음과 같았다.

컴포넌트 글로벌 스코프에서 참조함수 실행(이 시점에 글로벌 영역에 선언한 변수에는 이미 함수 호출의 결과값인 default 값이 할당됨) -> useEffect의 init실행 -> language set하는 함수 실행

여기서 문제는, 컴포넌트에 선언한 변수가 함수가 다시 호출되지 않으니까 값이 초기에 호출된 결과값인, 아직 set 함수가 실행되기 전의 초기값이 남아있었다.

그래서 이렇게만 해서는 문제가 해결되지 않았음.

컴포넌트 밖 영역에서 함수를 한 번만 호출해서 할당된 값을 활용하려면 다른 메커니즘이 필요하다.

### 어떻게 시점이 어긋나는 문제를 해결하고, 업데이트 된 값을 잘 참조하도록 할 수 있을까?

내가 생각했을 때, 방법이 2가지 있었다.

1.  state management를 이용한다. like zustand
2.  컴포넌트 밖에 선언한 변수가 특정 변수를 참조하고, 해당 변수가 변화되었을 때 이를 인지할 수 있도록 구현

나는 이 문제를 해결하기 위해서 zustand를 사용하고 싶지 않았다. 왜냐하면 이 값은 한 번 설정되면 다시 변경될 일이 없었기 때문에, 굳이 store를 하나 만들어서 상태를 관리할 필요가 없다고 생각했기 때문이다.

그래서 2번째 방법인, 특정 변수를 고정으로 선언하고 해당 변수가 변경될 때 이것이 반영될 수 있도록 하는 메커니즘을 만드는 방향으로 가야겠다고 결론을 내렸다.

### 한 ES6 모듈에서 선언한 값을 다른 모듈에서 참조하는 방법들에 대해서 조사

먼저, font를 왜 CustomFont.jsx 모듈 안에서 처리하지 않았냐 하면 가장 큰 이유는 의도치 않은 값 변경을 막고자 함이었다.

앱 실행 시점에는 언어를 알지 못하는 상태에서 앱이 실행된 이후에 실행되는 useEffect안에서 값이 할당되어야 하므로, let 변수로 선언하거나 객체값으로 선언해야한다.

여러 가지 값이나 로직이 필요하지 않기 때문에 단일 변수로 선언해도 괜찮겠다고 판단하였는데, 문제는 이 변수를 바로 export해서 쓸 수 없다는 점에 있었다.

애초에 font를 CustomFont.jsx 모듈 안에 변수로 선언해서 사용하지 않은 이유가 의도치 않은 값의 변경을 막고자 함이었는데, 바로 let변수를 외부 모듈에 노출시키면 마찬가지로 import해서 참조만 하는 것이 아니라 바로 변경이 가능하기 때문이다.

그래서 let 변수는 모듈 내부 변수로 선언하고, 이를 외부로 값을 참조만 할 수 있도록 expose시키는 방법이 필요했다.

앞서 말했던 것처럼 당장 떠오른 방법은 간단하게 fontFamily변수를 return하는 함수를 만드는 것이었다.

하지만 위에서 언급한 이유로 그 방법들은 선택하고 싶지 않았기 때문에 다른 방법을 고민해보았다.

요즘 유행하는 Claude에게 질문했더니, 같은 모듈 안에 getter메서드가 존재하는 객체를 하나 만들고 해당 객체의 getter를 참조하는 형태로 구현하는 방식을 추천해줬다.

처음에는 오 이게 딱 내가 원했던 방법이야 라는 생각이 들었다. 심지어 해당 값이 변경되면 이 값이 변경되는 것을 받아볼 수 있다니. 딱좋아

그런데 아니 그래도 이게 함수인데, 그냥 직접 접근하는 거랑 무슨 차이가 있나 하는 생각이 들어서 찾아보았다.

그랬더니....getter함수는 사용은 마치 property에 접근하는 것처럼 보이지만, 실상은 매번 값이 참조될 때마다 getter함수가 실행되는 형태로 처리된다.

그렇다는 것은... 내가 함수를 호출하는 형태로 처리하고 싶지 않았던 이유중 하나인 함수 호출이 불필요하게 이뤄지는 것을 방지한다가 성립하지 않는다는 의미가 된다.

그래도 값을 호출하는 방식이 마치 객체 프로퍼티를 직접 참조하는 형태처럼 보여서, 함수를 호출하는 형태라서 뭔가 값이 조건에 따라서 바뀔 수 있는 것 같은 느낌을 주는 것은 방지할 수 있다.

### 음... 근데 그래도 뭔가 값을 안전하게 직접 참조할 수 있는 방법은 없을까?

getter 메서드를 사용하는 방식에 대해서 더 찾아보니, 어떤 상황에서 사용하는 것이 추천되냐면 어떤 값을 가져올 때 특정 로직을 실행하고 싶을 때라고 하는 경우가 많았다.

즉, 미들웨어같은 느낌으로 특정 값을 compute해서 가져오고 싶을 때 유용하다(이는 setter function 도 마찬가지)

나는 그냥 그 값을 바로 참조하고 싶을 뿐인데, 이게 최적의 솔루션은 아닐 것 같다는 생각이 들었다.

그래서 또 고민을 좀 하면서 이런 저런 자료를 찾아보던 중에 Object.freeze를 사용하면 어떨까 하는 영감을 얻었음.

### Object.freeze로 어떻게 이 문제를 해결해볼 수 있을까?

내가 원하는 것은,

- 한 번 설정하고 다시 값을 설정할 수 없어야함(writable - false)
- 값을 별다른 처리없이 바로 접근할 수 있으면 좋겠다. 왜냐하면 단순 string값임.

`Object.freeze`를 사용하면 나름대로 이 두 가지 목적을 충족시킬 수 있겠다는 생각이 들었다.

```javascript

// font.js
export const fontFamily {
  value: null;
}

export const setFont() {
  if(fontFamily.value === null) {
    value = 'someFont';
    Object.freeze(fontFamily); // 값을 최초에 set한 다음에 Object를 얼려서 값 재할당이 처리되지 않도록 변경한다.
  }
}

// 객체가 의도치 않게 변경될 가능성이 많이 줄어든 상태이기 때문에 비교적 안전하게 바로 외부로 객체를 노출시켜서, 필요한 곳에서 property를 바로 참조할 수 있다.
```

오호. 약간 내가 문제라고 생각했던 부분들을 어느정도 해결하는 해결책이라는 생각이 들었다.

이러면 이제 값을 바로 참조하니까 굳이 함수가 여러번 호출될 필요도 없고, fontFamily값이 재할당되어도 write되지 않으므로 안전하게 값을 참조할 수 있음.

음.. 일단 이렇게 가보자.

## 배운 점

- getter/setter 및 유용한 상황들
- Object.freeze로 문제를 풀어보는 경험
- es6 모듈에서 값이 초기화 되는 시점에 대한 이해(참조와 연관이 있다는 점)
- 값의 특성을 고려해서 적절하게 값을 할당하고 참조할 수 있는 구조에 대한 고민
